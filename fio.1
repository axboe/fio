.TH fio 1 "May 2025" "User Manual"
.SH NAME
fio \- flexible I/O tester
.SH SYNOPSIS
.B fio
[\fIoptions\fR] [\fIjobfile\fR]...
.SH DESCRIPTION
.B fio
is a tool that will spawn a number of threads or processes doing a
particular type of I/O action as specified by the user.
The typical use of fio is to write a job file matching the I/O load
one wants to simulate.
.SH OPTIONS
.TP
.BI \-\-debug \fR=\fPtype
Enable verbose tracing \fItype\fR of various fio actions. May be `all' for all \fItype\fRs
or individual types separated by a comma (e.g. `\-\-debug=file,mem' will enable
file and memory debugging). `help' will list all available tracing options.
.TP
.BI \-\-parse\-only
Parse options only, don't start any I/O.
.TP
.BI \-\-merge\-blktrace\-only
Merge blktraces only, don't start any I/O.
.TP
.BI \-\-output \fR=\fPfilename
Write output to \fIfilename\fR.
.TP
.BI \-\-output\-format \fR=\fPformat
Set the reporting \fIformat\fR to `normal', `terse', `json', or
`json+'. Multiple formats can be selected, separate by a comma. `terse'
is a CSV based format. `json+' is like `json', except it adds a full
dump of the latency buckets.
.TP
.BI \-\-bandwidth\-log
Generate aggregate bandwidth logs.
.TP
.BI \-\-minimal
Print statistics in a terse, semicolon\-delimited format.
.TP
.BI \-\-append\-terse
Print statistics in selected mode AND terse, semicolon\-delimited format.
\fBDeprecated\fR, use \fB\-\-output\-format\fR instead to select multiple formats.
.TP
.BI \-\-terse\-version \fR=\fPversion
Set terse \fIversion\fR output format (default `3', or `2', `4', `5').
.TP
.BI \-\-version
Print version information and exit.
.TP
.BI \-\-help
Print a summary of the command line options and exit.
.TP
.BI \-\-cpuclock\-test
Perform test and validation of internal CPU clock.
.TP
.BI \-\-crctest \fR=\fP[test]
Test the speed of the built\-in checksumming functions. If no argument is given,
all of them are tested. Alternatively, a comma separated list can be passed, in which
case the given ones are tested.
.TP
.BI \-\-cmdhelp \fR=\fPcommand
Print help information for \fIcommand\fR. May be `all' for all commands.
.TP
.BI \-\-enghelp \fR=\fP[ioengine[,command]]
List all commands defined by \fIioengine\fR, or print help for \fIcommand\fR
defined by \fIioengine\fR. If no \fIioengine\fR is given, list all
available ioengines.
.TP
.BI \-\-showcmd
Convert given \fIjobfile\fRs to a set of command\-line options.
.TP
.BI \-\-readonly
Turn on safety read\-only checks, preventing writes and trims. The \fB\-\-readonly\fR
option is an extra safety guard to prevent users from accidentally starting
a write or trim workload when that is not desired. Fio will only modify the
device under test if `rw=write/randwrite/rw/randrw/trim/randtrim/trimwrite'
is given. This safety net can be used as an extra precaution.
.TP
.BI \-\-eta \fR=\fPwhen
Specifies when real\-time ETA estimate should be printed. \fIwhen\fR may
be `always', `never' or `auto'. `auto' is the default, it prints ETA when
requested if the output is a TTY. `always' disregards the output type, and
prints ETA when requested. `never' never prints ETA.
.TP
.BI \-\-eta\-interval \fR=\fPtime
By default, fio requests client ETA status roughly every second. With this
option, the interval is configurable. Fio imposes a minimum allowed time to
avoid flooding the console, less than 250 msec is not supported.
.TP
.BI \-\-eta\-newline \fR=\fPtime
Force a new line for every \fItime\fR period passed. When the unit is omitted,
the value is interpreted in seconds.
.TP
.BI \-\-status\-interval \fR=\fPtime
Force a full status dump of cumulative (from job start) values at \fItime\fR
intervals. This option does *not* provide per-period measurements. So
values such as bandwidth are running averages. When the time unit is omitted,
\fItime\fR is interpreted in seconds. Note that using this option with
`\-\-output-format=json' will yield output that technically isn't valid json,
since the output will be collated sets of valid json. It will need to be split
into valid sets of json after the run.
.TP
.BI \-\-section \fR=\fPname
Only run specified section \fIname\fR in job file. Multiple sections can be specified.
The \fB\-\-section\fR option allows one to combine related jobs into one file.
E.g. one job file could define light, moderate, and heavy sections. Tell
fio to run only the "heavy" section by giving `\-\-section=heavy'
command line option. One can also specify the "write" operations in one
section and "verify" operation in another section. The \fB\-\-section\fR option
only applies to job sections. The reserved *global* section is always
parsed and used.
.TP
.BI \-\-alloc\-size \fR=\fPkb
Allocate additional internal smalloc pools of size \fIkb\fR in KiB. The
\fB\-\-alloc\-size\fR option increases shared memory set aside for use by fio.
If running large jobs with randommap enabled, fio can run out of memory.
Smalloc is an internal allocator for shared structures from a fixed size
memory pool and can grow to 16 pools. The pool size defaults to 16MiB.
NOTE: While running `.fio_smalloc.*' backing store files are visible
in `/tmp'.
.TP
.BI \-\-warnings\-fatal
All fio parser warnings are fatal, causing fio to exit with an error.
.TP
.BI \-\-max\-jobs \fR=\fPnr
Set the maximum number of threads/processes to support to \fInr\fR.
NOTE: On Linux, it may be necessary to increase the shared-memory limit
(`/proc/sys/kernel/shmmax') if fio runs into errors while creating jobs.
.TP
.BI \-\-server \fR=\fPargs
Start a backend server, with \fIargs\fR specifying what to listen to.
See \fBCLIENT/SERVER\fR section.
.TP
.BI \-\-daemonize \fR=\fPpidfile
Background a fio server, writing the pid to the given \fIpidfile\fR file.
.TP
.BI \-\-client \fR=\fPhostname
Instead of running the jobs locally, send and run them on the given \fIhostname\fR
or set of \fIhostname\fRs. See \fBCLIENT/SERVER\fR section.
.TP
.BI \-\-remote\-config \fR=\fPfile
Tell fio server to load this local \fIfile\fR.
.TP
.BI \-\-idle\-prof \fR=\fPoption
Report CPU idleness. \fIoption\fR is one of the following:
.RS
.RS
.TP
.B calibrate
Run unit work calibration only and exit.
.TP
.B system
Show aggregate system idleness and unit work.
.TP
.B percpu
As \fBsystem\fR but also show per CPU idleness.
.RE
.RE
.TP
.BI \-\-inflate\-log \fR=\fPlog
Inflate and output compressed \fIlog\fR.
.TP
.BI \-\-trigger\-file \fR=\fPfile
Execute trigger command when \fIfile\fR exists.
.TP
.BI \-\-trigger\-timeout \fR=\fPtime
Execute trigger at this \fItime\fR.
.TP
.BI \-\-trigger \fR=\fPcommand
Set this \fIcommand\fR as local trigger.
.TP
.BI \-\-trigger\-remote \fR=\fPcommand
Set this \fIcommand\fR as remote trigger.
.TP
.BI \-\-aux\-path \fR=\fPpath
Use the directory specified by \fIpath\fP for generated state files instead
of the current working directory.
.SH "JOB FILE FORMAT"
Any parameters following the options will be assumed to be job files, unless
they match a job file parameter. Multiple job files can be listed and each job
file will be regarded as a separate group. Fio will \fBstonewall\fR execution
between each group.

Fio accepts one or more job files describing what it is
supposed to do. The job file format is the classic ini file, where the names
enclosed in [] brackets define the job name. You are free to use any ASCII name
you want, except *global* which has special meaning. Following the job name is
a sequence of zero or more parameters, one per line, that define the behavior of
the job. If the first character in a line is a ';' or a '#', the entire line is
discarded as a comment.

A *global* section sets defaults for the jobs described in that file. A job may
override a *global* section parameter, and a job file may even have several
*global* sections if so desired. A job is only affected by a *global* section
residing above it.

The \fB\-\-cmdhelp\fR option also lists all options. If used with an \fIcommand\fR
argument, \fB\-\-cmdhelp\fR will detail the given \fIcommand\fR.

See the `examples/' directory for inspiration on how to write job files. Note
the copyright and license requirements currently apply to
`examples/' files.

Note that the maximum length of a line in the job file is 8192 bytes.
.SH "JOB FILE PARAMETERS"
Some parameters take an option of a given type, such as an integer or a
string. Anywhere a numeric value is required, an arithmetic expression may be
used, provided it is surrounded by parentheses. Supported operators are:
.RS
.P
.B addition (+)
.P
.B subtraction (\-)
.P
.B multiplication (*)
.P
.B division (/)
.P
.B modulus (%)
.P
.B exponentiation (^)
.RE
.P
For time values in expressions, units are microseconds by default. This is
different than for time values not in expressions (not enclosed in
parentheses).
.SH "PARAMETER TYPES"
The following parameter types are used.
.TP
.I str
String. A sequence of alphanumeric characters.
.TP
.I time
Integer with possible time suffix. Without a unit value is interpreted as
seconds unless otherwise specified. Accepts a suffix of 'd' for days, 'h' for
hours, 'm' for minutes, 's' for seconds, 'ms' (or 'msec') for milliseconds and 'us'
(or 'usec') for microseconds. For example, use 10m for 10 minutes.
.TP
.I int
Integer. A whole number value, which may contain an integer prefix
and an integer suffix.
.RS
.RS
.P
[*integer prefix*] **number** [*integer suffix*]
.RE
.P
The optional *integer prefix* specifies the number's base. The default
is decimal. *0x* specifies hexadecimal.
.P
The optional *integer suffix* specifies the number's units, and includes an
optional unit prefix and an optional unit. For quantities of data, the
default unit is bytes. For quantities of time, the default unit is seconds
unless otherwise specified.
.P
With `kb_base=1000', fio follows international standards for unit
prefixes. To specify power-of-10 decimal values defined in the
International System of Units (SI):
.RS
.P
.PD 0
K means kilo (K) or 1000
.P
M means mega (M) or 1000**2
.P
G means giga (G) or 1000**3
.P
T means tera (T) or 1000**4
.P
P means peta (P) or 1000**5
.PD
.RE
.P
To specify power-of-2 binary values defined in IEC 80000-13:
.RS
.P
.PD 0
Ki means kibi (Ki) or 1024
.P
Mi means mebi (Mi) or 1024**2
.P
Gi means gibi (Gi) or 1024**3
.P
Ti means tebi (Ti) or 1024**4
.P
Pi means pebi (Pi) or 1024**5
.PD
.RE
.P
For Zone Block Device Mode:
.RS
.P
.PD 0
z means Zone
.P
.PD
.RE
.P
With `kb_base=1024' (the default), the unit prefixes are opposite
from those specified in the SI and IEC 80000-13 standards to provide
compatibility with old scripts. For example, 4k means 4096.
.P
For quantities of data, an optional unit of 'B' may be included
(e.g., 'kB' is the same as 'k').
.P
The *integer suffix* is not case sensitive (e.g., m/mi mean mebi/mega,
not milli). 'b' and 'B' both mean byte, not bit.
.P
Examples with `kb_base=1000':
.RS
.P
.PD 0
4 KiB: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB
.P
1 MiB: 1048576, 1m, 1024k
.P
1 MB: 1000000, 1mi, 1000ki
.P
1 TiB: 1073741824, 1t, 1024m, 1048576k
.P
1 TB: 1000000000, 1ti, 1000mi, 1000000ki
.PD
.RE
.P
Examples with `kb_base=1024' (default):
.RS
.P
.PD 0
4 KiB: 4096, 4096b, 4096B, 4k, 4kb, 4kB, 4K, 4KB
.P
1 MiB: 1048576, 1m, 1024k
.P
1 MB: 1000000, 1mi, 1000ki
.P
1 TiB: 1073741824, 1t, 1024m, 1048576k
.P
1 TB: 1000000000, 1ti, 1000mi, 1000000ki
.PD
.RE
.P
To specify times (units are not case sensitive):
.RS
.P
.PD 0
D means days
.P
H means hours
.P
M mean minutes
.P
s or sec means seconds (default)
.P
ms or msec means milliseconds
.P
us or usec means microseconds
.PD
.RE
.P
`z' suffix specifies that the value is measured in zones.
Value is recalculated once block device's zone size becomes known.
.P
If the option accepts an upper and lower range, use a colon ':' or
minus '\-' to separate such values. See \fIirange\fR parameter type.
If the lower value specified happens to be larger than the upper value
the two values are swapped.
.RE
.TP
.I bool
Boolean. Usually parsed as an integer, however only defined for
true and false (1 and 0).
.TP
.I irange
Integer range with suffix. Allows value range to be given, such as
1024\-4096. A colon may also be used as the separator, e.g. 1k:4k. If the
option allows two sets of ranges, they can be specified with a ',' or '/'
delimiter: 1k\-4k/8k\-32k. Also see \fIint\fR parameter type.
.TP
.I float_list
A list of floating point numbers, separated by a ':' character.
.SH "JOB PARAMETERS"
With the above in mind, here follows the complete list of fio job parameters.
.SS "Units"
.TP
.BI kb_base \fR=\fPint
Select the interpretation of unit prefixes in input parameters.
.RS
.RS
.TP
.B 1000
Inputs comply with IEC 80000-13 and the International
System of Units (SI). Use:
.RS
.P
.PD 0
\- power-of-2 values with IEC prefixes (e.g., KiB)
.P
\- power-of-10 values with SI prefixes (e.g., kB)
.PD
.RE
.TP
.B 1024
Compatibility mode (default). To avoid breaking old scripts:
.P
.RS
.PD 0
\- power-of-2 values with SI prefixes
.P
\- power-of-10 values with IEC prefixes
.PD
.RE
.RE
.P
See \fBbs\fR for more details on input parameters.
.P
Outputs always use correct prefixes. Most outputs include both
side-by-side, like:
.P
.RS
bw=2383.3kB/s (2327.4KiB/s)
.RE
.P
If only one value is reported, then kb_base selects the one to use:
.P
.RS
.PD 0
1000 \-\- SI prefixes
.P
1024 \-\- IEC prefixes
.PD
.RE
.RE
.TP
.BI unit_base \fR=\fPint
Base unit for reporting. Allowed values are:
.RS
.RS
.TP
.B 0
Use auto-detection (default).
.TP
.B 8
Byte based.
.TP
.B 1
Bit based.
.RE
.RE
.SS "Job description"
.TP
.BI name \fR=\fPstr
ASCII name of the job. This may be used to override the name printed by fio
for this job. Otherwise the job name is used. On the command line this
parameter has the special purpose of also signaling the start of a new job.
.TP
.BI description \fR=\fPstr
Text description of the job. Doesn't do anything except dump this text
description when this job is run. It's not parsed.
.TP
.BI loops \fR=\fPint
Run the specified number of iterations of this job. Used to repeat the same
workload a given number of times. Defaults to 1.
.TP
.BI numjobs \fR=\fPint
Create the specified number of clones of this job. Each clone of job
is spawned as an independent thread or process. May be used to setup a
larger number of threads/processes doing the same thing. Each thread is
reported separately; to see statistics for all clones as a whole, use
\fBgroup_reporting\fR in conjunction with \fBnew_group\fR.
See \fB\-\-max\-jobs\fR. Default: 1.
.SS "Time related parameters"
.TP
.BI runtime \fR=\fPtime
Limit runtime. The test will run until it completes the configured I/O
workload or until it has run for this specified amount of time, whichever
occurs first. It can be quite hard to determine for how long a specified
job will run, so this parameter is handy to cap the total runtime to a
given time.  When the unit is omitted, the value is interpreted in
seconds.
.TP
.BI time_based
If set, fio will run for the duration of the \fBruntime\fR specified
even if the file(s) are completely read or written. It will simply loop over
the same workload as many times as the \fBruntime\fR allows.
.TP
.BI startdelay \fR=\fPirange(int)
Delay the start of job for the specified amount of time. Can be a single
value or a range. When given as a range, each thread will choose a value
randomly from within the range. Value is in seconds if a unit is omitted.
.TP
.BI ramp_time \fR=\fPtime
If set, fio will run the specified workload for this amount of time before
logging any performance numbers. Useful for letting performance settle
before logging results, thus minimizing the runtime required for stable
results. Note that the \fBramp_time\fR is considered lead in time for a job,
thus it will increase the total runtime if a special timeout or
\fBruntime\fR is specified. When the unit is omitted, the value is
given in seconds.
.TP
.BI clocksource \fR=\fPstr
Use the given clocksource as the base of timing. The supported options are:
.RS
.RS
.TP
.B gettimeofday
\fBgettimeofday\fR\|(2)
.TP
.B clock_gettime
\fBclock_gettime\fR\|(2)
.TP
.B cpu
Internal CPU clock source
.RE
.P
\fBcpu\fR is the preferred clocksource if it is reliable, as it is very fast (and
fio is heavy on time calls). Fio will automatically use this clocksource if
it's supported and considered reliable on the system it is running on,
unless another clocksource is specifically set. For x86/x86\-64 CPUs, this
means supporting TSC Invariant.
.RE
.TP
.BI gtod_reduce \fR=\fPbool
Enable all of the \fBgettimeofday\fR\|(2) reducing options
(\fBdisable_clat\fR, \fBdisable_slat\fR, \fBdisable_bw_measurement\fR) plus
reduce precision of the timeout somewhat to really shrink the
\fBgettimeofday\fR\|(2) call count. With this option enabled, we only do
about 0.4% of the \fBgettimeofday\fR\|(2) calls we would have done if all
time keeping was enabled.
.TP
.BI gtod_cpu \fR=\fPint
Sometimes it's cheaper to dedicate a single thread of execution to just
getting the current time. Fio (and databases, for instance) are very
intensive on \fBgettimeofday\fR\|(2) calls. With this option, you can set
one CPU aside for doing nothing but logging current time to a shared memory
location. Then the other threads/processes that run I/O workloads need only
copy that segment, instead of entering the kernel with a
\fBgettimeofday\fR\|(2) call. The CPU set aside for doing these time
calls will be excluded from other uses. Fio will manually clear it from the
CPU mask of other jobs.
.TP
.BI job_start_clock_id \fR=\fPint
The clock_id passed to the call to \fBclock_gettime\fR used to record job_start
in the \fBjson\fR output format. Default is 0, or CLOCK_REALTIME.
.SS "Target file/device"
.TP
.BI directory \fR=\fPstr
Prefix \fBfilename\fRs with this directory. Used to place files in a different
location than `./'. You can specify a number of directories by
separating the names with a ':' character. These directories will be
assigned equally distributed to job clones created by \fBnumjobs\fR as
long as they are using generated filenames. If specific \fBfilename\fR(s) are
set fio will use the first listed directory, and thereby matching the
\fBfilename\fR semantic (which generates a file for each clone if not
specified, but lets all clones use the same file if set).
.RS
.P
See the \fBfilename\fR option for information on how to escape ':'
characters within the directory path itself.
.P
Note: To control the directory fio will use for internal state files
use \fB\-\-aux\-path\fR.
.RE
.TP
.BI filename \fR=\fPstr
Fio normally makes up a \fBfilename\fR based on the job name, thread number, and
file number (see \fBfilename_format\fR). If you want to share files
between threads in a job or several
jobs with fixed file paths, specify a \fBfilename\fR for each of them to override
the default. If the ioengine is file based, you can specify a number of files
by separating the names with a ':' colon. So if you wanted a job to open
`/dev/sda' and `/dev/sdb' as the two working files, you would use
`filename=/dev/sda:/dev/sdb'. This also means that whenever this option is
specified, \fBnrfiles\fR is ignored. The size of regular files specified
by this option will be \fBsize\fR divided by number of files unless an
explicit size is specified by \fBfilesize\fR.
.RS
.P
Each colon in the wanted path must be escaped with a '\e'
character. For instance, if the path is `/dev/dsk/foo@3,0:c' then you
would use `filename=/dev/dsk/foo@3,0\\:c' and if the path is
`F:\\filename' then you would use `filename=F\\:\\filename'.
.P
On Windows, disk devices are accessed as `\\\\.\\PhysicalDrive0' for
the first device, `\\\\.\\PhysicalDrive1' for the second etc.
Note: Windows and FreeBSD prevent write access to areas
of the disk containing in-use data (e.g. filesystems).
.P
For HTTP and S3 access, specify a valid URL path or S3 key, respectively. 
A filename for path-style S3 includes a bucket name (`/bucket/k/e.y') 
while a virtual-hosted-style S3 filename (`/k/e.y') does not because its 
bucket name is specified in \fBhttp_host\fR.
.P
The filename `\-' is a reserved name, meaning *stdin* or *stdout*. Which
of the two depends on the read/write direction set.
.RE
.TP
.BI filename_format \fR=\fPstr
If sharing multiple files between jobs, it is usually necessary to have fio
generate the exact names that you want. By default, fio will name a file
based on the default file format specification of
`jobname.jobnumber.filenumber'. With this option, that can be
customized. Fio will recognize and replace the following keywords in this
string:
.RS
.RS
.TP
.B $jobname
The name of the worker thread or process.
.TP
.B $clientuid
IP of the fio process when using client/server mode.
.TP
.B $jobnum
The incremental number of the worker thread or process.
.TP
.B $filenum
The incremental number of the file for that worker thread or process.
.RE
.P
To have dependent jobs share a set of files, this option can be set to have
fio generate filenames that are shared between the two. For instance, if
`testfiles.$filenum' is specified, file number 4 for any job will be
named `testfiles.4'. The default of `$jobname.$jobnum.$filenum'
will be used if no other format specifier is given.
.P
If you specify a path then the directories will be created up to the main
directory for the file.  So for example if you specify `a/b/c/$jobnum` then the
directories a/b/c will be created before the file setup part of the job.  If you
specify \fBdirectory\fR then the path will be relative that directory, otherwise
it is treated as the absolute path.
.RE
.TP
.BI unique_filename \fR=\fPbool
To avoid collisions between networked clients, fio defaults to prefixing any
generated filenames (with a directory specified) with the source of the
client connecting. To disable this behavior, set this option to 0.
.TP
.BI filetype \fR=\fPstr
Assume that all files defined in a job are of this type. By default fio will do
\fBstat\fR\|(2) for each file to know its file type. For huge filesets it might
be a bottleneck, so the option can be used to skip the huge number of syscalls.
The file types are:
.RS
.RS
.TP
.B none
Unset. The default.
.TP
.B file
Regular file.
.TP
.B block
Block device file.
.TP
.B char
Char device file.
.RE
.RE
.TP
.BI opendir \fR=\fPstr
Recursively open any files below directory \fIstr\fR. This accepts only a
single directory and unlike related options, colons appearing in the path must
not be escaped.
.TP
.BI lockfile \fR=\fPstr
Fio defaults to not locking any files before it does I/O to them. If a file
or file descriptor is shared, fio can serialize I/O to that file to make the
end result consistent. This is usual for emulating real workloads that share
files. The lock modes are:
.RS
.RS
.TP
.B none
No locking. The default.
.TP
.B exclusive
Only one thread or process may do I/O at a time, excluding all others.
.TP
.B readwrite
Read\-write locking on the file. Many readers may
access the file at the same time, but writes get exclusive access.
.RE
.RE
.TP
.BI nrfiles \fR=\fPint
Number of files to use for this job. Defaults to 1. The size of files
will be \fBsize\fR divided by this unless explicit size is specified by
\fBfilesize\fR. Files are created for each thread separately, and each
file will have a file number within its name by default, as explained in
\fBfilename\fR section.
.TP
.BI openfiles \fR=\fPint
Number of files to keep open at the same time. Defaults to the same as
\fBnrfiles\fR, can be set smaller to limit the number simultaneous
opens.
.TP
.BI file_service_type \fR=\fPstr
Defines how fio decides which file from a job to service next. The following
types are defined:
.RS
.RS
.TP
.B random
Choose a file at random.
.TP
.B roundrobin
Round robin over opened files. This is the default.
.TP
.B sequential
Finish one file before moving on to the next. Multiple files can
still be open depending on \fBopenfiles\fR.
.TP
.B zipf
Use a Zipf distribution to decide what file to access.
.TP
.B pareto
Use a Pareto distribution to decide what file to access.
.TP
.B normal
Use a Gaussian (normal) distribution to decide what file to access.
.TP
.B gauss
Alias for normal.
.RE
.P
For \fBrandom\fR, \fBroundrobin\fR, and \fBsequential\fR, a postfix can be appended to
tell fio how many I/Os to issue before switching to a new file. For example,
specifying `file_service_type=random:8' would cause fio to issue
8 I/Os before selecting a new file at random. For the non-uniform
distributions, a floating point postfix can be given to influence how the
distribution is skewed. See \fBrandom_distribution\fR for a description
of how that would work.
.RE
.TP
.BI ioscheduler \fR=\fPstr
Attempt to switch the device hosting the file to the specified I/O scheduler
before running. If the file is a pipe, a character device file or if device
hosting the file could not be determined, this option is ignored.
.TP
.BI create_serialize \fR=\fPbool
If true, serialize the file creation for the jobs. This may be handy to
avoid interleaving of data files, which may greatly depend on the filesystem
used and even the number of processors in the system. Default: true.
.TP
.BI create_fsync \fR=\fPbool
\fBfsync\fR\|(2) the data file after creation. This is the default.
.TP
.BI create_on_open \fR=\fPbool
If true, don't pre-create files but allow the job's open() to create a file
when it's time to do I/O. Default: false \-\- pre-create all necessary files
when the job starts.
.TP
.BI create_only \fR=\fPbool
If true, fio will only run the setup phase of the job. If files need to be
laid out or updated on disk, only that will be done \-\- the actual job contents
are not executed. Default: false.
.TP
.BI allow_file_create \fR=\fPbool
If true, fio is permitted to create files as part of its workload. If this
option is false, then fio will error out if
the files it needs to use don't already exist. Default: true.
.TP
.BI allow_mounted_write \fR=\fPbool
If this isn't set, fio will abort jobs that are destructive (e.g. that write)
to what appears to be a mounted device or partition. This should help catch
creating inadvertently destructive tests, not realizing that the test will
destroy data on the mounted file system. Note that some platforms don't allow
writing against a mounted device regardless of this option. Default: false.
.TP
.BI pre_read \fR=\fPbool
If this is given, files will be pre-read into memory before starting the
given I/O operation. This will also clear the \fBinvalidate\fR flag,
since it is pointless to pre-read and then drop the cache. This will only
work for I/O engines that are seek-able, since they allow you to read the
same data multiple times. Thus it will not work on non-seekable I/O engines
(e.g. network, splice). Default: false.
.TP
.BI unlink \fR=\fPbool
Unlink (delete) the job files when done. Not the default, as repeated runs of that
job would then waste time recreating the file set again and again. Default:
false.
.TP
.BI unlink_each_loop \fR=\fPbool
Unlink (delete) job files after each iteration or loop. Default: false.
.TP
.BI zonemode \fR=\fPstr
Accepted values are:
.RS
.RS
.TP
.B none
The \fBzonerange\fR, \fBzonesize\fR \fBzonecapacity\fR and \fBzoneskip\fR
parameters are ignored.
.TP
.B strided
I/O happens in a single zone until \fBzonesize\fR bytes have been transferred.
After that number of bytes has been transferred processing of the next zone
starts. The \fBzonecapacity\fR parameter is ignored.
.TP
.B zbd
Zoned block device mode. I/O happens sequentially in each zone, even if random
I/O has been selected. Random I/O happens across all zones instead of being
restricted to a single zone.
Trim is handled using a zone reset operation. Trim only considers non-empty
sequential write required and sequential write preferred zones.
.RE
.RE
.TP
.BI zonerange \fR=\fPint
For \fBzonemode\fR=strided, this is the size of a single zone. See also
\fBzonesize\fR and \fBzoneskip\fR.

For \fBzonemode\fR=zbd, this parameter is ignored.
.TP
.BI zonesize \fR=\fPint
For \fBzonemode\fR=strided, this is the number of bytes to transfer before
skipping \fBzoneskip\fR bytes. If this parameter is smaller than
\fBzonerange\fR then only a fraction of each zone with \fBzonerange\fR bytes
will be accessed.  If this parameter is larger than \fBzonerange\fR then each
zone will be accessed multiple times before skipping to the next zone.

For \fBzonemode\fR=zbd, this is the size of a single zone. The
\fBzonerange\fR parameter is ignored in this mode. For a job accessing a
zoned block device, the specified \fBzonesize\fR must be 0 or equal to the
device zone size. For a regular block device or file, the specified
\fBzonesize\fR must be at least 512B.
.TP
.BI zonecapacity \fR=\fPint
For \fBzonemode\fR=zbd, this defines the capacity of a single zone, which is
the accessible area starting from the zone start address. This parameter only
applies when using \fBzonemode\fR=zbd in combination with regular block devices.
If not specified it defaults to the zone size. If the target device is a zoned
block device, the zone capacity is obtained from the device information and this
option is ignored.
.TP
.BI zoneskip \fR=\fPint[z]
For \fBzonemode\fR=strided, the number of bytes to skip after \fBzonesize\fR
bytes of data have been transferred.

For \fBzonemode\fR=zbd, the \fBzonesize\fR aligned number of bytes to skip
once a zone is fully written (write workloads) or all written data in the
zone have been read (read workloads). This parameter is valid only for
sequential workloads and ignored for random workloads. For read workloads,
see also \fBread_beyond_wp\fR.

.TP
.BI read_beyond_wp \fR=\fPbool
This parameter applies to \fBzonemode=zbd\fR only.

Zoned block devices are block devices that consist of multiple zones. Each
zone has a type, e.g. conventional or sequential. A conventional zone can be
written at any offset that is a multiple of the block size. Sequential zones
must be written sequentially. The position at which a write must occur is
called the write pointer. A zoned block device can be either host managed or
host aware. For host managed devices the host must ensure that writes happen
sequentially. Fio recognizes host managed devices and serializes writes to
sequential zones for these devices.

If a read occurs in a sequential zone beyond the write pointer then the zoned
block device will complete the read without reading any data from the storage
medium. Since such reads lead to unrealistically high bandwidth and IOPS
numbers fio only reads beyond the write pointer if explicitly told to do
so. Default: false.
.TP
.BI max_open_zones \fR=\fPint
When a zone of a zoned block device is partially written (i.e. not all sectors
of the zone have been written), the zone is in one of three
conditions: 'implicit open', 'explicit open' or 'closed'. Zoned block devices
may have a limit called 'max_open_zones' (same name as the parameter) on the
total number of zones that can simultaneously be in the 'implicit open'
or 'explicit open' conditions. Zoned block devices may have another limit
called 'max_active_zones', on the total number of zones that can simultaneously
be in the three conditions. The \fBmax_open_zones\fR parameter limits
the number of zones to which write commands are issued by all fio jobs, that is,
limits the number of zones that will be in the conditions. When the device has
the max_open_zones limit and does not have the max_active_zones limit, the
\fBmax_open_zones\fR parameter limits the number of zones in the two open
conditions up to the limit. In this case, fio includes zones in the two open
conditions to the write target zones at fio start. When the device has both the
max_open_zones and the max_active_zones limits, the \fBmax_open_zones\fR
parameter limits the number of zones in the three conditions up to the limit.
In this case, fio includes zones in the three conditions to the write target
zones at fio start.

This parameter is relevant only if the \fBzonemode=zbd\fR is used. The default
value is always equal to the max_open_zones limit of the target zoned block
device and a value higher than this limit cannot be specified by users unless
the option \fBignore_zone_limits\fR is specified. When \fBignore_zone_limits\fR
is specified or the target device does not have the max_open_zones limit,
\fBmax_open_zones\fR can specify 0 to disable any limit on the number of zones
that can be simultaneously written to by all jobs.
.TP
.BI job_max_open_zones \fR=\fPint
In the same manner as \fBmax_open_zones\fR, limit the number of open zones per
fio job, that is, the number of zones that a single job can simultaneously write
to. A value of zero indicates no limit. Default: zero.
.TP
.BI ignore_zone_limits \fR=\fPbool
If this option is used, fio will ignore the maximum number of open zones limit
of the zoned block device in use, thus allowing the option \fBmax_open_zones\fR
value to be larger than the device reported limit. Default: false.
.TP
.BI zone_reset_threshold \fR=\fPfloat
A number between zero and one that indicates the ratio of written bytes in the
zones with write pointers in the IO range to the size of the IO range. When
current ratio is above this ratio, zones are reset periodically as
\fBzone_reset_frequency\fR specifies. If there are multiple jobs when using this
option, the IO range for all write jobs has to be the same.
.TP
.BI zone_reset_frequency \fR=\fPfloat
A number between zero and one that indicates how often a zone reset should be
issued if the zone reset threshold has been exceeded. A zone reset is
submitted after each (1 / zone_reset_frequency) write requests. This and the
previous parameter can be used to simulate garbage collection activity.
.TP
.BI recover_zbd_write_error \fR=\fPbool
If this option is specified together with the option \fBcontinue_on_error\fR,
check the write pointer positions after the failed writes to sequential write
required zones. Then move the write pointers so that the next writes do not
fail due to partial writes and unexpected write pointer positions. If
\fBcontinue_on_error\fR is not specified, errors out. When the writes are
asynchronous, the write pointer move fills blocks with zero then breaks verify
data. If an asynchronous IO engine and \fBverify\fR workload are specified,
errors out. Default: false.

.SS "I/O type"
.TP
.BI direct \fR=\fPbool
If value is true, use non-buffered I/O. This is usually O_DIRECT. Note that
OpenBSD and ZFS on Solaris don't support direct I/O. On Windows the synchronous
ioengines don't support direct I/O. Default: false.
.TP
.BI buffered \fR=\fPbool
If value is true, use buffered I/O. This is the opposite of the
\fBdirect\fR option. Defaults to true.
.TP
.BI readwrite \fR=\fPstr "\fR,\fP rw" \fR=\fPstr
Type of I/O pattern. Accepted values are:
.RS
.RS
.TP
.B read
Sequential reads.
.TP
.B write
Sequential writes.
.TP
.B trim
Sequential trims (Linux block devices and SCSI character devices only).
.TP
.B randread
Random reads.
.TP
.B randwrite
Random writes.
.TP
.B randtrim
Random trims (Linux block devices and SCSI character devices only).
.TP
.B rw,readwrite
Sequential mixed reads and writes.
.TP
.B randrw
Random mixed reads and writes.
.TP
.B trimwrite
Sequential trim+write sequences. Blocks will be trimmed first,
then the same blocks will be written to. So if `io_size=64K' is specified,
Fio will trim a total of 64K bytes and also write 64K bytes on the same
trimmed blocks. This behaviour will be consistent with `number_ios' or
other Fio options limiting the total bytes or number of I/O's.
.TP
.B randtrimwrite
Like
.B trimwrite ,
but uses random offsets rather than sequential writes.
.RE
.P
Fio defaults to read if the option is not specified. For the mixed I/O
types, the default is to split them 50/50. For certain types of I/O the
result may still be skewed a bit, since the speed may be different.
.P
It is possible to specify the number of I/Os to do before getting a new
offset by appending `:<nr>' to the end of the string given. For a
random read, it would look like `rw=randread:8' for passing in an offset
modifier with a value of 8. If the suffix is used with a sequential I/O
pattern, then the `<nr>' value specified will be added to the generated
offset for each I/O turning sequential I/O into sequential I/O with holes.
For instance, using `rw=write:4k' will skip 4k for every write. Also see
the \fBrw_sequencer\fR option. If this is used with \fBverify\fR then
\fBverify_header_seed\fR option will be disabled, unless its explicitly
enabled.
.RE
.TP
.BI rw_sequencer \fR=\fPstr
If an offset modifier is given by appending a number to the `rw=\fIstr\fR'
line, then this option controls how that number modifies the I/O offset
being generated. Accepted values are:
.RS
.RS
.TP
.B sequential
Generate sequential offset.
.TP
.B identical
Generate the same offset.
.RE
.P
\fBsequential\fR is only useful for random I/O, where fio would normally
generate a new random offset for every I/O. If you append e.g. 8 to randread,
i.e. `rw=randread:8' you would get a new random offset for every 8 I/Os. The
result would be a sequence of 8 sequential offsets with a random starting
point.  However this behavior may change if a sequential I/O reaches end of the
file. As sequential I/O is already sequential, setting \fBsequential\fR for
that would not result in any difference. \fBidentical\fR behaves in a similar
fashion, except it sends the same offset 8 number of times before generating a
new offset.
.P
Example #1:
.RS
.P
.PD 0
rw=randread:8
.P
rw_sequencer=sequential
.P
bs=4k
.PD
.RE
.P
The generated sequence of offsets will look like this:
4k, 8k, 12k, 16k, 20k, 24k, 28k, 32k, 92k, 96k, 100k, 104k, 108k, 112k, 116k,
120k, 48k, 52k ...
.P
Example #2:
.RS
.P
.PD 0
rw=randread:8
.P
rw_sequencer=identical
.P
bs=4k
.PD
.RE
.P
The generated sequence of offsets will look like this:
4k, 4k, 4k, 4k, 4k, 4k, 4k, 4k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 92k, 48k,
48k, 48k ...
.RE
.TP
.BI unified_rw_reporting \fR=\fPstr
Fio normally reports statistics on a per data direction basis, meaning that
reads, writes, and trims are accounted and reported separately. This option
determines whether fio reports the results normally, summed together, or as
both options.
Accepted values are:
.RS
.TP
.B none
Normal statistics reporting.
.TP
.B mixed
Statistics are summed per data direction and reported together.
.TP
.B both
Statistics are reported normally, followed by the mixed statistics.
.TP
.B 0
Backward-compatible alias for \fBnone\fR.
.TP
.B 1
Backward-compatible alias for \fBmixed\fR.
.TP
.B 2
Alias for \fBboth\fR.
.RE
.TP
.BI randrepeat \fR=\fPbool
Seed all random number generators in a predictable way so the pattern is
repeatable across runs. Default: true.
.TP
.BI allrandrepeat \fR=\fPbool
Alias for \fBrandrepeat\fR. Default: true.
.TP
.BI randseed \fR=\fPint
Seed the random number generators based on this seed value, to be able to
control what sequence of output is being generated. If not set, the random
sequence depends on the \fBrandrepeat\fR setting.
.TP
.BI fallocate \fR=\fPstr
Whether pre-allocation is performed when laying down files.
Accepted values are:
.RS
.RS
.TP
.B none
Do not pre-allocate space.
.TP
.B native
Use a platform's native pre-allocation call but fall back to
\fBnone\fR behavior if it fails/is not implemented.
.TP
.B posix
Pre-allocate via \fBposix_fallocate\fR\|(3).
.TP
.B keep
Pre-allocate via \fBfallocate\fR\|(2) with
FALLOC_FL_KEEP_SIZE set.
.TP
.B truncate
Extend file to final size using \fBftruncate\fR|(2)
instead of allocating.
.TP
.B 0
Backward-compatible alias for \fBnone\fR.
.TP
.B 1
Backward-compatible alias for \fBposix\fR.
.RE
.P
May not be available on all supported platforms. \fBkeep\fR is only available
on Linux. If using ZFS on Solaris this cannot be set to \fBposix\fR
because ZFS doesn't support pre-allocation. Default: \fBnative\fR if any
pre-allocation methods except \fBtruncate\fR are available, \fBnone\fR if not.
.P
Note that using \fBtruncate\fR on Windows will interact surprisingly
with non-sequential write patterns. When writing to a file that has
been extended by setting the end-of-file information, Windows will
backfill the unwritten portion of the file up to that offset with
zeroes before issuing the new write. This means that a single small
write to the end of an extended file will stall until the entire
file has been filled with zeroes.
.RE
.TP
.BI fadvise_hint \fR=\fPstr
Use \fBposix_fadvise\fR\|(2) or \fBposix_madvise\fR\|(2) to advise the kernel
what I/O patterns are likely to be issued. Accepted values are:
.RS
.RS
.TP
.B 0
Backwards compatible hint for "no hint".
.TP
.B 1
Backwards compatible hint for "advise with fio workload type". This
uses FADV_RANDOM for a random workload, and FADV_SEQUENTIAL
for a sequential workload.
.TP
.B sequential
Advise using FADV_SEQUENTIAL.
.TP
.B random
Advise using FADV_RANDOM.
.TP
.B noreuse
Advise using FADV_NOREUSE. This may be a no-op on older Linux
kernels. Since Linux 6.3, it provides a hint to the LRU algorithm.
See the \fBposix_fadvise\fR\|(2) man page.
.RE
.RE
.TP
.BI write_hint \fR=\fPstr
Use \fBfcntl\fR\|(2) to advise the kernel what life time to expect
from a write. Only supported on Linux, as of version 4.13. Accepted
values are:
.RS
.RS
.TP
.B none
No particular life time associated with this file.
.TP
.B short
Data written to this file has a short life time.
.TP
.B medium
Data written to this file has a medium life time.
.TP
.B long
Data written to this file has a long life time.
.TP
.B extreme
Data written to this file has a very long life time.
.RE
.P
The values are all relative to each other, and no absolute meaning
should be associated with them.
.RE
.TP
.BI offset \fR=\fPint[%|z]
Start I/O at the provided offset in the file, given as either a fixed size in
bytes, zones or a percentage. If a percentage is given, the generated offset will be
aligned to the minimum \fBblocksize\fR or to the value of \fBoffset_align\fR if
provided. Data before the given offset will not be touched. This
effectively caps the file size at `real_size \- offset'. Can be combined with
\fBsize\fR to constrain the start and end range of the I/O workload.
A percentage can be specified by a number between 1 and 100 followed by '%',
for example, `offset=20%' to specify 20%. In ZBD mode, value can be set as
number of zones using 'z'.
.TP
.BI offset_align \fR=\fPint
If set to non-zero value, the byte offset generated by a percentage \fBoffset\fR
is aligned upwards to this value. Defaults to 0 meaning that a percentage
offset is aligned to the minimum block size.
.TP
.BI offset_increment \fR=\fPint[%|z]
If this is provided, then the real offset becomes `\fBoffset\fR + \fBoffset_increment\fR
* thread_number', where the thread number is a counter that starts at 0 and
is incremented for each sub-job (i.e. when \fBnumjobs\fR option is
specified). This option is useful if there are several jobs which are
intended to operate on a file in parallel disjoint segments, with even
spacing between the starting points. Percentages can be used for this option.
If a percentage is given, the generated offset will be aligned to the minimum
\fBblocksize\fR or to the value of \fBoffset_align\fR if provided.In ZBD mode, value
can be set as number of zones using 'z'.
.TP
.BI number_ios \fR=\fPint
Fio will normally perform I/Os until it has exhausted the size of the region
set by \fBsize\fR, or if it exhaust the allocated time (or hits an error
condition). With this setting, the range/size can be set independently of
the number of I/Os to perform. When fio reaches this number, it will exit
normally and report status. Note that this does not extend the amount of I/O
that will be done, it will only stop fio if this condition is met before
other end-of-job criteria.
.TP
.BI fsync \fR=\fPint
If writing to a file, issue an \fBfsync\fR\|(2) (or its equivalent) of
the dirty data for every number of blocks given. For example, if you give 32
as a parameter, fio will sync the file after every 32 writes issued. If fio is
using non-buffered I/O, we may not sync the file. The exception is the sg
I/O engine, which synchronizes the disk cache anyway. Defaults to 0, which
means fio does not periodically issue and wait for a sync to complete. Also
see \fBend_fsync\fR and \fBfsync_on_close\fR.
.TP
.BI fdatasync \fR=\fPint
Like \fBfsync\fR but uses \fBfdatasync\fR\|(2) to only sync data and
not metadata blocks. In Windows, DragonFlyBSD or OSX there is no
\fBfdatasync\fR\|(2) so this falls back to using \fBfsync\fR\|(2).
Defaults to 0, which means fio does not periodically issue and wait for a
data-only sync to complete.
.TP
.BI write_barrier \fR=\fPint
Make every N\-th write a barrier write.
.TP
.BI sync_file_range \fR=\fPstr:int
Use \fBsync_file_range\fR\|(2) for every \fIint\fR number of write
operations. Fio will track range of writes that have happened since the last
\fBsync_file_range\fR\|(2) call. \fIstr\fR can currently be one or more of:
.RS
.RS
.TP
.B wait_before
SYNC_FILE_RANGE_WAIT_BEFORE
.TP
.B write
SYNC_FILE_RANGE_WRITE
.TP
.B wait_after
SYNC_FILE_RANGE_WRITE_AFTER
.RE
.P
So if you do `sync_file_range=wait_before,write:8', fio would use
`SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE' for every 8
writes. Also see the \fBsync_file_range\fR\|(2) man page. This option is
Linux specific.
.RE
.TP
.BI overwrite \fR=\fPbool
If true, writes to a file will always overwrite existing data. If the file
doesn't already exist, it will be created before the write phase begins. If
the file exists and is large enough for the specified write phase, nothing
will be done. Default: false.
.TP
.BI end_fsync \fR=\fPbool
If true, \fBfsync\fR\|(2) file contents when a write stage has completed.
Default: false.
.TP
.BI fsync_on_close \fR=\fPbool
If true, fio will \fBfsync\fR\|(2) a dirty file on close. This differs
from \fBend_fsync\fR in that it will happen on every file close, not
just at the end of the job. Default: false.
.TP
.BI rwmixread \fR=\fPint
Percentage of a mixed workload that should be reads. Default: 50.
.TP
.BI rwmixwrite \fR=\fPint
Percentage of a mixed workload that should be writes. If both
\fBrwmixread\fR and \fBrwmixwrite\fR is given and the values do not
add up to 100%, the latter of the two will be used to override the
first. This may interfere with a given rate setting, if fio is asked to
limit reads or writes to a certain rate. If that is the case, then the
distribution may be skewed. Default: 50.
.TP
.BI random_distribution \fR=\fPstr:float[:float][,str:float][,str:float]
By default, fio will use a completely uniform random distribution when asked
to perform random I/O. Sometimes it is useful to skew the distribution in
specific ways, ensuring that some parts of the data is more hot than others.
fio includes the following distribution models:
.RS
.RS
.TP
.B random
Uniform random distribution
.TP
.B zipf
Zipf distribution
.TP
.B pareto
Pareto distribution
.TP
.B normal
Normal (Gaussian) distribution
.TP
.B zoned
Zoned random distribution
.B zoned_abs
Zoned absolute random distribution
.RE
.P
When using a \fBzipf\fR or \fBpareto\fR distribution, an input value is also
needed to define the access pattern. For \fBzipf\fR, this is the `Zipf theta'.
For \fBpareto\fR, it's the `Pareto power'. Fio includes a test
program, \fBfio\-genzipf\fR, that can be used visualize what the given input
values will yield in terms of hit rates. If you wanted to use \fBzipf\fR with
a `theta' of 1.2, you would use `random_distribution=zipf:1.2' as the
option. If a non\-uniform model is used, fio will disable use of the random
map. For the \fBnormal\fR distribution, a normal (Gaussian) deviation is
supplied as a value between 0 and 100.
.P
The second, optional float is allowed for \fBpareto\fR, \fBzipf\fR and \fBnormal\fR
distributions. It allows one to set base of distribution in non-default place, giving
more control over most probable outcome. This value is in range [0-1] which maps linearly to
range of possible random values.
Defaults are: random for \fBpareto\fR and \fBzipf\fR, and 0.5 for \fBnormal\fR.
If you wanted to use \fBzipf\fR with a `theta` of 1.2 centered on 1/4 of allowed value range,
you would use `random_distribution=zipf:1.2:0.25`.
.P
For a \fBzoned\fR distribution, fio supports specifying percentages of I/O
access that should fall within what range of the file or device. For
example, given a criteria of:
.RS
.P
.PD 0
60% of accesses should be to the first 10%
.P
30% of accesses should be to the next 20%
.P
8% of accesses should be to the next 30%
.P
2% of accesses should be to the next 40%
.PD
.RE
.P
we can define that through zoning of the random accesses. For the above
example, the user would do:
.RS
.P
random_distribution=zoned:60/10:30/20:8/30:2/40
.RE
.P
A \fBzoned_abs\fR distribution works exactly like the\fBzoned\fR, except that
it takes absolute sizes. For example, let's say you wanted to define access
according to the following criteria:
.RS
.P
.PD 0
60% of accesses should be to the first 20G
.P
30% of accesses should be to the next 100G
.P
10% of accesses should be to the next 500G
.PD
.RE
.P
we can define an absolute zoning distribution with:
.RS
.P
random_distribution=zoned:60/10:30/20:8/30:2/40
.RE
.P
For both \fBzoned\fR and \fBzoned_abs\fR, fio supports defining up to 256
separate zones.
.P
Similarly to how \fBbssplit\fR works for setting ranges and percentages
of block sizes. Like \fBbssplit\fR, it's possible to specify separate
zones for reads, writes, and trims. If just one set is given, it'll apply to
all of them.
.RE
.TP
.BI percentage_random \fR=\fPint[,int][,int]
For a random workload, set how big a percentage should be random. This
defaults to 100%, in which case the workload is fully random. It can be set
from anywhere from 0 to 100. Setting it to 0 would make the workload fully
sequential. Any setting in between will result in a random mix of sequential
and random I/O, at the given percentages. Comma-separated values may be
specified for reads, writes, and trims as described in \fBblocksize\fR.
.TP
.BI norandommap
Normally fio will cover every block of the file when doing random I/O. If
this option is given, fio will just get a new random offset without looking
at past I/O history. This means that some blocks may not be read or written,
and that some blocks may be read/written more than once. If this option is
used with \fBverify\fR then \fBverify_header_seed\fR will be disabled. If this
option is used with \fBverify\fR and multiple blocksizes (via \fBbsrange\fR),
only intact blocks are verified, i.e., partially-overwritten blocks are
ignored. With an async I/O engine and an I/O depth > 1, header write sequence
number verification will be disabled. See \fBverify_write_sequence\fR.
.TP
.BI softrandommap \fR=\fPbool
See \fBnorandommap\fR. If fio runs with the random block map enabled and
it fails to allocate the map, if this option is set it will continue without
a random block map. As coverage will not be as complete as with random maps,
this option is disabled by default.
.TP
.BI random_generator \fR=\fPstr
Fio supports the following engines for generating I/O offsets for random I/O:
.RS
.RS
.TP
.B tausworthe
Strong 2^88 cycle random number generator.
.TP
.B lfsr
Linear feedback shift register generator.
.TP
.B tausworthe64
Strong 64\-bit 2^258 cycle random number generator.
.RE
.P
\fBtausworthe\fR is a strong random number generator, but it requires tracking
on the side if we want to ensure that blocks are only read or written
once. \fBlfsr\fR guarantees that we never generate the same offset twice, and
it's also less computationally expensive. It's not a true random generator,
however, though for I/O purposes it's typically good enough. \fBlfsr\fR only
works with single block sizes, not with workloads that use multiple block
sizes. If used with such a workload, fio may read or write some blocks
multiple times. The default value is \fBtausworthe\fR, unless the required
space exceeds 2^32 blocks. If it does, then \fBtausworthe64\fR is
selected automatically.
.RE
.TP
.B sprandom=bool
SPRandom is a method designed to rapidly precondition SSDs for
steady-state random write workloads. It divides the device into
equally sized regions and writes the device's entire physical capacity
once, selecting offsets so that the regions have a distribution of
invalid blocks matching the distribution that occurs at steady state.
Default: false.

It uses \fBrandom_generator=lfsr\fR, which fio will set by default.
Selecting any other random generator will result in an error.
.TP
.B spr_num_regions=int
See
.BR sprandom .
Specifies the number of regions used for SPRandom. Default=100
.P
.RS
For large devices it is better to use more regions, to increase precision
and reduce memory allocation. The allocation is proportional to the region size.
.RE
.TP
.B spr_op=float
See
.BR sprandom .
Over-provisioning ratio in the range (0, 1), as specified by the SSD manufacturer.
The default is 0.15.
.RE
.SS "Block size"
.TP
.BI blocksize \fR=\fPint[,int][,int] "\fR,\fB bs" \fR=\fPint[,int][,int]
The block size in bytes used for I/O units. Default: 4096. A single value
applies to reads, writes, and trims. Comma-separated values may be
specified for reads, writes, and trims. A value not terminated in a comma
applies to subsequent types. Examples:
.RS
.RS
.P
.PD 0
bs=256k        means 256k for reads, writes and trims.
.P
bs=8k,32k      means 8k for reads, 32k for writes and trims.
.P
bs=8k,32k,     means 8k for reads, 32k for writes, and default for trims.
.P
bs=,8k         means default for reads, 8k for writes and trims.
.P
bs=,8k,        means default for reads, 8k for writes, and default for trims.
.PD
.RE
.RE
.TP
.BI blocksize_range \fR=\fPirange[,irange][,irange] "\fR,\fB bsrange" \fR=\fPirange[,irange][,irange]
A range of block sizes in bytes for I/O units. The issued I/O unit will
always be a multiple of the minimum size, unless
\fBblocksize_unaligned\fR is set.
Comma-separated ranges may be specified for reads, writes, and trims as
described in \fBblocksize\fR. Example:
.RS
.RS
.P
bsrange=1k\-4k,2k\-8k or bsrange=1k:4k,2k:8k
.RE
.RE
.TP
.BI bssplit \fR=\fPstr[,str][,str]
Sometimes you want even finer grained control of the block sizes issued, not
just an even split between them. This option allows you to weight various
block sizes, so that you are able to define a specific amount of block sizes
issued. The format for this option is:
.RS
.RS
.P
bssplit=blocksize/percentage:blocksize/percentage
.RE
.P
for as many block sizes as needed. So if you want to define a workload that
has 50% 64k blocks, 10% 4k blocks, and 40% 32k blocks, you would write:
.RS
.P
bssplit=4k/10:64k/50:32k/40
.RE
.P
Ordering does not matter. If the percentage is left blank, fio will fill in
the remaining values evenly. So a bssplit option like this one:
.RS
.P
bssplit=4k/50:1k/:32k/
.RE
.P
would have 50% 4k ios, and 25% 1k and 32k ios. The percentages always add up
to 100, if bssplit is given a range that adds up to more, it will error out.
.P
Comma-separated values may be specified for reads, writes, and trims as
described in \fBblocksize\fR.
.P
If you want a workload that has 50% 2k reads and 50% 4k reads, while having
90% 4k writes and 10% 8k writes, you would specify:
.RS
.P
bssplit=2k/50:4k/50,4k/90:8k/10
.RE
.P
Fio supports defining up to 64 different weights for each data direction.
.RE
.TP
.BI blocksize_unaligned "\fR,\fB bs_unaligned"
If set, fio will issue I/O units with any size within
\fBblocksize_range\fR, not just multiples of the minimum size. This
typically won't work with direct I/O, as that normally requires sector
alignment.
.TP
.BI bs_is_seq_rand \fR=\fPbool
If this option is set, fio will use the normal read,write blocksize settings
as sequential,random blocksize settings instead. Any random read or write
will use the WRITE blocksize settings, and any sequential read or write will
use the READ blocksize settings.
.TP
.BI blockalign \fR=\fPint[,int][,int] "\fR,\fB ba" \fR=\fPint[,int][,int]
Boundary to which fio will align random I/O units. Default:
\fBblocksize\fR. Minimum alignment is typically 512b for using direct
I/O, though it usually depends on the hardware block size. This option is
mutually exclusive with using a random map for files, so it will turn off
that option. Comma-separated values may be specified for reads, writes, and
trims as described in \fBblocksize\fR.
.SS "Buffers and memory"
.TP
.BI zero_buffers
Initialize buffers with all zeros. Default: fill buffers with random data.
.TP
.BI refill_buffers
If this option is given, fio will refill the I/O buffers on every
submit. The default is to only fill it at init time and reuse that
data. Only makes sense if zero_buffers isn't specified, naturally. If data
verification is enabled, \fBrefill_buffers\fR is also automatically enabled.
.TP
.BI scramble_buffers \fR=\fPbool
If \fBrefill_buffers\fR is too costly and the target is using data
deduplication, then setting this option will slightly modify the I/O buffer
contents to defeat normal de-dupe attempts. This is not enough to defeat
more clever block compression attempts, but it will stop naive dedupe of
blocks. Default: true.
.TP
.BI buffer_compress_percentage \fR=\fPint
If this is set, then fio will attempt to provide I/O buffer content
(on WRITEs) that compresses to the specified level. Fio does this by
providing a mix of random data followed by fixed pattern data. The
fixed pattern is either zeros, or the pattern specified by
\fBbuffer_pattern\fR. If the \fBbuffer_pattern\fR option is used, it
might skew the compression ratio slightly. Setting
\fBbuffer_compress_percentage\fR to a value other than 100 will also
enable \fBrefill_buffers\fR in order to reduce the likelihood that
adjacent blocks are so similar that they over compress when seen
together. See \fBbuffer_compress_chunk\fR for how to set a finer or
coarser granularity of the random/fixed data regions. Defaults to unset
i.e., buffer data will not adhere to any compression level.
.TP
.BI buffer_compress_chunk \fR=\fPint
This setting allows fio to manage how big the random/fixed data region
is when using \fBbuffer_compress_percentage\fR. When
\fBbuffer_compress_chunk\fR is set to some non-zero value smaller than the
block size, fio can repeat the random/fixed region throughout the I/O
buffer at the specified interval (which particularly useful when
bigger block sizes are used for a job). When set to 0, fio will use a
chunk size that matches the block size resulting in a single
random/fixed region within the I/O buffer. Defaults to 512. When the
unit is omitted, the value is interpreted in bytes.
.TP
.BI buffer_pattern \fR=\fPstr
If set, fio will fill the I/O buffers with this pattern or with the contents
of a file. If not set, the contents of I/O buffers are defined by the other
options related to buffer contents. The setting can be any pattern of bytes,
and can be prefixed with 0x for hex values. It may also be a string, where
the string must then be wrapped with "". Or it may also be a filename,
where the filename must be wrapped with '' in which case the file is
opened and read. Note that not all the file contents will be read if that
would cause the buffers to overflow. So, for example:
.RS
.RS
.P
.PD 0
buffer_pattern='filename'
.P
or:
.P
buffer_pattern="abcd"
.P
or:
.P
buffer_pattern=\-12
.P
or:
.P
buffer_pattern=0xdeadface
.PD
.RE
.P
Also you can combine everything together in any order:
.RS
.P
buffer_pattern=0xdeadface"abcd"\-12'filename'
.RE
.RE
.TP
.BI dedupe_percentage \fR=\fPint
If set, fio will generate this percentage of identical buffers when
writing. These buffers will be naturally dedupable. The contents of the
buffers depend on what other buffer compression settings have been set. It's
possible to have the individual buffers either fully compressible, or not at
all \-\- this option only controls the distribution of unique buffers. Setting
this option will also enable \fBrefill_buffers\fR to prevent every buffer
being identical.
.TP
.BI dedupe_mode \fR=\fPstr
If \fBdedupe_percentage\fR is given, then this option controls how fio
generates the dedupe buffers.
.RS
.RS
.TP
.B repeat
.P
.RS
Generate dedupe buffers by repeating previous writes
.RE
.TP
.B working_set
.P
.RS
Generate dedupe buffers from working set
.RE
.RE
.P
\fBrepeat\fR is the default option for fio. Dedupe buffers are generated
by repeating previous unique write.

\fBworking_set\fR is a more realistic workload.
With \fBworking_set\fR, \fBdedupe_working_set_percentage\fR should be provided.
Given that, fio will use the initial unique write buffers as its working set.
Upon deciding to dedupe, fio will randomly choose a buffer from the working set.
Note that by using \fBworking_set\fR the dedupe percentage will converge
to the desired over time while \fBrepeat\fR maintains the desired percentage
throughout the job.
.RE
.TP
.BI dedupe_working_set_percentage \fR=\fPint
If \fBdedupe_mode\fR is set to \fBworking_set\fR, then this controls
the percentage of size of the file or device used as the buffers
fio will choose to generate the dedupe buffers from
.P
.RS
Note that \fBsize\fR needs to be explicitly provided and only 1 file
per job is supported
.RE
.TP
.BI dedupe_global \fR=\fPbool
This controls whether the deduplication buffers will be shared amongst
all jobs that have this option set. The buffers are spread evenly between
participating jobs.
.P
.RS
Note that \fBdedupe_mode\fR must be set to \fBworking_set\fR for this to work.
Can be used in combination with compression
.TP
.BI invalidate \fR=\fPbool
Invalidate the buffer/page cache parts of the files to be used prior to
starting I/O if the platform and file type support it. Defaults to true.
This will be ignored if \fBpre_read\fR is also specified for the
same job.
.TP
.BI sync \fR=\fPstr
Whether, and what type, of synchronous I/O to use for writes.  The allowed
values are:
.RS
.RS
.TP
.B none
Do not use synchronous IO, the default.
.TP
.B 0
Same as \fBnone\fR.
.TP
.B sync
Use synchronous file IO. For the majority of I/O engines,
this means using O_SYNC.
.TP
.B 1
Same as \fBsync\fR.
.TP
.B dsync
Use synchronous data IO. For the majority of I/O engines,
this means using O_DSYNC.
.PD
.RE
.RE
.TP
.BI iomem \fR=\fPstr "\fR,\fP mem" \fR=\fPstr
Fio can use various types of memory as the I/O unit buffer. The allowed
values are:
.RS
.RS
.TP
.B malloc
Use memory from \fBmalloc\fR\|(3) as the buffers. Default memory type.
.TP
.B shm
Use shared memory as the buffers. Allocated through \fBshmget\fR\|(2).
.TP
.B shmhuge
Same as \fBshm\fR, but use huge pages as backing.
.TP
.B mmap
Use \fBmmap\fR\|(2) to allocate buffers. May either be anonymous memory, or can
be file backed if a filename is given after the option. The format
is `mem=mmap:/path/to/file'.
.TP
.B mmaphuge
Use a memory mapped huge file as the buffer backing. Append filename
after mmaphuge, ala `mem=mmaphuge:/hugetlbfs/file'.
.TP
.B mmapshared
Same as \fBmmap\fR, but use a MMAP_SHARED mapping.
.TP
.B cudamalloc
Use GPU memory as the buffers for GPUDirect RDMA benchmark.
The \fBioengine\fR must be \fBrdma\fR.
.RE
.P
The area allocated is a function of the maximum allowed bs size for the job,
multiplied by the I/O depth given. Note that for \fBshmhuge\fR and
\fBmmaphuge\fR to work, the system must have free huge pages allocated. This
can normally be checked and set by reading/writing
`/proc/sys/vm/nr_hugepages' on a Linux system. Fio assumes a huge page
is 2 or 4MiB in size depending on the platform. So to calculate the number of
huge pages you need for a given job file, add up the I/O depth of all jobs
(normally one unless \fBiodepth\fR is used) and multiply by the maximum bs set.
Then divide that number by the huge page size. You can see the size of the huge
pages in `/proc/meminfo'. If no huge pages are allocated by having a non-zero
number in `nr_hugepages', using \fBmmaphuge\fR or \fBshmhuge\fR will fail. Also
see \fBhugepage\-size\fR.
.P
\fBmmaphuge\fR also needs to have hugetlbfs mounted and the file location
should point there. So if it's mounted in `/huge', you would use
`mem=mmaphuge:/huge/somefile'.
.RE
.TP
.BI iomem_align \fR=\fPint "\fR,\fP mem_align" \fR=\fPint
This indicates the memory alignment of the I/O memory buffers. Note that
the given alignment is applied to the first I/O unit buffer, if using
\fBiodepth\fR the alignment of the following buffers are given by the
\fBbs\fR used. In other words, if using a \fBbs\fR that is a
multiple of the page sized in the system, all buffers will be aligned to
this value. If using a \fBbs\fR that is not page aligned, the alignment
of subsequent I/O memory buffers is the sum of the \fBiomem_align\fR and
\fBbs\fR used.
.TP
.BI hugepage\-size \fR=\fPint
Defines the size of a huge page. Must at least be equal to the system setting,
see `/proc/meminfo' and `/sys/kernel/mm/hugepages/'. Defaults to 2 or 4MiB
depending on the platform. Should probably always be a multiple of megabytes,
so using `hugepage\-size=Xm' is the preferred way to set this to avoid setting
a non-pow-2 bad value.
.TP
.BI lockmem \fR=\fPint
Pin the specified amount of memory with \fBmlock\fR\|(2). Can be used to
simulate a smaller amount of memory. The amount specified is per worker.
.SS "I/O size"
.TP
.BI size \fR=\fPint[%|z]
The total size of file I/O for each thread of this job. Fio will run until
this many bytes has been transferred, unless runtime is altered by other means
such as (1) \fBruntime\fR, (2) \fBio_size\fR, (3) \fBnumber_ios\fR, (4)
gaps/holes while doing I/O's such as `rw=read:16K', or (5) sequential I/O
reaching end of the file which is possible when \fBpercentage_random\fR is
less than 100.
Fio will divide this size between the available files determined by options
such as \fBnrfiles\fR, \fBfilename\fR, unless \fBfilesize\fR is
specified by the job. If the result of division happens to be 0, the size is
set to the physical size of the given files or devices if they exist.
If this option is not specified, fio will use the full size of the given
files or devices. If the files do not exist, size must be given. It is also
possible to give size as a percentage between 1 and 100. If `size=20%' is
given, fio will use 20% of the full size of the given files or devices. In ZBD mode,
size can be given in units of number of zones using 'z'. Can be combined with \fBoffset\fR to
constrain the start and end range that I/O will be done within.
.TP
.BI io_size \fR=\fPint[%|z] "\fR,\fB io_limit" \fR=\fPint[%|z]
Normally fio operates within the region set by \fBsize\fR, which means
that the \fBsize\fR option sets both the region and size of I/O to be
performed. Sometimes that is not what you want. With this option, it is
possible to define just the amount of I/O that fio should do. For instance,
if \fBsize\fR is set to 20GiB and \fBio_size\fR is set to 5GiB, fio
will perform I/O within the first 20GiB but exit when 5GiB have been
done. The opposite is also possible \-\- if \fBsize\fR is set to 20GiB,
and \fBio_size\fR is set to 40GiB, then fio will do 40GiB of I/O within
the 0..20GiB region. Value can be set as percentage: \fBio_size\fR=N%.
In this case \fBio_size\fR multiplies \fBsize\fR= value. In ZBD mode, value can
also be set as number of zones using 'z'.
.TP
.BI filesize \fR=\fPirange(int)
Individual file sizes. May be a range, in which case fio will select sizes
for files at random within the given range. If not given, each created file
is the same size. This option overrides \fBsize\fR in terms of file size,
i.e. \fBsize\fR becomes merely the default for \fBio_size\fR (and
has no effect it all if \fBio_size\fR is set explicitly).
.TP
.BI file_append \fR=\fPbool
Perform I/O after the end of the file. Normally fio will operate within the
size of a file. If this option is set, then fio will append to the file
instead. This has identical behavior to setting \fBoffset\fR to the size
of a file. This option is ignored on non-regular files.
.TP
.BI fill_device \fR=\fPbool "\fR,\fB fill_fs" \fR=\fPbool
Sets size to something really large and waits for ENOSPC (no space left on
device) or EDQUOT (disk quota exceeded)
as the terminating condition. Only makes sense with sequential
write. For a read workload, the mount point will be filled first then I/O
started on the result.
.SS "I/O engine"
.TP
.BI ioengine \fR=\fPstr
fio supports 2 kinds of performance measurement: I/O and file/directory operation.

I/O engines define how the job issues I/O to the file. The following types are defined:
.RS
.TP
.B sync
Basic \fBread\fR\|(2) or \fBwrite\fR\|(2)
I/O. \fBlseek\fR\|(2) is used to position the I/O location.
See \fBfsync\fR and \fBfdatasync\fR for syncing write I/Os.
.TP
.B psync
Basic \fBpread\fR\|(2) or \fBpwrite\fR\|(2) I/O. Default on
all supported operating systems except for Windows.
.TP
.B vsync
Basic \fBreadv\fR\|(2) or \fBwritev\fR\|(2) I/O. Will emulate
queuing by coalescing adjacent I/Os into a single submission.
.TP
.B pvsync
Basic \fBpreadv\fR\|(2) or \fBpwritev\fR\|(2) I/O.
.TP
.B pvsync2
Basic \fBpreadv2\fR\|(2) or \fBpwritev2\fR\|(2) I/O.
.TP
.B io_uring
Fast Linux native asynchronous I/O. Supports async IO
for both direct and buffered IO.
This engine defines engine specific options.
.TP
.B io_uring_cmd
Fast Linux native asynchronous I/O for passthrough commands.
This engine defines engine specific options.
.TP
.B libaio
Linux native asynchronous I/O. Note that Linux may only support
queued behavior with non-buffered I/O (set `direct=1' or
`buffered=0').
This engine defines engine specific options.
.TP
.B posixaio
POSIX asynchronous I/O using \fBaio_read\fR\|(3) and
\fBaio_write\fR\|(3).
.TP
.B solarisaio
Solaris native asynchronous I/O.
.TP
.B windowsaio
Windows native asynchronous I/O. Default on Windows.
.TP
.B mmap
File is memory mapped with \fBmmap\fR\|(2) and data copied
to/from using \fBmemcpy\fR\|(3).
.TP
.B splice
\fBsplice\fR\|(2) is used to transfer the data and
\fBvmsplice\fR\|(2) to transfer data from user space to the
kernel.
.TP
.B sg
SCSI generic sg v3 I/O. May either be synchronous using the SG_IO
ioctl, or if the target is an sg character device we use
\fBread\fR\|(2) and \fBwrite\fR\|(2) for asynchronous
I/O. Requires \fBfilename\fR option to specify either block or
character devices. This engine supports trim operations. The
sg engine includes engine specific options.
.TP
.B libzbc
Read, write, trim and ZBC/ZAC operations to a zoned block device using
\fBlibzbc\fR library. The target can be either an SG character device or
a block device file.
.TP
.B null
Doesn't transfer any data, just pretends to. This is mainly used to
exercise fio itself and for debugging/testing purposes.
.TP
.B net
Transfer over the network to given `host:port'. Depending on the
\fBprotocol\fR used, the \fBhostname\fR, \fBport\fR,
\fBlisten\fR and \fBfilename\fR options are used to specify
what sort of connection to make, while the \fBprotocol\fR option
determines which protocol will be used. This engine defines engine
specific options.
.TP
.B netsplice
Like \fBnet\fR, but uses \fBsplice\fR\|(2) and
\fBvmsplice\fR\|(2) to map data and send/receive.
This engine defines engine specific options.
.TP
.B cpuio
Doesn't transfer any data, but burns CPU cycles according to the
\fBcpuload\fR, \fBcpuchunks\fR and \fBcpumode\fR options.
A job never finishes unless there is at least one non-cpuio job.
.RS
.P
.PD 0
\fBcpuload\fR=85 will cause that job to do nothing but burn 85% of the CPU.
In case of SMP machines, use \fBnumjobs=<nr_of_cpu>\fR\ to get desired CPU usage,
as the cpuload only loads a single CPU at the desired rate.

.P
\fBcpumode\fR=qsort replace the default noop instructions loop
by a qsort algorithm to consume more energy.
.PD
.RE
.TP
.B rdma
The RDMA I/O engine supports both RDMA memory semantics
(RDMA_WRITE/RDMA_READ) and channel semantics (Send/Recv) for the
InfiniBand, RoCE and iWARP protocols. This engine defines engine
specific options.
.TP
.B falloc
I/O engine that does regular fallocate to simulate data transfer as
fio ioengine.
.RS
.P
.PD 0
DDIR_READ      does fallocate(,mode = FALLOC_FL_KEEP_SIZE,).
.P
DIR_WRITE      does fallocate(,mode = 0).
.P
DDIR_TRIM      does fallocate(,mode = FALLOC_FL_KEEP_SIZE|FALLOC_FL_PUNCH_HOLE).
.PD
.RE
.TP
.B ftruncate
I/O engine that sends \fBftruncate\fR\|(2) operations in response
to write (DDIR_WRITE) events. Each ftruncate issued sets the file's
size to the current block offset. \fBblocksize\fR is ignored.
.TP
.B e4defrag
I/O engine that does regular EXT4_IOC_MOVE_EXT ioctls to simulate
defragment activity in request to DDIR_WRITE event.
.TP
.B rados
I/O engine supporting direct access to Ceph Reliable Autonomic Distributed
Object Store (RADOS) via librados. This ioengine defines engine specific
options.
.TP
.B rbd
I/O engine supporting direct access to Ceph Rados Block Devices
(RBD) via librbd without the need to use the kernel rbd driver. This
ioengine defines engine specific options.
.TP
.B http
I/O engine supporting GET/PUT requests over HTTP(S) with libcurl to
a WebDAV or S3 endpoint.  This ioengine defines engine specific options.

This engine only supports direct IO of iodepth=1; you need to scale this
via numjobs. blocksize defines the size of the objects to be created.

TRIM is translated to object deletion.
.TP
.B gfapi
Using GlusterFS libgfapi sync interface to direct access to
GlusterFS volumes without having to go through FUSE. This ioengine
defines engine specific options.
.TP
.B gfapi_async
Using GlusterFS libgfapi async interface to direct access to
GlusterFS volumes without having to go through FUSE. This ioengine
defines engine specific options.
.TP
.B libhdfs
Read and write through Hadoop (HDFS). The \fBfilename\fR option
is used to specify host,port of the hdfs name\-node to connect. This
engine interprets offsets a little differently. In HDFS, files once
created cannot be modified so random writes are not possible. To
imitate this the libhdfs engine expects a bunch of small files to be
created over HDFS and will randomly pick a file from them
based on the offset generated by fio backend (see the example
job file to create such files, use `rw=write' option). Please
note, it may be necessary to set environment variables to work
with HDFS/libhdfs properly. Each job uses its own connection to
HDFS.
.TP
.B mtd
Read, write and erase an MTD character device (e.g.,
`/dev/mtd0'). Discards are treated as erases. Depending on the
underlying device type, the I/O may have to go in a certain pattern,
e.g., on NAND, writing sequentially to erase blocks and discarding
before overwriting. The \fBtrimwrite\fR mode works well for this
constraint.
.TP
.B dev\-dax
Read and write using device DAX to a persistent memory device (e.g.,
/dev/dax0.0) through the PMDK libpmem library.
.TP
.B external
Prefix to specify loading an external I/O engine object file. Append
the engine filename, e.g. `ioengine=external:/tmp/foo.o' to load
ioengine `foo.o' in `/tmp'. The path can be either
absolute or relative. See `engines/skeleton_external.c' in the fio source for
details of writing an external I/O engine.
.TP
.B libpmem
Read and write using mmap I/O to a file on a filesystem
mounted with DAX on a persistent memory device through the PMDK
libpmem library.
.TP
.B ime_psync
Synchronous read and write using DDN's Infinite Memory Engine (IME). This
engine is very basic and issues calls to IME whenever an IO is queued.
.TP
.B ime_psyncv
Synchronous read and write using DDN's Infinite Memory Engine (IME). This
engine uses iovecs and will try to stack as much IOs as possible (if the IOs
are "contiguous" and the IO depth is not exceeded) before issuing a call to IME.
.TP
.B ime_aio
Asynchronous read and write using DDN's Infinite Memory Engine (IME). This
engine will try to stack as much IOs as possible by creating requests for IME.
FIO will then decide when to commit these requests.
.TP
.B libiscsi
Read and write iscsi lun with libiscsi.
.TP
.B nbd
Synchronous read and write a Network Block Device (NBD).
.TP
.B libcufile
I/O engine supporting libcufile synchronous access to nvidia-fs and a
GPUDirect Storage-supported filesystem. This engine performs
I/O without transferring buffers between user-space and the kernel,
unless \fBverify\fR is set or \fBcuda_io\fR is \fBposix\fR. \fBiomem\fR must
not be \fBcudamalloc\fR. This ioengine defines engine specific options.
.TP
.B dfs
I/O engine supporting asynchronous read and write operations to the DAOS File
System (DFS) via libdfs.
.TP
.B nfs
I/O engine supporting asynchronous read and write operations to
NFS filesystems from userspace via libnfs. This is useful for
achieving higher concurrency and thus throughput than is possible
via kernel NFS.
.TP
.B exec
Execute 3rd party tools. Could be used to perform monitoring during jobs runtime.
.TP
.B xnvme
I/O engine using the xNVMe C API, for NVMe devices. The xnvme engine provides
flexibility to access GNU/Linux Kernel NVMe driver via libaio, IOCTLs, io_uring,
the SPDK NVMe driver, or your own custom NVMe driver. The xnvme engine includes
engine specific options. (See \fIhttps://xnvme.io/\fR).
.TP
.B libblkio
Use the libblkio library (\fIhttps://gitlab.com/libblkio/libblkio\fR). The
specific driver to use must be set using \fBlibblkio_driver\fR. If
\fBmem\fR/\fBiomem\fR is not specified, memory allocation is delegated to
libblkio (and so is guaranteed to work with the selected driver). One libblkio
instance is used per process, so all jobs setting option \fBthread\fR will share
a single instance (with one queue per thread) and must specify compatible
options. Note that some drivers don't allow several instances to access the same
device or file simultaneously, but allow it for threads.
.RE
.P
File/directory operation engines define how the job operates file or directory.
The following types are defined:
.RS
.TP
.B filecreate
Simply create the files and do no I/O to them.  You still need to
set  \fBfilesize\fP so that all the accounting still occurs, but no
actual I/O will be done other than creating the file.
Example job file: filecreate-ioengine.fio.
.TP
.B filestat
Simply do stat() and do no I/O to the file. You need to set \fBfilesize\fP
and \fBnrfiles\fP, so that files will be created.
This engine is to measure file lookup and meta data access.
Example job file: filestat-ioengine.fio.
.TP
.B filedelete
Simply delete the files by unlink() and do no I/O to them. You need to set \fBfilesize\fP
and \fBnrfiles\fP, so that the files will be created.
This engine is to measure file delete.
Example job file: filedelete-ioengine.fio.
.TP
.B dircreate
Simply create the directories and do no I/O to them.  You still need to
set  \fBfilesize\fP so that all the accounting still occurs, but no
actual I/O will be done other than creating the directories.
Example job file: dircreate-ioengine.fio.
.TP
.B dirstat
Simply do stat() and do no I/O to the directories. You need to set \fBfilesize\fP
and \fBnrfiles\fP, so that directories will be created.
This engine is to measure directory lookup and meta data access.
Example job file: dirstat-ioengine.fio.
.TP
.B dirdelete
Simply delete the directories by rmdir() and do no I/O to them. You need to set \fBfilesize\fP
and \fBnrfiles\fP, so that the directories will be created.
This engine is to measure directory delete.
.P
For file and directory operation engines, there is no I/O throughput, then the statistics \
data in report have different meanings. The meaningful output indexes are: \fBiops\fP and \fBclat\fP. \
\fBbw\fP is meaningless. Refer to section: "Interpreting the output" for more details.
.RE
.SS "I/O engine specific parameters"
In addition, there are some parameters which are only valid when a specific
\fBioengine\fR is in use. These are used identically to normal parameters,
with the caveat that when used on the command line, they must come after the
\fBioengine\fR that defines them is selected.
.TP
.BI (io_uring,libaio)cmdprio_percentage \fR=\fPint[,int]
Set the percentage of I/O that will be issued with the highest priority.
Default: 0. A single value applies to reads and writes. Comma-separated
values may be specified for reads and writes. For this option to be effective,
NCQ priority must be supported and enabled, and `direct=1' option must be
used. fio must also be run as the root user. Unlike slat/clat/lat stats, which
can be tracked and reported independently, per priority stats only track and
report a single type of latency. By default, completion latency (clat) will be
reported, if \fBlat_percentiles\fR is set, total latency (lat) will be reported.
.TP
.BI (io_uring,libaio)cmdprio_class \fR=\fPint[,int]
Set the I/O priority class to use for I/Os that must be issued with a
priority when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR is set.
If not specified when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR
is set, this defaults to the highest priority class. A single value applies
to reads and writes. Comma-separated values may be specified for reads and
writes. See man \fBionice\fR\|(1). See also the \fBprioclass\fR option.
.TP
.BI (io_uring,libaio)cmdprio_hint \fR=\fPint[,int]
Set the I/O priority hint to use for I/Os that must be issued with a
priority when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR is set.
If not specified when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR
is set, this defaults to 0 (no hint). A single value applies to reads and
writes. Comma-separated values may be specified for reads and writes.
See also the \fBpriohint\fR option.
.TP
.BI (io_uring,libaio)cmdprio \fR=\fPint[,int]
Set the I/O priority value to use for I/Os that must be issued with a
priority when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR is set.
If not specified when \fBcmdprio_percentage\fR or \fBcmdprio_bssplit\fR
is set, this defaults to 0. Linux limits us to a positive value between
0 and 7, with 0 being the highest. A single value applies to reads and writes.
Comma-separated values may be specified for reads and writes. See man
\fBionice\fR\|(1). Refer to an appropriate manpage for other operating systems
since the meaning of priority may differ. See also the \fBprio\fR option.
.TP
.BI (io_uring,libaio)cmdprio_bssplit \fR=\fPstr[,str]
To get a finer control over I/O priority, this option allows specifying
the percentage of IOs that must have a priority set depending on the block
size of the IO. This option is useful only when used together with the option
\fBbssplit\fR, that is, multiple different block sizes are used for reads and
writes.
.RS
.P
The first accepted format for this option is the same as the format of the
\fBbssplit\fR option:
.RS
.P
cmdprio_bssplit=blocksize/percentage:blocksize/percentage
.RE
.P
In this case, each entry will use the priority class, priority hint and
priority level defined by the options \fBcmdprio_class\fR, \fBcmdprio\fR
and \fBcmdprio_hint\fR respectively.
.P
The second accepted format for this option is:
.RS
.P
cmdprio_bssplit=blocksize/percentage/class/level:blocksize/percentage/class/level
.RE
.P
In this case, the priority class and priority level is defined inside each
entry. In comparison with the first accepted format, the second accepted format
does not restrict all entries to have the same priority class and priority
level.
.P
The third accepted format for this option is:
.RS
.P
cmdprio_bssplit=blocksize/percentage/class/level/hint:...
.RE
.P
This is an extension of the second accepted format that allows one to also
specify a priority hint.
.P
For all formats, only the read and write data directions are supported, values
for trim IOs are ignored. This option is mutually exclusive with the
\fBcmdprio_percentage\fR option.
.RE
.TP
.BI (io_uring,io_uring_cmd)fixedbufs
If fio is asked to do direct IO, then Linux will map pages for each IO call, and
release them when IO is done. If this option is set, the pages are pre-mapped
before IO is started. This eliminates the need to map and release for each IO.
This is more efficient, and reduces the IO latency as well.
.TP
.BI (io_uring,io_uring_cmd)nonvectored \fR=\fPint
With this option, fio will use non-vectored read/write commands, where address
must contain the address directly. Default is -1.
.TP
.BI (io_uring,io_uring_cmd)force_async
Normal operation for io_uring is to try and issue an sqe as non-blocking first,
and if that fails, execute it in an async manner. With this option set to N,
then every N request fio will ask sqe to be issued in an async manner. Default
is 0.
.TP
.BI (io_uring,io_uring_cmd,xnvme)hipri
If this option is set, fio will attempt to use polled IO completions. Normal IO
completions generate interrupts to signal the completion of IO, polled
completions do not. Hence they are require active reaping by the application.
The benefits are more efficient IO for high IOPS scenarios, and lower latencies
for low queue depth IO.
.TP
.BI (io_uring,io_uring_cmd)registerfiles
With this option, fio registers the set of files being used with the kernel.
This avoids the overhead of managing file counts in the kernel, making the
submission and completion part more lightweight. Required for the below
sqthread_poll option.
.TP
.BI (io_uring,io_uring_cmd,xnvme)sqthread_poll
Normally fio will submit IO by issuing a system call to notify the kernel of
available items in the SQ ring. If this option is set, the act of submitting IO
will be done by a polling thread in the kernel. This frees up cycles for fio, at
the cost of using more CPU in the system. As submission is just the time it
takes to fill in the sqe entries and any syscall required to wake up the idle
kernel thread, fio will not report submission latencies.
.TP
.BI (io_uring,io_uring_cmd)sqthread_poll_cpu \fR=\fPint
When `sqthread_poll` is set, this option provides a way to define which CPU
should be used for the polling thread.
.TP
.BI (io_uring_cmd)cmd_type \fR=\fPstr
Specifies the type of uring passthrough command to be used. Supported
value is nvme. Default is nvme.
.TP
.BI (libaio)userspace_reap
Normally, with the libaio engine in use, fio will use the
\fBio_getevents\fR\|(3) system call to reap newly returned events. With
this flag turned on, the AIO ring will be read directly from user-space to
reap events. The reaping mode is only enabled when polling for a minimum of
0 events (e.g. when `iodepth_batch_complete=0').
.TP
.BI (pvsync2)hipri
Set RWF_HIPRI on I/O, indicating to the kernel that it's of higher priority
than normal.
.TP
.BI (pvsync2)hipri_percentage
When hipri is set this determines the probability of a pvsync2 I/O being high
priority. The default is 100%.
.TP
.BI (pvsync2,libaio,io_uring,io_uring_cmd)nowait \fR=\fPbool
By default if a request cannot be executed immediately (e.g. resource starvation,
waiting on locks) it is queued and the initiating process will be blocked until
the required resource becomes free.
This option sets the RWF_NOWAIT flag (supported from the 4.14 Linux kernel) and
the call will return instantly with EAGAIN or a partial result rather than waiting.

It is useful to also use \fBignore_error\fR=EAGAIN when using this option.
Note: glibc 2.27, 2.28 have a bug in syscall wrappers preadv2, pwritev2.
They return EOPNOTSUP instead of EAGAIN.

For cached I/O, using this option usually means a request operates only with
cached data. Currently the RWF_NOWAIT flag does not supported for cached write.
For direct I/O, requests will only succeed if cache invalidation isn't required,
file blocks are fully allocated and the disk request could be issued immediately.
.TP
.BI (pvsync2,io_uring)uncached \fR=\fPint
This option will perform buffered IO without retaining data in the
page cache after the operation completes.

Reads work like a normal buffered read but pages are evicted immediately
after data is copied to userspace. Writes work like buffered writes but
a writeback is initiated before the syscall returns. Pages are evicted
once the writeback completes.

This option sets the RWF_UNCACHED flag (supported from the 6.14 Linux kernel) on
a per-IO basis.
.TP
.BI (pvsync2,libaio,io_uring)atomic \fR=\fPbool
This option means that writes are issued with torn-write protection, meaning
that for a power fail or kernel crash, all or none of the data from the write
will be stored, but never a mix of old and new data. Torn-write protection is
also known as atomic writes.

This option sets the RWF_ATOMIC flag (supported from the 6.11 Linux kernel) on
a per-IO basis.

Writes with RWF_ATOMIC set will be rejected by the kernel when the file does
not support torn-write protection. To learn a file's torn-write limits, issue
statx with STATX_WRITE_ATOMIC.
.TP
.BI (io_uring_cmd,xnvme)fdp \fR=\fPbool
Enable Flexible Data Placement mode for write commands.
.TP
.BI (io_uring_cmd,xnvme)dataplacement \fR=\fPstr
Specifies the data placement directive type to use for write commands. The
following types are supported:
.RS
.RS
.TP
.B none
Do not use a data placement directive. This is the default.
.TP
.B fdp
Use Flexible Data placement directives for write commands. This is equivalent
to specifying \fBfdp\fR=1.
.TP
.B streams
Use Streams directives for write commands.
.RE
.RE
.TP
.BI (io_uring_cmd,xnvme)plid_select=str, fdp_pli_select \fR=\fPstr
Defines how fio decides which placement ID to use next. The following types
are defined:
.RS
.RS
.TP
.B random
Choose a placement ID at random (uniform).
.TP
.B roundrobin
Round robin over available placement IDs. This is the default.
.TP
.B scheme
Choose a placement ID (index) based on the scheme file defined by
the option \fBdp_scheme\fP.
.RE
.P
The available placement ID (indices) are defined by \fBplids\fR or
\fBfdp_pli\fR option except for the case of \fBscheme\fP.
.RE
.TP
.BI (io_uring_cmd,xnvme)plids=str, fdp_pli \fR=\fPstr
Select which Placement ID Indices (FDP) or Placement IDs (streams) this job is
allowed to use for writes. This option accepts a comma-separated list of values
or ranges (e.g., 1,2-4,5,6-8).

For FDP by default, the job will cycle through all available Placement IDs, so
use this option to be selective. The values specified here are array indices
for the list of placement IDs returned by the nvme-cli command `nvme fdp
status'. If you want fio to use FDP placement identifiers only at indices 0, 2
and 5, set `plids=0,2,5'.

For streams this should be a list of Stream IDs.
.TP
.BI (io_uring_cmd,xnvme)\fR\fBdp_scheme\fP=str
Defines which placement ID (index) to be selected based on offset(LBA) range.
The file should contains one or more scheme entries in the following format:
.sp
.RS
.RS
0, 10737418240, 0
.br
10737418240, 21474836480, 1
.br
21474836480, 32212254720, 2
.br
\&...
.RE
.sp
Each line, a scheme entry, contains start offset, end offset, and placement ID
(index) separated by comma(,). If the write offset is within the range of a certain
scheme entry(start offset  offset < end offset), the corresponding placement ID
(index) will be selected. If the write offset belongs to multiple scheme entries,
the first matched scheme entry will be applied. If the offset is not within any range
of scheme entry, dspec field will be set to 0, default RUH. (Caution: In case of
multiple devices in a job, all devices of the job will be affected by the scheme. If
this option is specified, the option \fBplids\fP or \fBfdp_pli\fP will be ignored.)
.RE
.TP
.BI (io_uring_cmd,xnvme)md_per_io_size \fR=\fPint
Size in bytes for separate metadata buffer per IO. For io_uring_cmd these
buffers are allocated using malloc regardless of what is set for \fBiomem\fR.
Default: 0.
.TP
.BI (io_uring_cmd,xnvme)pi_act \fR=\fPint
Action to take when nvme namespace is formatted with protection information.
If this is set to 1 and namespace is formatted with metadata size equal to
protection information size, fio won't use separate metadata buffer or extended
logical block. If this is set to 1 and namespace is formatted with metadata
size greater than protection information size, fio will not generate or verify
the protection information portion of metadata for write or read case
respectively. If this is set to 0, fio generates protection information for
write case and verifies for read case. Default: 1.

For 16 bit CRC generation fio will use isa-l if available otherwise it will
use the default slower generator.
(see: https://github.com/intel/isa-l)
.TP
.BI (io_uring_cmd,xnvme)pi_chk \fR=\fPstr[,str][,str]
Controls the protection information check. This can take one or more of these
values. Default: none.
.RS
.RS
.TP
.B GUARD
Enables protection information checking of guard field.
.TP
.B REFTAG
Enables protection information checking of logical block reference tag field.
.TP
.B APPTAG
Enables protection information checking of application tag field.
.RE
.RE
.TP
.BI (io_uring_cmd,xnvme)apptag \fR=\fPint
Specifies logical block application tag value, if namespace is formatted to use
end to end protection information. Default: 0x1234.
.TP
.BI (io_uring_cmd,xnvme)apptag_mask \fR=\fPint
Specifies logical block application tag mask value, if namespace is formatted
to use end to end protection information. Default: 0xffff.
.TP
.BI (io_uring_cmd)num_range \fR=\fPint
For trim command this will be the number of ranges to trim per I/O request.
The number of logical blocks per range is determined by the \fBbs\fR option
which should be a multiple of logical block size. This cannot be used with
read or write. Note that setting this option > 1, \fBlog_offset\fR will not be
able to log all the offsets. Default: 1.
.TP
.BI (cpuio)cpuload \fR=\fPint
Attempt to use the specified percentage of CPU cycles. This is a mandatory
option when using cpuio I/O engine.
.TP
.BI (cpuio)cpuchunks \fR=\fPint
Split the load into cycles of the given time. In microseconds.
.TP
.BI (cpuio)cpumode \fR=\fPstr
Specify how to stress the CPU. It can take these two values:
.RS
.RS
.TP
.B noop
This is the default and directs the CPU to execute noop instructions.
.TP
.B qsort
Replace the default noop instructions with a qsort algorithm to consume more energy.
.RE
.RE
.TP
.BI (cpuio)exit_on_io_done \fR=\fPbool
Detect when I/O threads are done, then exit.
.TP
.BI (libhdfs)namenode \fR=\fPstr
The hostname or IP address of a HDFS cluster namenode to contact.
.TP
.BI (libhdfs)port \fR=\fPint
The listening port of the HFDS cluster namenode.
.TP
.BI (netsplice,net)port \fR=\fPint
The TCP or UDP port to bind to or connect to. If this is used with
\fBnumjobs\fR to spawn multiple instances of the same job type, then
this will be the starting port number since fio will use a range of
ports.
.TP
.BI (rdma)port \fR=\fPint
The port to use for RDMA-CM communication. This should be the same
value on the client and the server side.
.TP
.BI (netsplice,net,rdma)hostname \fR=\fPstr
The hostname or IP address to use for TCP, UDP or RDMA-CM based I/O.
If the job is a TCP listener or UDP reader, the hostname is not used
and must be omitted unless it is a valid UDP multicast address.
.TP
.BI (netsplice,net)interface \fR=\fPstr
The IP address of the network interface used to send or receive UDP
multicast.
.TP
.BI (netsplice,net)ttl \fR=\fPint
Time\-to\-live value for outgoing UDP multicast packets. Default: 1.
.TP
.BI (netsplice,net)nodelay \fR=\fPbool
Set TCP_NODELAY on TCP connections.
.TP
.BI (netsplice,net)protocol \fR=\fPstr "\fR,\fP proto" \fR=\fPstr
The network protocol to use. Accepted values are:
.RS
.RS
.TP
.B tcp
Transmission control protocol.
.TP
.B tcpv6
Transmission control protocol V6.
.TP
.B udp
User datagram protocol.
.TP
.B udpv6
User datagram protocol V6.
.TP
.B unix
UNIX domain socket.
.TP
.B vsock
VSOCK protocol.
.RE
.P
When the protocol is TCP, UDP or VSOCK, the port must also be given, as well as the
hostname if the job is a TCP or VSOCK listener or UDP reader. For unix sockets, the
normal \fBfilename\fR option should be used and the port is invalid.
When the protocol is VSOCK, the \fBhostname\fR is the CID of the remote VM.

.RE
.TP
.BI (netsplice,net)listen
For TCP network connections, tell fio to listen for incoming connections
rather than initiating an outgoing connection. The \fBhostname\fR must
be omitted if this option is used.
.TP
.BI (netsplice,net)pingpong
Normally a network writer will just continue writing data, and a network
reader will just consume packages. If `pingpong=1' is set, a writer will
send its normal payload to the reader, then wait for the reader to send the
same payload back. This allows fio to measure network latencies. The
submission and completion latencies then measure local time spent sending or
receiving, and the completion latency measures how long it took for the
other end to receive and send back. For UDP multicast traffic
`pingpong=1' should only be set for a single reader when multiple readers
are listening to the same address.
.TP
.BI (netsplice,net)window_size \fR=\fPint
Set the desired socket buffer size for the connection.
.TP
.BI (netsplice,net)mss \fR=\fPint
Set the TCP maximum segment size (TCP_MAXSEG).
.TP
.BI (e4defrag)donorname \fR=\fPstr
File will be used as a block donor (swap extents between files).
.TP
.BI (e4defrag)inplace \fR=\fPint
Configure donor file blocks allocation strategy:
.RS
.RS
.TP
.B 0
Default. Preallocate donor's file on init.
.TP
.B 1
Allocate space immediately inside defragment event, and free right
after event.
.RE
.RE
.TP
.BI (rbd,rados)clustername \fR=\fPstr
Specifies the name of the Ceph cluster.
.TP
.BI (rbd)rbdname \fR=\fPstr
Specifies the name of the RBD.
.TP
.BI (rbd,rados)pool \fR=\fPstr
Specifies the name of the Ceph pool containing RBD or RADOS data.
.TP
.BI (rbd,rados)clientname \fR=\fPstr
Specifies the username (without the 'client.' prefix) used to access the
Ceph cluster. If the \fBclustername\fR is specified, the \fBclientname\fR shall be
the full *type.id* string. If no type. prefix is given, fio will add 'client.'
by default.
.TP
.BI (rados)conf \fR=\fPstr
Specifies the configuration path of ceph cluster, so conf file does not
have to be /etc/ceph/ceph.conf.
.TP
.BI (rbd,rados)busy_poll \fR=\fPbool
Poll store instead of waiting for completion. Usually this provides better
throughput at cost of higher(up to 100%) CPU utilization.
.TP
.BI (rados)touch_objects \fR=\fPbool
During initialization, touch (create if do not exist) all objects (files).
Touching all objects affects ceph caches and likely impacts test results.
Enabled by default.
.TP
.BI (http)http_host \fR=\fPstr
Hostname to connect to.  HTTP port 80 is used automatically when the value 
of the \fBhttps\fP parameter is \fBoff\fP, and HTTPS port 443 if it is \fBon\fP.
A virtual-hosted-style S3 hostname starts with a bucket name, while a 
path-style S3 hostname does not.  Default is \fBlocalhost\fR.
.TP
.BI (http)http_user \fR=\fPstr
Username for HTTP authentication.
.TP
.BI (http)http_pass \fR=\fPstr
Password for HTTP authentication.
.TP
.BI (http)https \fR=\fPstr
Whether to use HTTPS instead of plain HTTP. \fBon\fP enables HTTPS;
\fBinsecure\fP will enable HTTPS, but disable SSL peer verification (use
with caution!).  Default is \fBoff\fR.
.TP
.BI (http)http_mode \fR=\fPstr
Which HTTP access mode to use: webdav, swift, or s3. Default is
\fBwebdav\fR.
.TP
.BI (http)http_s3_region \fR=\fPstr
The S3 region/zone to include in the request. Default is \fBus-east-1\fR.
.TP
.BI (http)http_s3_key \fR=\fPstr
The S3 secret key.
.TP
.BI (http)http_s3_keyid \fR=\fPstr
The S3 key/access id.
.TP
.BI (http)http_s3_security_token \fR=\fPstr
The S3 security token.
.TP
.BI (http)http_s3_sse_customer_key \fR=\fPstr
The encryption customer key in SSE server side.
.TP
.BI (http)http_s3_sse_customer_algorithm \fR=\fPstr
The encryption customer algorithm in SSE server side. Default is \fBAES256\fR
.TP
.BI (http)http_s3_storage_class \fR=\fPstr
Which storage class to access. User-customizable settings. Default is \fBSTANDARD\fR
.TP
.BI (http)http_swift_auth_token \fR=\fPstr
The Swift auth token. See the example configuration file on how to
retrieve this.
.TP
.BI (http)http_verbose \fR=\fPint
Enable verbose requests from libcurl. Useful for debugging. 1 turns on
verbose logging from libcurl, 2 additionally enables HTTP IO tracing.
Default is \fB0\fR
.TP
.BI (http)http_object_mode \fR=\fPstr
How to structure objects for HTTP IO: block or range. Default is \fBblock\fR.
.RS
.RS
.TP
.B block
One object is created for every block. The HTTP engine treats \fBblocksize\fR
as the size of the object to read or write, and appends the block start/end
offsets to the \fBfilename\fR to create the target object path. Reads and
writes operate on whole objects at a time.
.TP
.B range
One object is created for every file. The object path is the filename directly
for both read and write I/O. For read requests, the \fBblocksize\fR and
\fBoffset\fR will be used to set the "Range" header on read requests to issue
partial reads of the object. For write requests, blocksize is used to set the
size of the object, the same as in \fBblock\fR mode.
.RE
.RE
.TP
.BI (mtd)skip_bad \fR=\fPbool
Skip operations against known bad blocks.
.TP
.BI (libhdfs)hdfsdirectory
libhdfs will create chunk in this HDFS directory.
.TP
.BI (libhdfs)chunk_size
The size of the chunk to use for each file.
.TP
.BI (rdma)verb \fR=\fPstr
The RDMA verb to use on this side of the RDMA ioengine
connection. Valid values are write, read, send and recv. These
correspond to the equivalent RDMA verbs (e.g. write = rdma_write
etc.). Note that this only needs to be specified on the client side of
the connection. See the examples folder.
.TP
.BI (rdma)bindname \fR=\fPstr
The name to use to bind the local RDMA-CM connection to a local RDMA
device. This could be a hostname or an IPv4 or IPv6 address. On the
server side this will be passed into the rdma_bind_addr() function and
on the client site it will be used in the rdma_resolve_add()
function. This can be useful when multiple paths exist between the
client and the server or in certain loopback configurations.
.TP
.BI (filestat)stat_type \fR=\fPstr
Specify stat system call type to measure lookup/getattr performance.
Default is \fBstat\fR for \fBstat\fR\|(2).
.TP
.BI (sg)hipri
If this option is set, fio will attempt to use polled IO completions. This
will have a similar effect as (io_uring)hipri. Only SCSI READ and WRITE
commands will have the SGV4_FLAG_HIPRI set (not UNMAP (trim) nor VERIFY).
Older versions of the Linux sg driver that do not support hipri will simply
ignore this flag and do normal IO. The Linux SCSI Low Level Driver (LLD)
that "owns" the device also needs to support hipri (also known as iopoll
and mq_poll). The MegaRAID driver is an example of a SCSI LLD.
Default: clear (0) which does normal (interrupted based) IO.
.TP
.BI (sg, io_uring_cmd)readfua \fR=\fPbool
With readfua option set to 1, read operations include the force
unit access (fua) flag. Default: 0.
.TP
.BI (sg, io_uring_cmd)writefua \fR=\fPbool
With writefua option set to 1, write operations include the force
unit access (fua) flag. Default: 0.
.TP
.BI (io_uring_cmd)write_mode \fR=\fPstr
Specifies the type of write operation.  Defaults to 'write'.
.RS
.RS
.TP
.B write
Use Write commands for write operations
.TP
.B uncor
Use Write Uncorrectable commands for write operations
.TP
.B zeroes
Use Write Zeroes commands for write operations
.TP
.B verify
Use Verify commands for write operations
.RE
.RE
.TP
.BI (io_uring_cmd)verify_mode \fR=\fPstr
Specifies the type of command to be used in the verification phase. Defaults to 'read'.
.RS
.RS
.TP
.B read
Use Read commands for data verification
.TP
.B compare
Use Compare commands for data verification.  This option is only valid with
specific pattern(s), which means it *must* be given with `verify=pattern` and
`verify_pattern=<pattern>`.
.RE
.RE
.TP
.BI (sg)sg_write_mode \fR=\fPstr
Specify the type of write commands to issue. This option can take multiple
values:
.RS
.RS
.TP
.B write (default)
Write opcodes are issued as usual
.TP
.B write_and_verify
Issue WRITE AND VERIFY commands. The BYTCHK bit is set to 00b. This directs the
device to carry out a medium verification with no data comparison for the data
that was written. The writefua option is ignored with this selection.
.TP
.B verify
This option is deprecated. Use write_and_verify instead.
.TP
.B write_same
Issue WRITE SAME commands. This transfers a single block to the device
and writes this same block of data to a contiguous sequence of LBAs
beginning at the specified offset. fio's block size parameter
specifies the amount of data written with each command. However, the
amount of data actually transferred to the device is equal to the
device's block (sector) size. For a device with 512 byte sectors,
blocksize=8k will write 16 sectors with each command. fio will still
generate 8k of data for each command butonly the first 512 bytes will
be used and transferred to the device. The writefua option is ignored
with this selection.
.TP
.B same
This option is deprecated. Use write_same instead.
.TP
.B write_same_ndob
Issue WRITE SAME(16) commands as above but with the No Data Output
Buffer (NDOB) bit set. No data will be transferred to the device with
this bit set. Data written will be a pre-determined pattern such as
all zeroes.
.TP
.B write_stream
Issue WRITE STREAM(16) commands. Use the stream_id option to specify
the stream identifier.
.TP
.B verify_bytchk_00
Issue VERIFY commands with BYTCHK set to 00. This directs the device to carry
out a medium verification with no data comparison.
.TP
.B verify_bytchk_01
Issue VERIFY commands with BYTCHK set to 01. This directs the device to
compare the data on the device with the data transferred to the device.
.TP
.B verify_bytchk_11
Issue VERIFY commands with BYTCHK set to 11. This transfers a single block to
the device and compares the contents of this block with the data on the device
beginning at the specified offset. fio's block size parameter specifies the
total amount of data compared with this command. However, only one block
(sector) worth of data is transferred to the device. This is similar to the
WRITE SAME command except that data is compared instead of written.
.RE
.RE
.TP
.BI (sg)stream_id \fR=\fPint
Set the stream identifier for WRITE STREAM commands. If this is set to 0 (which is not
a valid stream identifier) fio will open a stream and then close it when done. Default
is 0.
.TP
.BI (nbd)uri \fR=\fPstr
Specify the NBD URI of the server to test.
The string is a standard NBD URI (see
\fIhttps://github.com/NetworkBlockDevice/nbd/tree/master/doc\fR).
Example URIs:
.RS
.RS
.TP
\fInbd://localhost:10809\fR
.TP
\fInbd+unix:///?socket=/tmp/socket\fR
.TP
\fInbds://tlshost/exportname\fR
.RE
.RE
.TP
.BI (libcufile)gpu_dev_ids\fR=\fPstr
Specify the GPU IDs to use with CUDA. This is a colon-separated list of int.
GPUs are assigned to workers roundrobin. Default is 0.
.TP
.BI (libcufile)cuda_io\fR=\fPstr
Specify the type of I/O to use with CUDA. This option
takes the following values:
.RS
.RS
.TP
.B cufile (default)
Use libcufile and nvidia-fs. This option performs I/O directly
between a GPUDirect Storage filesystem and GPU buffers,
avoiding use of a bounce buffer. If \fBverify\fR is set,
cudaMemcpy is used to copy verification data between RAM and GPU(s).
Verification data is copied from RAM to GPU before a write
and from GPU to RAM after a read.
\fBdirect\fR must be 1.
.TP
.BI posix
Use POSIX to perform I/O with a RAM buffer, and use
cudaMemcpy to transfer data between RAM and the GPU(s).
Data is copied from GPU to RAM before a write and copied
from RAM to GPU after a read. \fBverify\fR does not affect
the use of cudaMemcpy.
.RE
.RE
.TP
.BI (dfs)pool
Specify the label or UUID of the DAOS pool to connect to.
.TP
.BI (dfs)cont
Specify the label or UUID of the DAOS container to open.
.TP
.BI (dfs)chunk_size
Specify a different chunk size (in bytes) for the dfs file.
Use DAOS container's chunk size by default.
.TP
.BI (dfs)object_class
Specify a different object class for the dfs file.
Use DAOS container's object class by default.
.TP
.BI (nfs)nfs_url
URL in libnfs format, eg nfs://<server|ipv4|ipv6>/path[?arg=val[&arg=val]*]
Refer to the libnfs README for more details.
.TP
.BI (exec)program\fR=\fPstr
Specify the program to execute.
Note the program will receive a SIGTERM when the job is reaching the time limit.
A SIGKILL is sent once the job is over. The delay between the two signals is defined by \fBgrace_time\fR option.
.TP
.BI (exec)arguments\fR=\fPstr
Specify arguments to pass to program.
Some special variables can be expanded to pass fio's job details to the program :
.RS
.RS
.TP
.B %r
replaced by the duration of the job in seconds
.TP
.BI %n
replaced by the name of the job
.RE
.RE
.TP
.BI (exec)grace_time\fR=\fPint
Defines the time between the SIGTERM and SIGKILL signals. Default is 1 second.
.TP
.BI (exec)std_redirect\fR=\fPbool
If set, stdout and stderr streams are redirected to files named from the job name. Default is true.
.TP
.BI (xnvme)xnvme_async\fR=\fPstr
Select the xnvme async command interface. This can take these values.
.RS
.RS
.TP
.B emu
This is default and use to emulate asynchronous I/O by using a single thread to
create a queue pair on top of a synchronous I/O interface using the NVMe driver
IOCTL.
.TP
.BI thrpool
Emulate an asynchronous I/O interface with a pool of userspace threads on top
of a synchronous I/O interface using the NVMe driver IOCTL. By default four
threads are used.
.TP
.BI io_uring
Linux native asynchronous I/O interface which supports both direct and buffered
I/O.
.TP
.BI libaio
Use Linux aio for Asynchronous I/O
.TP
.BI posix
Use the posix asynchronous I/O interface to perform one or more I/O operations
asynchronously.
.TP
.BI vfio
Use the user-space VFIO-based backend, implemented using libvfn instead of
SPDK.
.TP
.BI nil
Do not transfer any data; just pretend to. This is mainly used for
introspective performance evaluation.
.RE
.RE
.TP
.BI (xnvme)xnvme_sync\fR=\fPstr
Select the xnvme synchronous command interface. This can take these values.
.RS
.RS
.TP
.B nvme
This is default and uses Linux NVMe Driver ioctl() for synchronous I/O.
.TP
.BI psync
This supports regular as well as vectored pread() and pwrite() commands.
.TP
.BI block
This is the same as psync except that it also supports zone management
commands using Linux block layer IOCTLs.
.RE
.RE
.TP
.BI (xnvme)xnvme_admin\fR=\fPstr
Select the xnvme admin command interface. This can take these values.
.RS
.RS
.TP
.B nvme
This is default and uses Linux NVMe Driver ioctl() for admin commands.
.TP
.BI block
Use Linux Block Layer ioctl() and sysfs for admin commands.
.RE
.RE
.TP
.BI (xnvme)xnvme_dev_nsid\fR=\fPint
xnvme namespace identifier for userspace NVMe driver SPDK or vfio.
.TP
.BI (xnvme)xnvme_dev_subnqn\fR=\fPstr
Sets the subsystem NQN for fabrics. This is for xNVMe to utilize a fabrics
target with multiple systems.
.TP
.BI (xnvme)xnvme_mem\fR=\fPstr
Select the xnvme memory backend. This can take these values.
.RS
.RS
.TP
.B posix
This is the default posix memory backend for linux NVMe driver.
.TP
.BI hugepage
Use hugepages, instead of existing posix memory backend. The memory backend
uses hugetlbfs. This require users to allocate hugepages, mount hugetlbfs and
set an environment variable for XNVME_HUGETLB_PATH.
.TP
.BI spdk
Uses SPDK's memory allocator.
.TP
.BI vfio
Uses libvfn's memory allocator. This also specifies the use of libvfn backend
instead of SPDK.
.RE
.RE
.TP
.BI (xnvme)xnvme_iovec
If this option is set, xnvme will use vectored read/write commands.
.TP
.BI (libblkio)libblkio_driver \fR=\fPstr
The libblkio driver to use. Different drivers access devices through different
underlying interfaces. Available drivers depend on the libblkio version in use
and are listed at \fIhttps://libblkio.gitlab.io/libblkio/blkio.html#drivers\fR
.TP
.BI (libblkio)libblkio_path \fR=\fPstr
Sets the value of the driver-specific "path" property before connecting the
libblkio instance, which identifies the target device or file on which to
perform I/O. Its exact semantics are driver-dependent and not all drivers may
support it; see \fIhttps://libblkio.gitlab.io/libblkio/blkio.html#drivers\fR
.TP
.BI (libblkio)libblkio_pre_connect_props \fR=\fPstr
A colon-separated list of additional libblkio properties to be set after
creating but before connecting the libblkio instance. Each property must have
the format \fB<name>=<value>\fR. Colons can be escaped as \fB\\:\fR. These are
set after the engine sets any other properties, so those can be overridden.
Available properties depend on the libblkio version in use and are listed at
\fIhttps://libblkio.gitlab.io/libblkio/blkio.html#properties\fR
.TP
.BI (libblkio)libblkio_num_entries \fR=\fPint
Sets the value of the driver-specific "num-entries" property before starting the
libblkio instance. Its exact semantics are driver-dependent and not all drivers
may support it; see \fIhttps://libblkio.gitlab.io/libblkio/blkio.html#drivers\fR
.TP
.BI (libblkio)libblkio_queue_size \fR=\fPint
Sets the value of the driver-specific "queue-size" property before starting the
libblkio instance. Its exact semantics are driver-dependent and not all drivers
may support it; see \fIhttps://libblkio.gitlab.io/libblkio/blkio.html#drivers\fR
.TP
.BI (libblkio)libblkio_pre_start_props \fR=\fPstr
A colon-separated list of additional libblkio properties to be set after
connecting but before starting the libblkio instance. Each property must have
the format \fB<name>=<value>\fR. Colons can be escaped as \fB\\:\fR. These are
set after the engine sets any other properties, so those can be overridden.
Available properties depend on the libblkio version in use and are listed at
\fIhttps://libblkio.gitlab.io/libblkio/blkio.html#properties\fR
.TP
.BI (libblkio)hipri
Use poll queues. This is incompatible with \fBlibblkio_wait_mode=eventfd\fR and
\fBlibblkio_force_enable_completion_eventfd\fR.
.TP
.BI (libblkio)libblkio_vectored
Submit vectored read and write requests.
.TP
.BI (libblkio)libblkio_write_zeroes_on_trim
Submit trims as "write zeroes" requests instead of discard requests.
.TP
.BI (libblkio)libblkio_wait_mode \fR=\fPstr
How to wait for completions:
.RS
.RS
.TP
.B block \fR(default)
Use a blocking call to \fBblkioq_do_io()\fR.
.TP
.B eventfd
Use a blocking call to \fBread()\fR on the completion eventfd.
.TP
.B loop
Use a busy loop with a non-blocking call to \fBblkioq_do_io()\fR.
.RE
.RE
.TP
.BI (libblkio)libblkio_force_enable_completion_eventfd
Enable the queue's completion eventfd even when unused. This may impact
performance. The default is to enable it only if
\fBlibblkio_wait_mode=eventfd\fR.
.TP
.BI (windowsaio)no_completion_thread
Avoid using a separate thread for completion polling.
.SS "I/O depth"
.TP
.BI iodepth \fR=\fPint
Number of I/O units to keep in flight against the file. Note that
increasing \fBiodepth\fR beyond 1 will not affect synchronous ioengines (except
for small degrees when \fBverify_async\fR is in use). Even async
engines may impose OS restrictions causing the desired depth not to be
achieved. This may happen on Linux when using libaio and not setting
`direct=1', since buffered I/O is not async on that OS. Keep an
eye on the I/O depth distribution in the fio output to verify that the
achieved depth is as expected. Default: 1.
.TP
.BI iodepth_batch_submit \fR=\fPint "\fR,\fP iodepth_batch" \fR=\fPint
This defines how many pieces of I/O to submit at once. It defaults to 1
which means that we submit each I/O as soon as it is available, but can be
raised to submit bigger batches of I/O at the time. If it is set to 0 the
\fBiodepth\fR value will be used.
.TP
.BI iodepth_batch_complete_min \fR=\fPint "\fR,\fP iodepth_batch_complete" \fR=\fPint
This defines how many pieces of I/O to retrieve at once. It defaults to 1
which means that we'll ask for a minimum of 1 I/O in the retrieval process
from the kernel. The I/O retrieval will go on until we hit the limit set by
\fBiodepth_low\fR. If this variable is set to 0, then fio will always
check for completed events before queuing more I/O. This helps reduce I/O
latency, at the cost of more retrieval system calls.
.TP
.BI iodepth_batch_complete_max \fR=\fPint
This defines maximum pieces of I/O to retrieve at once. This variable should
be used along with \fBiodepth_batch_complete_min\fR=\fIint\fR variable,
specifying the range of min and max amount of I/O which should be
retrieved. By default it is equal to \fBiodepth_batch_complete_min\fR
value. Example #1:
.RS
.RS
.P
.PD 0
iodepth_batch_complete_min=1
.P
iodepth_batch_complete_max=<iodepth>
.PD
.RE
.P
which means that we will retrieve at least 1 I/O and up to the whole
submitted queue depth. If none of I/O has been completed yet, we will wait.
Example #2:
.RS
.P
.PD 0
iodepth_batch_complete_min=0
.P
iodepth_batch_complete_max=<iodepth>
.PD
.RE
.P
which means that we can retrieve up to the whole submitted queue depth, but
if none of I/O has been completed yet, we will NOT wait and immediately exit
the system call. In this example we simply do polling.
.RE
.TP
.BI iodepth_low \fR=\fPint
The low water mark indicating when to start filling the queue
again. Defaults to the same as \fBiodepth\fR, meaning that fio will
attempt to keep the queue full at all times. If \fBiodepth\fR is set to
e.g. 16 and \fBiodepth_low\fR is set to 4, then after fio has filled the queue of
16 requests, it will let the depth drain down to 4 before starting to fill
it again.
.TP
.BI serialize_overlap \fR=\fPbool
Serialize in-flight I/Os that might otherwise cause or suffer from data races.
When two or more I/Os are submitted simultaneously, there is no guarantee that
the I/Os will be processed or completed in the submitted order. Further, if
two or more of those I/Os are writes, any overlapping region between them can
become indeterminate/undefined on certain storage. These issues can cause
verification to fail erratically when at least one of the racing I/Os is
changing data and the overlapping region has a non-zero size. Setting
\fBserialize_overlap\fR tells fio to avoid provoking this behavior by explicitly
serializing in-flight I/Os that have a non-zero overlap. Note that setting
this option can reduce both performance and the \fBiodepth\fR achieved.
.RS
.P
This option only applies to I/Os issued for a single job except when it is
enabled along with \fBio_submit_mode\fR=offload. In offload mode, fio
will check for overlap among all I/Os submitted by offload jobs with \fBserialize_overlap\fR
enabled.
.P
Default: false.
.RE
.TP
.BI io_submit_mode \fR=\fPstr
This option controls how fio submits the I/O to the I/O engine. The default
is `inline', which means that the fio job threads submit and reap I/O
directly. If set to `offload', the job threads will offload I/O submission
to a dedicated pool of I/O threads. This requires some coordination and thus
has a bit of extra overhead, especially for lower queue depth I/O where it
can increase latencies. The benefit is that fio can manage submission rates
independently of the device completion rates. This avoids skewed latency
reporting if I/O gets backed up on the device side (the coordinated omission
problem). Note that this option cannot reliably be used with async IO engines.
.SS "I/O rate"
.TP
.BI thinkcycles \fR=\fPint
Stall the job for the specified number of cycles after an I/O has completed before
issuing the next. May be used to simulate processing being done by an application.
This is not taken into account for the time to be waited on for \fBthinktime\fR.
Might not have any effect on some platforms, this can be checked by trying a setting
a high enough amount of thinkcycles.
.TP
.BI thinktime \fR=\fPtime
Stall the job for the specified period of time after an I/O has completed before issuing the
next. May be used to simulate processing being done by an application.
When the unit is omitted, the value is interpreted in microseconds. See
\fBthinktime_blocks\fR, \fBthinktime_iotime\fR and \fBthinktime_spin\fR.
.TP
.BI thinktime_spin \fR=\fPtime
Only valid if \fBthinktime\fR is set - pretend to spend CPU time doing
something with the data received, before falling back to sleeping for the
rest of the period specified by \fBthinktime\fR. When the unit is
omitted, the value is interpreted in microseconds.
.TP
.BI thinktime_blocks \fR=\fPint
Only valid if \fBthinktime\fR is set - control how many blocks to issue,
before waiting \fBthinktime\fR usecs. If not set, defaults to 1 which will make
fio wait \fBthinktime\fR usecs after every block. This effectively makes any
queue depth setting redundant, since no more than 1 I/O will be queued
before we have to complete it and do our \fBthinktime\fR. In other words, this
setting effectively caps the queue depth if the latter is larger.
.TP
.BI thinktime_blocks_type \fR=\fPstr
Only valid if \fBthinktime\fR is set - control how \fBthinktime_blocks\fR triggers.
The default is `complete', which triggers \fBthinktime\fR when fio completes
\fBthinktime_blocks\fR blocks. If this is set to `issue', then the trigger happens
at the issue side.
.TP
.BI thinktime_iotime \fR=\fPtime
Only valid if \fBthinktime\fR is set - control \fBthinktime\fR interval by time.
The \fBthinktime\fR stall is repeated after IOs are executed for
\fBthinktime_iotime\fR. For example, `\-\-thinktime_iotime=9s \-\-thinktime=1s'
repeat 10-second cycle with IOs for 9 seconds and stall for 1 second. When the
unit is omitted, \fBthinktime_iotime\fR is interpreted as a number of seconds.
If this option is used together with \fBthinktime_blocks\fR, the \fBthinktime\fR
stall is repeated after \fBthinktime_iotime\fR or after \fBthinktime_blocks\fR
IOs, whichever happens first.

.TP
.BI rate \fR=\fPint[,int][,int]
Cap the bandwidth used by this job. The number is in bytes/sec, the normal
suffix rules apply. Comma-separated values may be specified for reads,
writes, and trims as described in \fBblocksize\fR.
.RS
.P
For example, using `rate=1m,500k' would limit reads to 1MiB/sec and writes to
500KiB/sec. Capping only reads or writes can be done with `rate=,500k' or
`rate=500k,' where the former will only limit writes (to 500KiB/sec) and the
latter will only limit reads.
.RE
.TP
.BI rate_min \fR=\fPint[,int][,int]
Tell fio to do whatever it can to maintain at least this bandwidth. Failing
to meet this requirement will cause the job to exit. Comma-separated values
may be specified for reads, writes, and trims as described in
\fBblocksize\fR.
.TP
.BI rate_iops \fR=\fPint[,int][,int]
Cap the bandwidth to this number of IOPS. Basically the same as
\fBrate\fR, just specified independently of bandwidth. If the job is
given a block size range instead of a fixed value, the smallest block size
is used as the metric. Comma-separated values may be specified for reads,
writes, and trims as described in \fBblocksize\fR.
.TP
.BI rate_iops_min \fR=\fPint[,int][,int]
If fio doesn't meet this rate of I/O, it will cause the job to exit.
Comma-separated values may be specified for reads, writes, and trims as
described in \fBblocksize\fR.
.TP
.BI rate_process \fR=\fPstr
This option controls how fio manages rated I/O submissions. The default is
`linear', which submits I/O in a linear fashion with fixed delays between
I/Os that gets adjusted based on I/O completion rates. If this is set to
`poisson', fio will submit I/O based on a more real world random request
flow, known as the Poisson process
(\fIhttps://en.wikipedia.org/wiki/Poisson_point_process\fR). The lambda will be
10^6 / IOPS for the given workload.
.TP
.BI rate_ignore_thinktime \fR=\fPbool
By default, fio will attempt to catch up to the specified rate setting, if any
kind of thinktime setting was used. If this option is set, then fio will
ignore the thinktime and continue doing IO at the specified rate, instead of
entering a catch-up mode after thinktime is done.
.TP
.BI rate_cycle \fR=\fPint
Average bandwidth for \fBrate_min\fR and \fBrate_iops_min\fR over this number
of milliseconds. Defaults to 1000.
.SS "I/O latency"
.TP
.BI latency_target \fR=\fPtime
If set, fio will attempt to find the max performance point that the given
workload will run at while maintaining a latency below this target. When
the unit is omitted, the value is interpreted in microseconds. See
\fBlatency_window\fR and \fBlatency_percentile\fR.
.TP
.BI latency_window \fR=\fPtime
Used with \fBlatency_target\fR to specify the sample window that the job
is run at varying queue depths to test the performance. When the unit is
omitted, the value is interpreted in microseconds.
.TP
.BI latency_percentile \fR=\fPfloat
The percentage of I/Os that must fall within the criteria specified by
\fBlatency_target\fR and \fBlatency_window\fR. If not set, this
defaults to 100.0, meaning that all I/Os must be equal or below to the value
set by \fBlatency_target\fR.
.TP
.BI latency_run \fR=\fPbool
Used with \fBlatency_target\fR. If false (default), fio will find the highest
queue depth that meets \fBlatency_target\fR and exit. If true, fio will continue
running and try to meet \fBlatency_target\fR by adjusting queue depth.
.TP
.BI max_latency \fR=\fPtime[,time][,time]
If set, fio will exit the job with an ETIMEDOUT error if it exceeds this
maximum latency. When the unit is omitted, the value is interpreted in
microseconds. Comma-separated values may be specified for reads, writes,
and trims as described in \fBblocksize\fR.
.SS "I/O replay"
.TP
.BI write_iolog \fR=\fPstr
Write the issued I/O patterns to the specified file. See
\fBread_iolog\fR. Specify a separate file for each job, otherwise the
iologs will be interspersed and the file may be corrupt. This file will be
opened in append mode.
.TP
.BI read_iolog \fR=\fPstr
Open an iolog with the specified filename and replay the I/O patterns it
contains. This can be used to store a workload and replay it sometime
later. The iolog given may also be a blktrace binary file, which allows fio
to replay a workload captured by blktrace. See
\fBblktrace\fR\|(8) for how to capture such logging data. For blktrace
replay, the file needs to be turned into a blkparse binary data file first
(`blkparse <device> \-o /dev/null \-d file_for_fio.bin').
You can specify a number of files by separating the names with a ':' character.
See the \fBfilename\fR option for information on how to escape ':'
characters within the file names. These files will be sequentially assigned to
job clones created by \fBnumjobs\fR. '-' is a reserved name, meaning read from
stdin, notably if \fBfilename\fR is set to '-' which means stdin as well,
then this flag can't be set to '-'.
.TP
.BI read_iolog_chunked \fR=\fPbool
Determines how iolog is read. If false (default) entire \fBread_iolog\fR will
be read at once. If selected true, input from iolog will be read gradually.
Useful when iolog is very large, or it is generated.
.TP
.BI merge_blktrace_file \fR=\fPstr
When specified, rather than replaying the logs passed to \fBread_iolog\fR,
the logs go through a merge phase which aggregates them into a single blktrace.
The resulting file is then passed on as the \fBread_iolog\fR parameter. The
intention here is to make the order of events consistent. This limits the
influence of the scheduler compared to replaying multiple blktraces via
concurrent jobs.
.TP
.BI merge_blktrace_scalars \fR=\fPfloat_list
This is a percentage based option that is index paired with the list of files
passed to \fBread_iolog\fR. When merging is performed, scale the time of each
event by the corresponding amount. For example,
`\-\-merge_blktrace_scalars="50:100"' runs the first trace in halftime and the
second trace in realtime. This knob is separately tunable from
\fBreplay_time_scale\fR which scales the trace during runtime and will not
change the output of the merge unlike this option.
.TP
.BI merge_blktrace_iters \fR=\fPfloat_list
This is a whole number option that is index paired with the list of files
passed to \fBread_iolog\fR. When merging is performed, run each trace for
the specified number of iterations. For example,
`\-\-merge_blktrace_iters="2:1"' runs the first trace for two iterations
and the second trace for one iteration.
.TP
.BI replay_no_stall \fR=\fPbool
When replaying I/O with \fBread_iolog\fR the default behavior is to
attempt to respect the timestamps within the log and replay them with the
appropriate delay between IOPS. By setting this variable fio will not
respect the timestamps and attempt to replay them as fast as possible while
still respecting ordering. The result is the same I/O pattern to a given
device, but different timings.
.TP
.BI replay_time_scale \fR=\fPint
When replaying I/O with \fBread_iolog\fR, fio will honor the original timing
in the trace. With this option, it's possible to scale the time. It's a
percentage option, if set to 50 it means run at 50% the original IO rate in
the trace. If set to 200, run at twice the original IO rate. Defaults to 100.
.TP
.BI replay_redirect \fR=\fPstr
While replaying I/O patterns using \fBread_iolog\fR the default behavior
is to replay the IOPS onto the major/minor device that each IOP was recorded
from. This is sometimes undesirable because on a different machine those
major/minor numbers can map to a different device. Changing hardware on the
same system can also result in a different major/minor mapping.
\fBreplay_redirect\fR causes all I/Os to be replayed onto the single specified
device regardless of the device it was recorded
from. i.e. `replay_redirect=/dev/sdc' would cause all I/O
in the blktrace or iolog to be replayed onto `/dev/sdc'. This means
multiple devices will be replayed onto a single device, if the trace
contains multiple devices. If you want multiple devices to be replayed
concurrently to multiple redirected devices you must blkparse your trace
into separate traces and replay them with independent fio invocations.
Unfortunately this also breaks the strict time ordering between multiple
device accesses.
.TP
.BI replay_align \fR=\fPint
Force alignment of the byte offsets in a trace to this value. The value
must be a power of 2.
.TP
.BI replay_scale \fR=\fPint
Scale bye offsets down by this factor when replaying traces. Should most
likely use \fBreplay_align\fR as well.
.SS "Threads, processes and job synchronization"
.TP
.BI replay_skip \fR=\fPstr
Sometimes it's useful to skip certain IO types in a replay trace. This could
be, for instance, eliminating the writes in the trace. Or not replaying the
trims/discards, if you are redirecting to a device that doesn't support them.
This option takes a comma separated list of read, write, trim, sync.
.TP
.BI thread
Fio defaults to creating jobs by using fork, however if this option is
given, fio will create jobs by using POSIX Threads' function
\fBpthread_create\fR\|(3) to create threads instead.
.TP
.BI wait_for \fR=\fPstr
If set, the current job won't be started until all workers of the specified
waitee job are done.
.\" ignore blank line here from HOWTO as it looks normal without it
\fBwait_for\fR operates on the job name basis, so there are a few
limitations. First, the waitee must be defined prior to the waiter job
(meaning no forward references). Second, if a job is being referenced as a
waitee, it must have a unique name (no duplicate waitees).
.TP
.BI nice \fR=\fPint
Run the job with the given nice value. See man \fBnice\fR\|(2).
.\" ignore blank line here from HOWTO as it looks normal without it
On Windows, values less than \-15 set the process class to "High"; \-1 through
\-15 set "Above Normal"; 1 through 15 "Below Normal"; and above 15 "Idle"
priority class.
.TP
.BI prio \fR=\fPint
Set the I/O priority value of this job. Linux limits us to a positive value
between 0 and 7, with 0 being the highest. See man
\fBionice\fR\|(1). Refer to an appropriate manpage for other operating
systems since meaning of priority may differ. For per-command priority
setting, see the I/O engine specific `cmdprio_percentage` and
`cmdprio` options.
.TP
.BI prioclass \fR=\fPint
Set the I/O priority class. See man \fBionice\fR\|(1). For per-command
priority setting, see the I/O engine specific `cmdprio_percentage` and
`cmdprio_class` options.
.TP
.BI priohint \fR=\fPint
Set the I/O priority hint. This is only applicable to platforms that support
I/O priority classes and to devices with features controlled through priority
hints, e.g. block devices supporting command duration limits, or CDL. CDL is a
way to indicate the desired maximum latency of I/Os so that the device can
optimize its internal command scheduling according to the latency limits
indicated by the user. For per-I/O priority hint setting, see the I/O engine
specific \fBcmdprio_hint\fB option.
.TP
.BI cpus_allowed \fR=\fPstr
Controls the same options as \fBcpumask\fR, but accepts a textual
specification of the permitted CPUs instead and CPUs are indexed from 0. So
to use CPUs 0 and 5 you would specify `cpus_allowed=0,5'. This option also
allows a range of CPUs to be specified \-\- say you wanted a binding to CPUs
0, 5, and 8 to 15, you would set `cpus_allowed=0,5,8\-15'.
.RS
.P
On Windows, when `cpus_allowed' is unset only CPUs from fio's current
processor group will be used and affinity settings are inherited from the
system. An fio build configured to target Windows 7 makes options that set
CPUs processor group aware and values will set both the processor group
and a CPU from within that group. For example, on a system where processor
group 0 has 40 CPUs and processor group 1 has 32 CPUs, `cpus_allowed'
values between 0 and 39 will bind CPUs from processor group 0 and
`cpus_allowed' values between 40 and 71 will bind CPUs from processor
group 1. When using `cpus_allowed_policy=shared' all CPUs specified by a
single `cpus_allowed' option must be from the same processor group. For
Windows fio builds not built for Windows 7, CPUs will only be selected from
(and be relative to) whatever processor group fio happens to be running in
and CPUs from other processor groups cannot be used.
.RE
.TP
.BI cpus_allowed_policy \fR=\fPstr
Set the policy of how fio distributes the CPUs specified by
\fBcpus_allowed\fR or \fBcpumask\fR. Two policies are supported:
.RS
.RS
.TP
.B shared
All jobs will share the CPU set specified.
.TP
.B split
Each job will get a unique CPU from the CPU set.
.RE
.P
\fBshared\fR is the default behavior, if the option isn't specified. If
\fBsplit\fR is specified, then fio will assign one cpu per job. If not
enough CPUs are given for the jobs listed, then fio will roundrobin the CPUs
in the set.
.RE
.TP
.BI cpumask \fR=\fPint
Set the CPU affinity of this job. The parameter given is a bit mask of
allowed CPUs the job may run on. So if you want the allowed CPUs to be 1
and 5, you would pass the decimal value of (1 << 1 | 1 << 5), or 34. See man
\fBsched_setaffinity\fR\|(2). This may not work on all supported
operating systems or kernel versions. This option doesn't work well for a
higher CPU count than what you can store in an integer mask, so it can only
control cpus 1\-32. For boxes with larger CPU counts, use
\fBcpus_allowed\fR.
.TP
.BI numa_cpu_nodes \fR=\fPstr
Set this job running on specified NUMA nodes' CPUs. The arguments allow
comma delimited list of cpu numbers, A\-B ranges, or `all'. Note, to enable
NUMA options support, fio must be built on a system with libnuma\-dev(el)
installed.
.TP
.BI numa_mem_policy \fR=\fPstr
Set this job's memory policy and corresponding NUMA nodes. Format of the
arguments:
.RS
.RS
.P
<mode>[:<nodelist>]
.RE
.P
`mode' is one of the following memory policies: `default', `prefer',
`bind', `interleave' or `local'. For `default' and `local' memory
policies, no node needs to be specified. For `prefer', only one node is
allowed. For `bind' and `interleave' the `nodelist' may be as
follows: a comma delimited list of numbers, A\-B ranges, or `all'.
.RE
.TP
.BI cgroup \fR=\fPstr
Add job to this control group. If it doesn't exist, it will be created. The
system must have a mounted cgroup blkio mount point for this to work. If
your system doesn't have it mounted, you can do so with:
.RS
.RS
.P
# mount \-t cgroup \-o blkio none /cgroup
.RE
.RE
.TP
.BI cgroup_weight \fR=\fPint
Set the weight of the cgroup to this value. See the documentation that comes
with the kernel, allowed values are in the range of 100..1000.
.TP
.BI cgroup_nodelete \fR=\fPbool
Normally fio will delete the cgroups it has created after the job
completion. To override this behavior and to leave cgroups around after the
job completion, set `cgroup_nodelete=1'. This can be useful if one wants
to inspect various cgroup files after job completion. Default: false.
.TP
.BI flow_id \fR=\fPint
The ID of the flow. If not specified, it defaults to being a global
flow. See \fBflow\fR.
.TP
.BI flow \fR=\fPint
Weight in token-based flow control. If this value is used,
then fio regulates the activity between two or more jobs
sharing the same flow_id.
Fio attempts to keep each job activity proportional to other jobs' activities
in the same flow_id group, with respect to requested weight per job.
That is, if one job has `flow=3', another job has `flow=2'
and another with `flow=1`, then there will be a roughly 3:2:1 ratio
in how much one runs vs the others.
.TP
.BI flow_sleep \fR=\fPint
The period of time, in microseconds, to wait after the flow counter
has exceeded its proportion before retrying operations.
.TP
.BI stonewall "\fR,\fB wait_for_previous"
Wait for preceding jobs in the job file to exit, before starting this
one. Can be used to insert serialization points in the job file. A stone
wall also implies starting a new reporting group, see
\fBgroup_reporting\fR. Optionally you can use `stonewall=0` to disable or
`stonewall=1` to enable it.
.TP
.BI exitall
By default, fio will continue running all other jobs when one job finishes.
Sometimes this is not the desired action. Setting \fBexitall\fR will instead
make fio terminate all jobs in the same group, as soon as one job of that
group finishes.
.TP
.BI exit_what \fR=\fPstr
By default, fio will continue running all other jobs when one job finishes.
Sometimes this is not the desired action. Setting \fBexitall\fR will instead
make fio terminate all jobs in the same group. The option \fBexit_what\fR
allows you to control which jobs get terminated when \fBexitall\fR is enabled.
The default value is \fBgroup\fR.
The allowed values are:
.RS
.RS
.TP
.B all
terminates all jobs.
.TP
.B group
is the default and does not change the behaviour of \fBexitall\fR.
.TP
.B stonewall
terminates all currently running jobs across all groups and continues
execution with the next stonewalled group.
.RE
.RE
.TP
.BI exec_prerun \fR=\fPstr
Before running this job, issue the command specified through
\fBsystem\fR\|(3). Output is redirected in a file called `jobname.prerun.txt'.
.TP
.BI exec_postrun \fR=\fPstr
After the job completes, issue the command specified though
\fBsystem\fR\|(3). Output is redirected in a file called `jobname.postrun.txt'.
.TP
.BI uid \fR=\fPint
Instead of running as the invoking user, set the user ID to this value
before the thread/process does any work.
.TP
.BI gid \fR=\fPint
Set group ID, see \fBuid\fR.
.SS "Verification"
.TP
.BI verify_only
Do not perform specified workload, only verify data still matches previous
invocation of this workload. This option allows one to check data multiple
times at a later date without overwriting it. This option makes sense only
for workloads that write data, and does not support workloads with the
\fBtime_based\fR option set. Options \fBverify_write_sequence\fR and
\fBverify_header_seed\fR will be disabled in this mode, unless they are
explicitly enabled.
.TP
.BI do_verify \fR=\fPbool
Run the verify phase after a write phase. Only valid if \fBverify\fR is
set. Default: true.
.TP
.BI verify \fR=\fPstr
If writing to a file, fio can verify the file contents after each iteration
of the job. Each verification method also implies verification of special
header, which is written to the beginning of each block. This header also
includes meta information, like offset of the block, block number, timestamp
when block was written, initial seed value used to generate the buffer
contents, etc. \fBverify\fR can be combined with \fBverify_pattern\fR option.
The allowed values are:
.RS
.RS
.TP
.B md5
Use an md5 sum of the data area and store it in the header of
each block.
.TP
.B crc64
Use an experimental crc64 sum of the data area and store it in the
header of each block.
.TP
.B crc32c
Use a crc32c sum of the data area and store it in the header of
each block. This will automatically use hardware acceleration
(e.g. SSE4.2 on an x86 or CRC crypto extensions on ARM64) but will
fall back to software crc32c if none is found. Generally the
fastest checksum fio supports when hardware accelerated.
.TP
.B crc32c\-intel
Synonym for crc32c.
.TP
.B crc32
Use a crc32 sum of the data area and store it in the header of each
block.
.TP
.B crc16
Use a crc16 sum of the data area and store it in the header of each
block.
.TP
.B crc7
Use a crc7 sum of the data area and store it in the header of each
block.
.TP
.B xxhash
Use xxhash as the checksum function. Generally the fastest software
checksum that fio supports.
.TP
.B sha512
Use sha512 as the checksum function.
.TP
.B sha256
Use sha256 as the checksum function.
.TP
.B sha1
Use optimized sha1 as the checksum function.
.TP
.B sha3\-224
Use optimized sha3\-224 as the checksum function.
.TP
.B sha3\-256
Use optimized sha3\-256 as the checksum function.
.TP
.B sha3\-384
Use optimized sha3\-384 as the checksum function.
.TP
.B sha3\-512
Use optimized sha3\-512 as the checksum function.
.TP
.B meta
This option is deprecated, since now meta information is included in
generic verification header and meta verification happens by
default. For detailed information see the description of the
\fBverify\fR setting. This option is kept because of
compatibility's sake with old configurations. Do not use it.
.TP
.B pattern
Verify a strict pattern. Normally fio includes a header with some
basic information and checksumming, but if this option is set, only
the specific pattern set with \fBverify_pattern\fR is verified.
.TP
.B pattern_hdr
Verify a pattern in conjunction with a header.
.TP
.B null
Only pretend to verify. Useful for testing internals with
`ioengine=null', not for much else.
.RE
.P
This option can be used for repeated burn\-in tests of a system to make sure
that the written data is also correctly read back.
.P
If the data direction given is a read or random read, fio will assume that it
should verify a previously written file. In this scenario fio will not verify
the block number written in the header. The header seed won't be verified,
unless its explicitly requested by setting \fBverify_header_seed\fR option.
Note in this scenario the header seed check will only work if the read
invocation exactly matches the original write invocation.
.P
If the data direction includes any form of write, the verify will be of the
newly written data.
.P
To avoid false verification errors, do not use the norandommap option when
verifying data with async I/O engines and I/O depths > 1.  Or use the
norandommap and the lfsr random generator together to avoid writing to the
same offset with multiple outstanding I/Os.
.RE
.TP
.BI verify_offset \fR=\fPint
Swap the verification header with data somewhere else in the block before
writing. It is swapped back before verifying. This should be within the range
of \fBverify_interval\fR.
.TP
.BI verify_interval \fR=\fPint
Write the verification header at a finer granularity than the
\fBblocksize\fR. It will be written for chunks the size of
\fBverify_interval\fR. \fBblocksize\fR should divide this evenly.
.TP
.BI verify_pattern \fR=\fPstr
If set, fio will fill the I/O buffers with this pattern. Fio defaults to
filling with totally random bytes, but sometimes it's interesting to fill
with a known pattern for I/O verification purposes. Depending on the width
of the pattern, fio will fill 1/2/3/4 bytes of the buffer at the time (it can
be either a decimal or a hex number). The \fBverify_pattern\fR if larger than
a 32\-bit quantity has to be a hex number that starts with either "0x" or
"0X". Use with \fBverify\fR. Also, \fBverify_pattern\fR supports %o
format, which means that for each block offset will be written and then
verified back, e.g.:
.RS
.RS
.P
verify_pattern=%o
.RE
.P
Or use combination of everything:
.RS
.P
verify_pattern=0xff%o"abcd"\-12
.RE
.RE
.TP
.BI verify_pattern_interval \fR=\fPbool
Recreate an instance of the \fBverify_pattern\fR every
\fBverify_pattern_interval\fR bytes. This is only useful when
\fBverify_pattern\fR contains the %o format specifier and can be used to speed
up the process of writing each block on a device with its offset. Default:
0 (disabled).
.TP
.BI verify_fatal \fR=\fPbool
Normally fio will keep checking the entire contents before quitting on a
block verification failure. If this option is set, fio will exit the job on
the first observed failure. Default: false.
.TP
.BI verify_dump \fR=\fPbool
If set, dump the contents of both the original data block and the data block
we read off disk to files. This allows later analysis to inspect just what
kind of data corruption occurred. Off by default.
.TP
.BI verify_async \fR=\fPint
Fio will normally verify I/O inline from the submitting thread. This option
takes an integer describing how many async offload threads to create for I/O
verification instead, causing fio to offload the duty of verifying I/O
contents to one or more separate threads. If using this offload option, even
sync I/O engines can benefit from using an \fBiodepth\fR setting higher
than 1, as it allows them to have I/O in flight while verifies are running.
Defaults to 0 async threads, i.e. verification is not asynchronous.
.TP
.BI verify_async_cpus \fR=\fPstr
Tell fio to set the given CPU affinity on the async I/O verification
threads. See \fBcpus_allowed\fR for the format used.
.TP
.BI verify_backlog \fR=\fPint
Fio will normally verify the written contents of a job that utilizes verify
once that job has completed. In other words, everything is written then
everything is read back and verified. You may want to verify continually
instead for a variety of reasons. Fio stores the meta data associated with
an I/O block in memory, so for large verify workloads, quite a bit of memory
would be used up holding this meta data. If this option is enabled, fio will
write only N blocks before verifying these blocks.
.TP
.BI verify_backlog_batch \fR=\fPint
Control how many blocks fio will verify if \fBverify_backlog\fR is
set. If not set, will default to the value of \fBverify_backlog\fR
(meaning the entire queue is read back and verified). If
\fBverify_backlog_batch\fR is less than \fBverify_backlog\fR then not all
blocks will be verified, if \fBverify_backlog_batch\fR is larger than
\fBverify_backlog\fR, some blocks will be verified more than once.
.TP
.BI verify_state_save \fR=\fPbool
When a job exits during the write phase of a verify workload, save its
current state. This allows fio to replay up until that point, if the verify
state is loaded for the verify read phase. The format of the filename is,
roughly:
.RS
.RS
.P
<type>\-<jobname>\-<jobindex>\-verify.state.
.RE
.P
<type> is "local" for a local run, "sock" for a client/server socket
connection, and "ip" (192.168.0.1, for instance) for a networked
client/server connection. Defaults to true.
.RE
.TP
.BI verify_state_load \fR=\fPbool
If a verify termination trigger was used, fio stores the current write state
of each thread. This can be used at verification time so that fio knows how
far it should verify. Without this information, fio will run a full
verification pass, according to the settings in the job file used. Default
false.
.TP
.BI experimental_verify \fR=\fPbool
Enable experimental verification. Standard verify records I/O metadata for
later use during the verification phase. Experimental verify instead resets the
file after the write phase and then replays I/Os for the verification phase.
.TP
.BI verify_write_sequence \fR=\fPbool
Verify the header write sequence number. In a scenario with multiple jobs,
verification of the write sequence number may fail. Disabling this option
will mean that write sequence number checking is skipped. Doing that can be
useful for testing atomic writes, as it means that checksum verification can
still be attempted. For when \fBatomic\fR is enabled, checksum verification
is expected to succeed (while write sequence checking can still fail).
.TP
.BI verify_header_seed \fR=\fPbool
Verify the header seed value which was used to generate the buffer contents.
In certain scenarios with read / verify only workloads, when \fBnorandommap\fR
is enabled, with offset modifiers (refer options \fBreadwrite\fR and
\fBrw_sequencer\fR), etc verification of header seed may fail. Disabling this
option will mean that header seed checking is skipped. Defaults to true.
.TP
.BI trim_percentage \fR=\fPint
Number of verify blocks to discard/trim.
.TP
.BI trim_verify_zero \fR=\fPbool
Verify that trim/discarded blocks are returned as zeros.
.TP
.BI trim_backlog \fR=\fPint
Verify that trim/discarded blocks are returned as zeros.
.TP
.BI trim_backlog_batch \fR=\fPint
Trim this number of I/O blocks.
.SS "Steady state"
.TP
.BI steadystate \fR=\fPstr:float "\fR,\fP ss" \fR=\fPstr:float
Define the criterion and limit for assessing steady state performance. The
first parameter designates the criterion whereas the second parameter sets
the threshold. When the criterion falls below the threshold for the
specified duration, the job will stop. For example, `iops_slope:0.1%' will
direct fio to terminate the job when the least squares regression slope
falls below 0.1% of the mean IOPS. If \fBgroup_reporting\fR is enabled
this will apply to all jobs in the group. Below is the list of available
steady state assessment criteria. All assessments are carried out using only
data from the rolling collection window. Threshold limits can be expressed
as a fixed value or as a percentage of the mean in the collection window.
.RS
.P
When using this feature, most jobs should include the \fBtime_based\fR
and \fBruntime\fR options or the \fBloops\fR option so that fio does not
stop running after it has covered the full size of the specified file(s)
or device(s).
.RS
.RS
.TP
.B iops
Collect IOPS data. Stop the job if all individual IOPS measurements
are within the specified limit of the mean IOPS (e.g., `iops:2'
means that all individual IOPS values must be within 2 of the mean,
whereas `iops:0.2%' means that all individual IOPS values must be
within 0.2% of the mean IOPS to terminate the job).
.TP
.B iops_slope
Collect IOPS data and calculate the least squares regression
slope. Stop the job if the slope falls below the specified limit.
.TP
.B bw
Collect bandwidth data. Stop the job if all individual bandwidth
measurements are within the specified limit of the mean bandwidth.
.TP
.B bw_slope
Collect bandwidth data and calculate the least squares regression
slope. Stop the job if the slope falls below the specified limit.
.RE
.RE
.TP
.BI steadystate_duration \fR=\fPtime "\fR,\fP ss_dur" \fR=\fPtime
A rolling window of this duration will be used to judge whether steady state
has been reached. Data will be collected every \fBss_interval\fR. The default
is 0 which disables steady state detection. When the unit is omitted, the value
is interpreted in seconds.
.TP
.BI steadystate_ramp_time \fR=\fPtime "\fR,\fP ss_ramp" \fR=\fPtime
Allow the job to run for the specified duration before beginning data
collection for checking the steady state job termination criterion. The
default is 0. When the unit is omitted, the value is interpreted in seconds.
.TP
.BI steadystate_check_interval \fR=\fPtime "\fR,\fP ss_interval" \fR=\fPtime
The values suring the rolling window will be collected with a period of this
value. If \fBss_interval\fR is 30s and \fBss_dur\fR is 300s, 10 measurements
will be taken. Default is 1s but that might not converge, especially for slower
devices, so set this accordingly. When the unit is omitted, the value is
interpreted in seconds.
.SS "Measurements and reporting"
.TP
.BI per_job_logs \fR=\fPbool
If set to true, fio generates bw/clat/iops logs with per job unique filenames.
If set to false, jobs with identical names will share a log filename. Note that
when this option is set to false log files will be opened in append mode and if
log files already exist the previous contents will not be overwritten. Default:
true.
.TP
.BI group_reporting
It may sometimes be interesting to display statistics for groups of jobs as
a whole instead of for each individual job. This is especially true if
\fBnumjobs\fR is used; looking at individual thread/process output
quickly becomes unwieldy. To see the final report per-group instead of
per-job, use \fBgroup_reporting\fR. Jobs in a file will be part of the
same reporting group, unless if separated by a \fBstonewall\fR, or by
using \fBnew_group\fR.
.RS
.P
NOTE: When \fBgroup_reporting\fR is used along with \fBjson\fR output, there
are certain per-job properties which can be different between jobs but do not
have a natural group-level equivalent. Examples include \fBkb_base\fR,
\fBunit_base\fR, \fBsig_figs\fR, \fBthread_number\fR, \fBpid\fR, and
\fBjob_start\fR. For these properties, the values for the first job are
recorded for the group.
.P
Also, options like \fBpercentile_list\fR and \fBunified_rw_reporting\fR should
be consistent among the jobs in a reporting group. Having options like these
vary across the jobs in a reporting group is an unsupported configuration.
.RE
.TP
.BI new_group
Start a new reporting group. See: \fBgroup_reporting\fR. If not given,
all jobs in a file will be part of the same reporting group, unless
separated by a \fBstonewall\fR.
.TP
.BI stats \fR=\fPbool
By default, fio collects and shows final output results for all jobs
that run. If this option is set to 0, then fio will ignore it in
the final stat output.
.TP
.BI write_bw_log \fR=\fPstr
If given, write a bandwidth log for this job. Can be used to store data of
the bandwidth of the jobs in their lifetime.
.RS
.P
If no str argument is given, the default filename of
`jobname_type.x.log' is used. Even when the argument is given, fio
will still append the type of log. So if one specifies:
.RS
.P
write_bw_log=foo
.RE
.P
The actual log name will be `foo_bw.x.log' where `x' is the index
of the job (1..N, where N is the number of jobs). If
\fBper_job_logs\fR is false, then the filename will not include the
`.x` job index.
.P
The included \fBfio_generate_plots\fR script uses gnuplot to turn these
text files into nice graphs. See the \fBLOG FILE FORMATS\fR section for how data is
structured within the file.
.RE
.TP
.BI write_lat_log \fR=\fPstr
Same as \fBwrite_bw_log\fR, except this option creates I/O
submission (e.g., `name_slat.x.log'), completion (e.g.,
`name_clat.x.log'), and total (e.g., `name_lat.x.log') latency
files instead. See \fBwrite_bw_log\fR for details about the
filename format and the \fBLOG FILE FORMATS\fR section for how data is structured
within the files.
.TP
.BI write_hist_log \fR=\fPstr
Same as \fBwrite_bw_log\fR but writes an I/O completion latency
histogram file (e.g., `name_hist.x.log') instead. Note that this
file will be empty unless \fBlog_hist_msec\fR has also been set.
See \fBwrite_bw_log\fR for details about the filename format and
the \fBLOG FILE FORMATS\fR section for how data is structured
within the file.
.TP
.BI write_iops_log \fR=\fPstr
Same as \fBwrite_bw_log\fR, but writes an IOPS file (e.g.
`name_iops.x.log`) instead. Because fio defaults to individual
I/O logging, the value entry in the IOPS log will be 1 unless windowed
logging (see \fBlog_avg_msec\fR) has been enabled. See
\fBwrite_bw_log\fR for details about the filename format and \fBLOG
FILE FORMATS\fR for how data is structured within the file.
.TP
.BI log_entries \fR=\fPint
By default, fio will log an entry in the iops, latency, or bw log for
every I/O that completes. The initial number of I/O log entries is 1024.
When the log entries are all used, new log entries are dynamically
allocated.  This dynamic log entry allocation may negatively impact
time-related statistics such as I/O tail latencies (e.g. 99.9th percentile
completion latency). This option allows specifying a larger initial
number of log entries to avoid run-time allocation of new log entries,
resulting in more precise time-related I/O statistics.
Also see \fBlog_avg_msec\fR as well. Defaults to 1024.
.TP
.BI log_avg_msec \fR=\fPint
By default, fio will log an entry in the iops, latency, or bw log for every I/O
that completes. When writing to the disk log, that can quickly grow to a very
large size. Setting this option directs fio to instead record an average over
the specified duration for each log entry, reducing the resolution of the log.
When the job completes, fio will flush any accumulated latency log data, so the
final log interval may not match the value specified by this option and there
may even be duplicate timestamps. See \fBlog_window_value\fR as well. Defaults
to 0, logging entries for each I/O. Also see \fBLOG FILE FORMATS\fR section.
.TP
.BI log_hist_msec \fR=\fPint
Same as \fBlog_avg_msec\fR, but logs entries for completion latency
histograms. Computing latency percentiles from averages of intervals using
\fBlog_avg_msec\fR is inaccurate. Setting this option makes fio log
histogram entries over the specified period of time, reducing log sizes for
high IOPS devices while retaining percentile accuracy. See
\fBlog_hist_coarseness\fR and \fBwrite_hist_log\fR as well.
Defaults to 0, meaning histogram logging is disabled.
.TP
.BI log_hist_coarseness \fR=\fPint
Integer ranging from 0 to 6, defining the coarseness of the resolution of
the histogram logs enabled with \fBlog_hist_msec\fR. For each increment
in coarseness, fio outputs half as many bins. Defaults to 0, for which
histogram logs contain 1216 latency bins. See \fBLOG FILE FORMATS\fR section.
.TP
.BI log_window_value \fR=\fPstr "\fR,\fP log_max_value" \fR=\fPstr
If \fBlog_avg_msec\fR is set, fio by default logs the average over that window.
This option determines whether fio logs the average, maximum or both the
values over the window. This only affects the latency logging, as both average
and maximum values for iops or bw log will be same. Accepted values are:
.RS
.TP
.B avg
Log average value over the window. The default.
.TP
.B max
Log maximum value in the window.
.TP
.B both
Log both average and maximum value over the window.
.TP
.B 0
Backward-compatible alias for \fBavg\fR.
.TP
.B 1
Backward-compatible alias for \fBmax\fR.
.RE
.TP
.BI log_offset \fR=\fPbool
If this is set, the iolog options will include the byte offset for the I/O
entry as well as the other data values. Defaults to 0 meaning that
offsets are not present in logs. Also see \fBLOG FILE FORMATS\fR section.
.TP
.BI log_prio \fR=\fPbool
If this is set, the `Command priority` field in \fBLOG FILE FORMATS\fR
shows the priority value and the IO priority class of the command.
Otherwise, the field shows if the command has the highest RT priority
class or not. Also see \fBLOG FILE FORMATS\fR section.
.TP
.BI log_issue_time \fR=\fPbool
If this is set, the iolog options will include the command issue time for the
I/O entry as well as the other data values. Defaults to 0 meaning that command
issue times are not present in logs. Also see \fBLOG FILE FORMATS\fR section.
This option shall be set together with \fBwrite_lat_log\fR and \fBlog_offset\fR.
.TP
.BI log_compression \fR=\fPint
If this is set, fio will compress the I/O logs as it goes, to keep the
memory footprint lower. When a log reaches the specified size, that chunk is
removed and compressed in the background. Given that I/O logs are fairly
highly compressible, this yields a nice memory savings for longer runs. The
downside is that the compression will consume some background CPU cycles, so
it may impact the run. This, however, is also true if the logging ends up
consuming most of the system memory. So pick your poison. The I/O logs are
saved normally at the end of a run, by decompressing the chunks and storing
them in the specified log file. This feature depends on the availability of
zlib.
.TP
.BI log_compression_cpus \fR=\fPstr
Define the set of CPUs that are allowed to handle online log compression for
the I/O jobs. This can provide better isolation between performance
sensitive jobs, and background compression work. See \fBcpus_allowed\fR for
the format used.
.TP
.BI log_store_compressed \fR=\fPbool
If set, fio will store the log files in a compressed format. They can be
decompressed with fio, using the \fB\-\-inflate\-log\fR command line
parameter. The files will be stored with a `.fz' suffix.
.TP
.BI log_unix_epoch \fR=\fPbool
Backward-compatible alias for \fBlog_alternate_epoch\fR.
.TP
.BI log_alternate_epoch \fR=\fPbool
If set, fio will log timestamps based on the epoch used by the clock specified
in the \fBlog_alternate_epoch_clock_id\fR option, to the log files produced by
enabling write_type_log for each log type, instead of the default zero-based
timestamps.
.TP
.BI log_alternate_epoch_clock_id \fR=\fPint
Specifies the clock_id to be used by clock_gettime to obtain the alternate
epoch if \fBlog_alternate_epoch\fR is true. Otherwise has no effect. Default
value is 0, or CLOCK_REALTIME.
.TP
.BI block_error_percentiles \fR=\fPbool
If set, record errors in trim block-sized units from writes and trims and
output a histogram of how many trims it took to get to errors, and what kind
of error was encountered.
.TP
.BI bwavgtime \fR=\fPint
Average the calculated bandwidth over the given time. Value is specified in
milliseconds. If the job also does bandwidth logging through
\fBwrite_bw_log\fR, then the minimum of this option and
\fBlog_avg_msec\fR will be used. Default: 500ms.
.TP
.BI iopsavgtime \fR=\fPint
Average the calculated IOPS over the given time. Value is specified in
milliseconds. If the job also does IOPS logging through
\fBwrite_iops_log\fR, then the minimum of this option and
\fBlog_avg_msec\fR will be used. Default: 500ms.
.TP
.BI disk_util \fR=\fPbool
Generate disk utilization statistics, if the platform supports it.
Default: true.
.TP
.BI disable_lat \fR=\fPbool
Disable measurements of total latency numbers. Useful only for cutting back
the number of calls to \fBgettimeofday\fR\|(2), as that does impact
performance at really high IOPS rates. Note that to really get rid of a
large amount of these calls, this option must be used with
\fBdisable_slat\fR and \fBdisable_bw_measurement\fR as well.
.TP
.BI disable_clat \fR=\fPbool
Disable measurements of completion latency numbers. See
\fBdisable_lat\fR.
.TP
.BI disable_slat \fR=\fPbool
Disable measurements of submission latency numbers. See
\fBdisable_lat\fR.
.TP
.BI disable_bw_measurement \fR=\fPbool "\fR,\fP disable_bw" \fR=\fPbool
Disable measurements of throughput/bandwidth numbers. See
\fBdisable_lat\fR.
.TP
.BI slat_percentiles \fR=\fPbool
Report submission latency percentiles. Submission latency is not recorded
for synchronous ioengines.
.TP
.BI clat_percentiles \fR=\fPbool
Report completion latency percentiles.
.TP
.BI lat_percentiles \fR=\fPbool
Report total latency percentiles. Total latency is the sum of submission
latency and completion latency.
.TP
.BI percentile_list \fR=\fPfloat_list
Overwrite the default list of percentiles for latencies and the
block error histogram. Each number is a floating point number in the range
(0,100], and the maximum length of the list is 20. Use ':' to separate the
numbers. For example, `\-\-percentile_list=99.5:99.9' will cause fio to
report the latency durations below which 99.5% and 99.9% of the observed
latencies fell, respectively.
.TP
.BI significant_figures \fR=\fPint
If using \fB\-\-output\-format\fR of `normal', set the significant figures
to this value. Higher values will yield more precise IOPS and throughput
units, while lower values will round. Requires a minimum value of 1 and a
maximum value of 10. Defaults to 4.
.SS "Error handling"
.TP
.BI exitall_on_error
When one job finishes in error, terminate the rest. The default is to wait
for each job to finish.
.TP
.BI continue_on_error \fR=\fPstr
Normally fio will exit the job on the first observed failure. If this option
is set, fio will continue the job when there is a 'non-fatal error' (EIO or
EILSEQ) until the runtime is exceeded or the I/O size specified is
completed. If this option is used, there are two more stats that are
appended, the total error count and the first error. The error field given
in the stats is the first error that was hit during the run.
.RS
.P
Note: a write error from the device may go unnoticed by fio when using buffered
IO, as the write() (or similar) system call merely dirties the kernel pages,
unless `sync' or `direct' is used. Device IO errors occur when the dirty data is
actually written out to disk. If fully sync writes aren't desirable, `fsync' or
`fdatasync' can be used as well. This is specific to writes, as reads are always
synchronous.
.RS
.P
The allowed values are:
.RS
.RS
.TP
.B none
Exit on any I/O or verify errors.
.TP
.B read
Continue on read errors, exit on all others.
.TP
.B write
Continue on write errors, exit on all others.
.TP
.B io
Continue on any I/O error, exit on all others.
.TP
.B verify
Continue on verify errors, exit on all others.
.TP
.B all
Continue on all errors.
.TP
.B 0
Backward-compatible alias for 'none'.
.TP
.B 1
Backward-compatible alias for 'all'.
.RE
.RE
.TP
.BI ignore_error \fR=\fPstr
Sometimes you want to ignore some errors during test in that case you can
specify error list for each error type, instead of only being able to
ignore the default 'non-fatal error' using \fBcontinue_on_error\fR.
`ignore_error=READ_ERR_LIST,WRITE_ERR_LIST,VERIFY_ERR_LIST' errors for
given error type is separated with ':'. Error may be symbol ('ENOSPC', 'ENOMEM')
or integer. Example:
.RS
.RS
.P
ignore_error=EAGAIN,ENOSPC:122
.RE
.P
This option will ignore EAGAIN from READ, and ENOSPC and 122(EDQUOT) from
WRITE. This option works by overriding \fBcontinue_on_error\fR with
the list of errors for each error type if any.
.RE
.TP
.BI error_dump \fR=\fPbool
If set dump every error even if it is non fatal, true by default. If
disabled only fatal error will be dumped.
.SS "Running predefined workloads"
Fio includes predefined profiles that mimic the I/O workloads generated by
other tools.
.TP
.BI profile \fR=\fPstr
The predefined workload to run. Current profiles are:
.RS
.RS
.TP
.B tiobench
Threaded I/O bench (tiotest/tiobench) like workload.
.TP
.B act
Aerospike Certification Tool (ACT) like workload.
.RE
.RE
.P
To view a profile's additional options use \fB\-\-cmdhelp\fR after specifying
the profile. For example:
.RS
.TP
$ fio \-\-profile=act \-\-cmdhelp
.RE
.SS "Act profile options"
.TP
.BI device\-names \fR=\fPstr
Devices to use.
.TP
.BI load \fR=\fPint
ACT load multiplier. Default: 1.
.TP
.BI test\-duration\fR=\fPtime
How long the entire test takes to run. When the unit is omitted, the value
is given in seconds. Default: 24h.
.TP
.BI threads\-per\-queue\fR=\fPint
Number of read I/O threads per device. Default: 8.
.TP
.BI read\-req\-num\-512\-blocks\fR=\fPint
Number of 512B blocks to read at the time. Default: 3.
.TP
.BI large\-block\-op\-kbytes\fR=\fPint
Size of large block ops in KiB (writes). Default: 131072.
.TP
.BI prep
Set to run ACT prep phase.
.SS "Tiobench profile options"
.TP
.BI size\fR=\fPstr
Size in MiB.
.TP
.BI block\fR=\fPint
Block size in bytes. Default: 4096.
.TP
.BI numruns\fR=\fPint
Number of runs.
.TP
.BI dir\fR=\fPstr
Test directory.
.TP
.BI threads\fR=\fPint
Number of threads.
.SH OUTPUT
Fio spits out a lot of output. While running, fio will display the status of the
jobs created. An example of that would be:
.P
.nf
		Jobs: 1 (f=1): [_(1),M(1)][24.8%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 01m:31s]
.fi
.P
The characters inside the first set of square brackets denote the current status of
each thread. The first character is the first job defined in the job file, and so
forth. The possible values (in typical life cycle order) are:
.RS
.TP
.PD 0
.B P
Thread setup, but not started.
.TP
.B C
Thread created.
.TP
.B I
Thread initialized, waiting or generating necessary data.
.TP
.B p
Thread running pre-reading file(s).
.TP
.B /
Thread is in ramp period.
.TP
.B R
Running, doing sequential reads.
.TP
.B r
Running, doing random reads.
.TP
.B W
Running, doing sequential writes.
.TP
.B w
Running, doing random writes.
.TP
.B M
Running, doing mixed sequential reads/writes.
.TP
.B m
Running, doing mixed random reads/writes.
.TP
.B D
Running, doing sequential trims.
.TP
.B d
Running, doing random trims.
.TP
.B F
Running, currently waiting for \fBfsync\fR\|(2).
.TP
.B V
Running, doing verification of written data.
.TP
.B f
Thread finishing.
.TP
.B E
Thread exited, not reaped by main thread yet.
.TP
.B \-
Thread reaped.
.TP
.B X
Thread reaped, exited with an error.
.TP
.B K
Thread reaped, exited due to signal.
.PD
.RE
.P
Fio will condense the thread string as not to take up more space on the command
line than needed. For instance, if you have 10 readers and 10 writers running,
the output would look like this:
.P
.nf
		Jobs: 20 (f=20): [R(10),W(10)][4.0%][r=20.5MiB/s,w=23.5MiB/s][r=82,w=94 IOPS][eta 57m:36s]
.fi
.P
Note that the status string is displayed in order, so it's possible to tell which of
the jobs are currently doing what. In the example above this means that jobs 1\-\-10
are readers and 11\-\-20 are writers.
.P
The other values are fairly self explanatory \-\- number of threads currently
running and doing I/O, the number of currently open files (f=), the estimated
completion percentage, the rate of I/O since last check (read speed listed first,
then write speed and optionally trim speed) in terms of bandwidth and IOPS,
and time to completion for the current running group. It's impossible to estimate
runtime of the following groups (if any).
.P
When fio is done (or interrupted by Ctrl\-C), it will show the data for
each thread, group of threads, and disks in that order. For each overall thread (or
group) the output looks like:
.P
.nf
		Client1: (groupid=0, jobs=1): err= 0: pid=16109: Sat Jun 24 12:07:54 2017
		  write: IOPS=88, BW=623KiB/s (638kB/s)(30.4MiB/50032msec)
		    slat (nsec): min=500, max=145500, avg=8318.00, stdev=4781.50
		    clat (usec): min=170, max=78367, avg=4019.02, stdev=8293.31
		     lat (usec): min=174, max=78375, avg=4027.34, stdev=8291.79
		    clat percentiles (usec):
		     |  1.00th=[  302],  5.00th=[  326], 10.00th=[  343], 20.00th=[  363],
		     | 30.00th=[  392], 40.00th=[  404], 50.00th=[  416], 60.00th=[  445],
		     | 70.00th=[  816], 80.00th=[ 6718], 90.00th=[12911], 95.00th=[21627],
		     | 99.00th=[43779], 99.50th=[51643], 99.90th=[68682], 99.95th=[72877],
		     | 99.99th=[78119]
		   bw (  KiB/s): min=  532, max=  686, per=0.10%, avg=622.87, stdev=24.82, samples=  100
		   iops        : min=   76, max=   98, avg=88.98, stdev= 3.54, samples=  100
		  lat (usec)   : 250=0.04%, 500=64.11%, 750=4.81%, 1000=2.79%
		  lat (msec)   : 2=4.16%, 4=1.84%, 10=4.90%, 20=11.33%, 50=5.37%
		  lat (msec)   : 100=0.65%
		  cpu          : usr=0.27%, sys=0.18%, ctx=12072, majf=0, minf=21
		  IO depths    : 1=85.0%, 2=13.1%, 4=1.8%, 8=0.1%, 16=0.0%, 32=0.0%, >=64=0.0%
		     submit    : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%
		     complete  : 0=0.0%, 4=100.0%, 8=0.0%, 16=0.0%, 32=0.0%, 64=0.0%, >=64=0.0%
		     issued rwt: total=0,4450,0, short=0,0,0, dropped=0,0,0
		     latency   : target=0, window=0, percentile=100.00%, depth=8
.fi
.P
The job name (or first job's name when using \fBgroup_reporting\fR) is printed,
along with the group id, count of jobs being aggregated, last error id seen (which
is 0 when there are no errors), pid/tid of that thread and the time the job/group
completed. Below are the I/O statistics for each data direction performed (showing
writes in the example above). In the order listed, they denote:
.RS
.TP
.B read/write/trim
The string before the colon shows the I/O direction the statistics
are for. \fIIOPS\fR is the average I/Os performed per second. \fIBW\fR
is the average bandwidth rate shown as: value in power of 2 format
(value in power of 10 format). The last two values show: (total
I/O performed in power of 2 format / \fIruntime\fR of that thread).
.TP
.B slat
Submission latency (\fImin\fR being the minimum, \fImax\fR being the
maximum, \fIavg\fR being the average, \fIstdev\fR being the standard
deviation). This is the time it took to submit the I/O. For
sync I/O this row is not displayed as the slat is really the
completion latency (since queue/complete is one operation there).
This value can be in nanoseconds, microseconds or milliseconds \-\-\-
fio will choose the most appropriate base and print that (in the
example above nanoseconds was the best scale). Note: in \fB\-\-minimal\fR mode
latencies are always expressed in microseconds.
.TP
.B clat
Completion latency. Same names as slat, this denotes the time from
submission to completion of the I/O pieces. For sync I/O, clat will
usually be equal (or very close) to 0, as the time from submit to
complete is basically just CPU time (I/O has already been done, see slat
explanation).

For file and directory operation engines, \fBclat\fP denotes the time
to complete one file or directory operation.
.RS
.TP
\fBfilecreate engine\fP:\tthe time cost to create a new file
.TP
\fBfilestat engine\fP:\tthe time cost to look up an existing file
.TP
\fBfiledelete engine\fP:\tthe time cost to delete a file
.TP
\fBdircreate engine\fP:\tthe time cost to create a new directory
.TP
\fBdirstat engine\fP:\tthe time cost to look up an existing directory
.TP
\fBdirdelete engine\fP:\tthe time cost to delete a directory
.RE
.TP
.B lat
Total latency. Same names as slat and clat, this denotes the time from
when fio created the I/O unit to completion of the I/O operation.
.TP
.B bw
Bandwidth statistics based on measurements from discrete intervals. Fio
continuosly monitors bytes transferred and I/O operations completed. By default
fio calculates bandwidth in each half-second interval (see \fBbwavgtime\fR)
and reports descriptive statistics for the measurements here. Same names as the
xlat stats, but also includes the number of samples taken (\fIsamples\fR) and an
approximate percentage of total aggregate bandwidth this thread received in its
group (\fIper\fR). This last value is only really useful if the threads in this
group are on the same disk, since they are then competing for disk access.

For file and directory operation engines, \fBbw\fR is meaningless.
.TP
.B iops
IOPS statistics based on measurements from discrete intervals.
For details see the description for \fBbw\fR above. See
\fBiopsavgtime\fR to control the duration of the intervals.
Same values reported here as for \fBbw\fR except for percentage.

For file and directory operation engines, \fBiops\fP is the most
fundamental index to denote the performance.
It means how many files or directories can be operated per second.
.RS
.TP
\fBfilecreate engine\fP:\tnumber of files can be created per second
.TP
\fBfilestat engine\fP:\tnumber of files can be looked up per second
.TP
\fBfiledelete engine\fP:\tnumber of files can be deleted per second
.TP
\fBdircreate engine\fP:\tnumber of directories can be created per second
.TP
\fBdirstat engine\fP:\tnumber of directories can be looked up per second
.TP
\fBdirdelete engine\fP:\tnumber of directories can be deleted per second
.RE
.TP
.B lat (nsec/usec/msec)
The distribution of I/O completion latencies. This is the time from when
I/O leaves fio and when it gets completed. Unlike the separate
read/write/trim sections above, the data here and in the remaining
sections apply to all I/Os for the reporting group. 250=0.04% means that
0.04% of the I/Os completed in under 250us. 500=64.11% means that 64.11%
of the I/Os required 250 to 499us for completion.
.TP
.B cpu
CPU usage. User and system time, along with the number of context
switches this thread went through, usage of system and user time, and
finally the number of major and minor page faults. The CPU utilization
numbers are averages for the jobs in that reporting group, while the
context and fault counters are summed.
.TP
.B IO depths
The distribution of I/O depths over the job lifetime. The numbers are
divided into powers of 2 and each entry covers depths from that value
up to those that are lower than the next entry \-\- e.g., 16= covers
depths from 16 to 31. Note that the range covered by a depth
distribution entry can be different to the range covered by the
equivalent \fBsubmit\fR/\fBcomplete\fR distribution entry.
.TP
.B IO submit
How many pieces of I/O were submitting in a single submit call. Each
entry denotes that amount and below, until the previous entry \-\- e.g.,
16=100% means that we submitted anywhere between 9 to 16 I/Os per submit
call. Note that the range covered by a \fBsubmit\fR distribution entry can
be different to the range covered by the equivalent depth distribution
entry.
.TP
.B IO complete
Like the above \fBsubmit\fR number, but for completions instead.
.TP
.B IO issued rwt
The number of \fBread/write/trim\fR requests issued, and how many of them were
short or dropped.
.TP
.B IO latency
These values are for \fBlatency_target\fR and related options. When
these options are engaged, this section describes the I/O depth required
to meet the specified latency target.
.RE
.P
After each client has been listed, the group statistics are printed. They
will look like this:
.P
.nf
		Run status group 0 (all jobs):
		   READ: bw=20.9MiB/s (21.9MB/s), 10.4MiB/s\-10.8MiB/s (10.9MB/s\-11.3MB/s), io=64.0MiB (67.1MB), run=2973\-3069msec
		  WRITE: bw=1231KiB/s (1261kB/s), 616KiB/s\-621KiB/s (630kB/s\-636kB/s), io=64.0MiB (67.1MB), run=52747\-53223msec
.fi
.P
For each data direction it prints:
.RS
.TP
.B bw
Aggregate bandwidth of threads in this group followed by the
minimum and maximum bandwidth of all the threads in this group.
Values outside of brackets are power-of-2 format and those
within are the equivalent value in a power-of-10 format.
.TP
.B io
Aggregate I/O performed of all threads in this group. The
format is the same as \fBbw\fR.
.TP
.B run
The smallest and longest runtimes of the threads in this group.
.RE
.P
And finally, the disk statistics are printed. This is Linux specific.
They will look like this:
.P
.nf
		  Disk stats (read/write):
		    sda: ios=16398/16511, sectors=32321/65472, merge=30/162, ticks=6853/819634, in_queue=826487, util=100.00%
.fi
.P
Each value is printed for both reads and writes, with reads first. The
numbers denote:
.RS
.TP
.B ios
Number of I/Os performed by all groups.
.TP
.B merge
Number of merges performed by the I/O scheduler.
.TP
.B ticks
Number of ticks we kept the disk busy.
.TP
.B in_queue
Total time spent in the disk queue.
.TP
.B util
The disk utilization. A value of 100% means we kept the disk
busy constantly, 50% would be a disk idling half of the time.
.RE
.P
It is also possible to get fio to dump the current output while it is running,
without terminating the job. To do that, send fio the USR1 signal. You can
also get regularly timed dumps by using the \fB\-\-status\-interval\fR
parameter, or by creating a file in `/tmp' named
`fio\-dump\-status'. If fio sees this file, it will unlink it and dump the
current output status.
.SH TERSE OUTPUT
For scripted usage where you typically want to generate tables or graphs of the
results, fio can output the results in a semicolon separated format. The format
is one long line of values, such as:
.P
.nf
		2;card0;0;0;7139336;121836;60004;1;10109;27.932460;116.933948;220;126861;3495.446807;1085.368601;226;126864;3523.635629;1089.012448;24063;99944;50.275485%;59818.274627;5540.657370;7155060;122104;60004;1;8338;29.086342;117.839068;388;128077;5032.488518;1234.785715;391;128085;5061.839412;1236.909129;23436;100928;50.287926%;59964.832030;5644.844189;14.595833%;19.394167%;123706;0;7313;0.1%;0.1%;0.1%;0.1%;0.1%;0.1%;100.0%;0.00%;0.00%;0.00%;0.00%;0.00%;0.00%;0.01%;0.02%;0.05%;0.16%;6.04%;40.40%;52.68%;0.64%;0.01%;0.00%;0.01%;0.00%;0.00%;0.00%;0.00%;0.00%
		A description of this job goes here.
.fi
.P
The job description (if provided) follows on a second line for terse v2.
It appears on the same line for other terse versions.
.P
To enable terse output, use the \fB\-\-minimal\fR or
`\-\-output\-format=terse' command line options. The
first value is the version of the terse output format. If the output has to be
changed for some reason, this number will be incremented by 1 to signify that
change.
.P
Split up, the format is as follows (comments in brackets denote when a
field was introduced or whether it's specific to some terse version):
.P
.nf
			terse version, fio version [v3], jobname, groupid, error
.fi
.RS
.P
.B
READ status:
.RE
.P
.nf
			Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
			Submission latency: min, max, mean, stdev (usec)
			Completion latency: min, max, mean, stdev (usec)
			Completion latency percentiles: 20 fields (see below)
			Total latency: min, max, mean, stdev (usec)
			Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev, number of samples [v5]
			IOPS [v5]: min, max, mean, stdev, number of samples
.fi
.RS
.P
.B
WRITE status:
.RE
.P
.nf
			Total IO (KiB), bandwidth (KiB/sec), IOPS, runtime (msec)
			Submission latency: min, max, mean, stdev (usec)
			Completion latency: min, max, mean, stdev (usec)
			Completion latency percentiles: 20 fields (see below)
			Total latency: min, max, mean, stdev (usec)
			Bw (KiB/s): min, max, aggregate percentage of total, mean, stdev, number of samples [v5]
			IOPS [v5]: min, max, mean, stdev, number of samples
.fi
.RS
.P
.B
TRIM status [all but version 3]:
.RE
.P
.nf
			Fields are similar to \fBREAD/WRITE\fR status.
.fi
.RS
.P
.B
CPU usage:
.RE
.P
.nf
			user, system, context switches, major faults, minor faults
.fi
.RS
.P
.B
I/O depths:
.RE
.P
.nf
			<=1, 2, 4, 8, 16, 32, >=64
.fi
.RS
.P
.B
I/O latencies microseconds:
.RE
.P
.nf
			<=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000
.fi
.RS
.P
.B
I/O latencies milliseconds:
.RE
.P
.nf
			<=2, 4, 10, 20, 50, 100, 250, 500, 750, 1000, 2000, >=2000
.fi
.RS
.P
.B
Disk utilization [v3]:
.RE
.P
.nf
			disk name, read ios, write ios, read merges, write merges, read ticks, write ticks, time spent in queue, disk utilization percentage
.fi
.RS
.P
.B
Additional Info (dependent on continue_on_error, default off):
.RE
.P
.nf
			total # errors, first error code
.fi
.RS
.P
.B
Additional Info (dependent on description being set):
.RE
.P
.nf
			Text description
.fi
.P
Completion latency percentiles can be a grouping of up to 20 sets, so for the
terse output fio writes all of them. Each field will look like this:
.P
.nf
		1.00%=6112
.fi
.P
which is the Xth percentile, and the `usec' latency associated with it.
.P
For \fBDisk utilization\fR, all disks used by fio are shown. So for each disk there
will be a disk utilization section.
.P
Below is a single line containing short names for each of the fields in the
minimal output v3, separated by semicolons:
.P
.nf
		terse_version_3;fio_version;jobname;groupid;error;read_kb;read_bandwidth_kb;read_iops;read_runtime_ms;read_slat_min_us;read_slat_max_us;read_slat_mean_us;read_slat_dev_us;read_clat_min_us;read_clat_max_us;read_clat_mean_us;read_clat_dev_us;read_clat_pct01;read_clat_pct02;read_clat_pct03;read_clat_pct04;read_clat_pct05;read_clat_pct06;read_clat_pct07;read_clat_pct08;read_clat_pct09;read_clat_pct10;read_clat_pct11;read_clat_pct12;read_clat_pct13;read_clat_pct14;read_clat_pct15;read_clat_pct16;read_clat_pct17;read_clat_pct18;read_clat_pct19;read_clat_pct20;read_tlat_min_us;read_lat_max_us;read_lat_mean_us;read_lat_dev_us;read_bw_min_kb;read_bw_max_kb;read_bw_agg_pct;read_bw_mean_kb;read_bw_dev_kb;write_kb;write_bandwidth_kb;write_iops;write_runtime_ms;write_slat_min_us;write_slat_max_us;write_slat_mean_us;write_slat_dev_us;write_clat_min_us;write_clat_max_us;write_clat_mean_us;write_clat_dev_us;write_clat_pct01;write_clat_pct02;write_clat_pct03;write_clat_pct04;write_clat_pct05;write_clat_pct06;write_clat_pct07;write_clat_pct08;write_clat_pct09;write_clat_pct10;write_clat_pct11;write_clat_pct12;write_clat_pct13;write_clat_pct14;write_clat_pct15;write_clat_pct16;write_clat_pct17;write_clat_pct18;write_clat_pct19;write_clat_pct20;write_tlat_min_us;write_lat_max_us;write_lat_mean_us;write_lat_dev_us;write_bw_min_kb;write_bw_max_kb;write_bw_agg_pct;write_bw_mean_kb;write_bw_dev_kb;cpu_user;cpu_sys;cpu_csw;cpu_mjf;cpu_minf;iodepth_1;iodepth_2;iodepth_4;iodepth_8;iodepth_16;iodepth_32;iodepth_64;lat_2us;lat_4us;lat_10us;lat_20us;lat_50us;lat_100us;lat_250us;lat_500us;lat_750us;lat_1000us;lat_2ms;lat_4ms;lat_10ms;lat_20ms;lat_50ms;lat_100ms;lat_250ms;lat_500ms;lat_750ms;lat_1000ms;lat_2000ms;lat_over_2000ms;disk_name;disk_read_iops;disk_write_iops;disk_read_merges;disk_write_merges;disk_read_ticks;write_ticks;disk_queue_time;disk_util
.fi
.P
In client/server mode terse output differs from what appears when jobs are run
locally. Disk utilization data is omitted from the standard terse output and
for v3 and later appears on its own separate line at the end of each terse
reporting cycle.
.SH JSON OUTPUT
The \fBjson\fR output format is intended to be both human readable and convenient
for automated parsing. For the most part its sections mirror those of the
\fBnormal\fR output. The \fBruntime\fR value is reported in msec and the \fBbw\fR value is
reported in 1024 bytes per second units.
.fi
.SH JSON+ OUTPUT
The \fBjson+\fR output format is identical to the \fBjson\fR output format except that it
adds a full dump of the completion latency bins. Each \fBbins\fR object contains a
set of (key, value) pairs where keys are latency durations and values count how
many I/Os had completion latencies of the corresponding duration. For example,
consider:
.RS
.P
"bins" : { "87552" : 1, "89600" : 1, "94720" : 1, "96768" : 1, "97792" : 1, "99840" : 1, "100864" : 2, "103936" : 6, "104960" : 534, "105984" : 5995, "107008" : 7529, ... }
.RE
.P
This data indicates that one I/O required 87,552ns to complete, two I/Os required
100,864ns to complete, and 7529 I/Os required 107,008ns to complete.
.P
Also included with fio is a Python script \fBfio_jsonplus_clat2csv\fR that takes
json+ output and generates CSV-formatted latency data suitable for plotting.
.P
The latency durations actually represent the midpoints of latency intervals.
For details refer to `stat.h' in the fio source.
.SH TRACE FILE FORMAT
There are two trace file format that you can encounter. The older (v1) format is
unsupported since version 1.20\-rc3 (March 2008). It will still be described
below in case that you get an old trace and want to understand it.
.P
In any case the trace is a simple text file with a single action per line.
.TP
.B Trace file format v1
Each line represents a single I/O action in the following format:
.RS
.RS
.P
rw, offset, length
.RE
.P
where `rw=0/1' for read/write, and the `offset' and `length' entries being in bytes.
.P
This format is not supported in fio versions >= 1.20\-rc3.
.RE
.TP
.B Trace file format v2
The second version of the trace file format was added in fio version 1.17. It
allows one to access more than one file per trace and has a bigger set of possible
file actions.
.RS
.P
The first line of the trace file has to be:
.RS
.P
"fio version 2 iolog"
.RE
.P
Following this can be lines in two different formats, which are described below.
.P
.B
The file management format:
.RS
filename action
.P
The `filename' is given as an absolute path. The `action' can be one of these:
.RS
.TP
.B add
Add the given `filename' to the trace.
.TP
.B open
Open the file with the given `filename'. The `filename' has to have
been added with the \fBadd\fR action before.
.TP
.B close
Close the file with the given `filename'. The file has to have been
\fBopen\fRed before.
.RE
.RE
.P
.B
The file I/O action format:
.RS
filename action offset length
.P
The `filename' is given as an absolute path, and has to have been \fBadd\fRed and
\fBopen\fRed before it can be used with this format. The `offset' and `length' are
given in bytes. The `action' can be one of these:
.RS
.TP
.B wait
Wait for `offset' microseconds. Everything below 100 is discarded.
The time is relative to the previous `wait' statement. Note that action `wait`
is not allowed as of version 3, as the same behavior can be achieved using
timestamps.
.TP
.B read
Read `length' bytes beginning from `offset'.
.TP
.B write
Write `length' bytes beginning from `offset'.
.TP
.B sync
\fBfsync\fR\|(2) the file.
.TP
.B datasync
\fBfdatasync\fR\|(2) the file.
.TP
.B trim
Trim the given file from the given `offset' for `length' bytes.
.RE
.RE
.RE
.TP
.B Trace file format v3
The third version of the trace file format was added in fio version 3.31. It
forces each action to have a timestamp associated with it.
.RS
.P
The first line of the trace file has to be:
.RS
.P
"fio version 3 iolog"
.RE
.P
Following this can be lines in two different formats, which are described below.
.P
.B
The file management format:
.RS
timestamp filename action
.RE
.P
.B
The file I/O action format:
.RS
timestamp filename action offset length
.RE
.P
The `timestamp` is relative to the beginning of the run (ie starts at 0). The
`filename`, `action`, `offset` and `length`  are identical to version 2, except
that version 3 does not allow the `wait` action.
.RE
.SH I/O REPLAY \- MERGING TRACES
Colocation is a common practice used to get the most out of a machine.
Knowing which workloads play nicely with each other and which ones don't is
a much harder task. While fio can replay workloads concurrently via multiple
jobs, it leaves some variability up to the scheduler making results harder to
reproduce. Merging is a way to make the order of events consistent.
.P
Merging is integrated into I/O replay and done when a \fBmerge_blktrace_file\fR
is specified. The list of files passed to \fBread_iolog\fR go through the merge
process and output a single file stored to the specified file. The output file is
passed on as if it were the only file passed to \fBread_iolog\fR. An example would
look like:
.RS
.P
$ fio \-\-read_iolog="<file1>:<file2>" \-\-merge_blktrace_file="<output_file>"
.RE
.P
Creating only the merged file can be done by passing the command line argument
\fBmerge-blktrace-only\fR.
.P
Scaling traces can be done to see the relative impact of any particular trace
being slowed down or sped up. \fBmerge_blktrace_scalars\fR takes in a colon
separated list of percentage scalars. It is index paired with the files passed
to \fBread_iolog\fR.
.P
With scaling, it may be desirable to match the running time of all traces.
This can be done with \fBmerge_blktrace_iters\fR. It is index paired with
\fBread_iolog\fR just like \fBmerge_blktrace_scalars\fR.
.P
In an example, given two traces, A and B, each 60s long. If we want to see
the impact of trace A issuing IOs twice as fast and repeat trace A over the
runtime of trace B, the following can be done:
.RS
.P
$ fio \-\-read_iolog="<trace_a>:"<trace_b>" \-\-merge_blktrace_file"<output_file>" \-\-merge_blktrace_scalars="50:100" \-\-merge_blktrace_iters="2:1"
.RE
.P
This runs trace A at 2x the speed twice for approximately the same runtime as
a single run of trace B.
.SH CPU IDLENESS PROFILING
In some cases, we want to understand CPU overhead in a test. For example, we
test patches for the specific goodness of whether they reduce CPU usage.
Fio implements a balloon approach to create a thread per CPU that runs at idle
priority, meaning that it only runs when nobody else needs the cpu.
By measuring the amount of work completed by the thread, idleness of each CPU
can be derived accordingly.
.P
An unit work is defined as touching a full page of unsigned characters. Mean and
standard deviation of time to complete an unit work is reported in "unit work"
section. Options can be chosen to report detailed percpu idleness or overall
system idleness by aggregating percpu stats.
.SH VERIFICATION AND TRIGGERS
Fio is usually run in one of two ways, when data verification is done. The first
is a normal write job of some sort with verify enabled. When the write phase has
completed, fio switches to reads and verifies everything it wrote. The second
model is running just the write phase, and then later on running the same job
(but with reads instead of writes) to repeat the same I/O patterns and verify
the contents. Both of these methods depend on the write phase being completed,
as fio otherwise has no idea how much data was written.
.P
With verification triggers, fio supports dumping the current write state to
local files. Then a subsequent read verify workload can load this state and know
exactly where to stop. This is useful for testing cases where power is cut to a
server in a managed fashion, for instance.
.P
A verification trigger consists of two things:
.RS
.P
1) Storing the write state of each job.
.P
2) Executing a trigger command.
.RE
.P
The write state is relatively small, on the order of hundreds of bytes to single
kilobytes. It contains information on the number of completions done, the last X
completions, etc.
.P
A trigger is invoked either through creation ('touch') of a specified file in
the system, or through a timeout setting. If fio is run with
`\-\-trigger\-file=/tmp/trigger\-file', then it will continually
check for the existence of `/tmp/trigger\-file'. When it sees this file, it
will fire off the trigger (thus saving state, and executing the trigger
command).
.P
For client/server runs, there's both a local and remote trigger. If fio is
running as a server backend, it will send the job states back to the client for
safe storage, then execute the remote trigger, if specified. If a local trigger
is specified, the server will still send back the write state, but the client
will then execute the trigger.
.P
.B Verification trigger example
.RS
Let's say we want to run a powercut test on the remote Linux machine 'server'.
Our write workload is in `write\-test.fio'. We want to cut power to 'server' at
some point during the run, and we'll run this test from the safety or our local
machine, 'localbox'. On the server, we'll start the fio backend normally:
.RS
.P
server# fio \-\-server
.RE
.P
and on the client, we'll fire off the workload:
.RS
.P
localbox$ fio \-\-client=server \-\-trigger\-file=/tmp/my\-trigger \-\-trigger\-remote="bash \-c "echo b > /proc/sysrq\-triger""
.RE
.P
We set `/tmp/my\-trigger' as the trigger file, and we tell fio to execute:
.RS
.P
echo b > /proc/sysrq\-trigger
.RE
.P
on the server once it has received the trigger and sent us the write state. This
will work, but it's not really cutting power to the server, it's merely
abruptly rebooting it. If we have a remote way of cutting power to the server
through IPMI or similar, we could do that through a local trigger command
instead. Let's assume we have a script that does IPMI reboot of a given hostname,
ipmi\-reboot. On localbox, we could then have run fio with a local trigger
instead:
.RS
.P
localbox$ fio \-\-client=server \-\-trigger\-file=/tmp/my\-trigger \-\-trigger="ipmi\-reboot server"
.RE
.P
For this case, fio would wait for the server to send us the write state, then
execute `ipmi\-reboot server' when that happened.
.RE
.P
.B Loading verify state
.RS
To load stored write state, a read verification job file must contain the
\fBverify_state_load\fR option. If that is set, fio will load the previously
stored state. For a local fio run this is done by loading the files directly,
and on a client/server run, the server backend will ask the client to send the
files over and load them from there.
.RE
.SH LOG FILE FORMATS
Fio supports a variety of log file formats, for logging latencies, bandwidth,
and IOPS. The logs share a common format, which looks like this:
.RS
.P
time (msec), value, data direction, block size (bytes), offset (bytes),
command priority, issue time (nsec)
.RE
.P
`Time' for the log entry is always in milliseconds. The `value' logged depends
on the type of log, it will be one of the following:
.RS
.TP
.B Latency log
Value is latency in nsecs
.TP
.B Bandwidth log
Value is in KiB/sec
.TP
.B IOPS log
Value is IOPS
.RE
.P
`Data direction' is one of the following:
.RS
.TP
.B 0
I/O is a READ
.TP
.B 1
I/O is a WRITE
.TP
.B 2
I/O is a TRIM
.RE
.P
The entry's `block size' is always in bytes. The `offset' is the position in bytes
from the start of the file for that particular I/O. The logging of the offset can be
toggled with \fBlog_offset\fR.
.P
If \fBlog_prio\fR is not set, the entry's `Command priority` is 1 for an IO executed
with the highest RT priority class (\fBprioclass\fR=1 or \fBcmdprio_class\fR=1) and 0
otherwise. This is controlled by the \fBprioclass\fR option and the ioengine specific
\fBcmdprio_percentage\fR \fBcmdprio_class\fR options. If \fBlog_prio\fR is set, the
entry's `Command priority` is the priority set for the IO, as a 16-bits hexadecimal
number with the lowest 13 bits indicating the priority value (\fBprio\fR and
\fBcmdprio\fR options) and the highest 3 bits indicating the IO priority class
(\fBprioclass\fR and \fBcmdprio_class\fR options).
.P
The entry's `issue time` is the command issue time in nanoseconds. The logging
of the issue time can be toggled with \fBlog_issue_time\fR. This field has valid
values in completion latency log file (clat), or submit latency log file (slat).
The field has value 0 in other log files.
.P
Fio defaults to logging every individual I/O but when windowed logging is set
through \fBlog_avg_msec\fR, either the average (by default), the maximum
(\fBlog_window_value\fR is set to max) `value' seen over the specified period of
time, or both the average `value' and maximum `value1' (\fBlog_window_value\fR is
set to both) is recorded. The log file format when both the values are reported
takes this form:
.RS
.P
time (msec), value, value1, data direction, block size (bytes), offset (bytes),
command priority, issue time (nsec)
.RE
.P
Each `data direction' seen within the window period will aggregate its values
in a separate row. Further, when using windowed logging the `block size',
`offset' and `issue time` entries will always contain 0.
.SH CLIENT / SERVER
Normally fio is invoked as a stand-alone application on the machine where the
I/O workload should be generated. However, the backend and frontend of fio can
be run separately i.e., the fio server can generate an I/O workload on the "Device
Under Test" while being controlled by a client on another machine.
.P
Start the server on the machine which has access to the storage DUT:
.RS
.P
$ fio \-\-server=args
.RE
.P
where `args' defines what fio listens to. The arguments are of the form
`type,hostname' or `IP,port'. `type' is either `ip' (or ip4) for TCP/IP
v4, `ip6' for TCP/IP v6, or `sock' for a local unix domain socket.
`hostname' is either a hostname or IP address, and `port' is the port to listen
to (only valid for TCP/IP, not a local socket). Some examples:
.RS
.TP
1) \fBfio \-\-server\fR
Start a fio server, listening on all interfaces on the default port (8765).
.TP
2) \fBfio \-\-server=ip:hostname,4444\fR
Start a fio server, listening on IP belonging to hostname and on port 4444.
.TP
3) \fBfio \-\-server=ip6:::1,4444\fR
Start a fio server, listening on IPv6 localhost ::1 and on port 4444.
.TP
4) \fBfio \-\-server=,4444\fR
Start a fio server, listening on all interfaces on port 4444.
.TP
5) \fBfio \-\-server=1.2.3.4\fR
Start a fio server, listening on IP 1.2.3.4 on the default port.
.TP
6) \fBfio \-\-server=sock:/tmp/fio.sock\fR
Start a fio server, listening on the local socket `/tmp/fio.sock'.
.RE
.P
Once a server is running, a "client" can connect to the fio server with:
.RS
.P
$ fio <local\-args> \-\-client=<server> <remote\-args> <job file(s)>
.RE
.P
where `local\-args' are arguments for the client where it is running, `server'
is the connect string, and `remote\-args' and `job file(s)' are sent to the
server. The `server' string follows the same format as it does on the server
side, to allow IP/hostname/socket and port strings.
.P
Note that all job options must be defined in job files when running fio as a
client. Any job options specified in `remote\-args' will be ignored.
.P
Fio can connect to multiple servers this way:
.RS
.P
$ fio \-\-client=<server1> <job file(s)> \-\-client=<server2> <job file(s)>
.RE
.P
If the job file is located on the fio server, then you can tell the server to
load a local file as well. This is done by using \fB\-\-remote\-config\fR:
.RS
.P
$ fio \-\-client=server \-\-remote\-config /path/to/file.fio
.RE
.P
Then fio will open this local (to the server) job file instead of being passed
one from the client.
.P
If you have many servers (example: 100 VMs/containers), you can input a pathname
of a file containing host IPs/names as the parameter value for the
\fB\-\-client\fR option. For example, here is an example `host.list'
file containing 2 hostnames:
.RS
.P
.PD 0
host1.your.dns.domain
.P
host2.your.dns.domain
.PD
.RE
.P
The fio command would then be:
.RS
.P
$ fio \-\-client=host.list <job file(s)>
.RE
.P
In this mode, you cannot input server-specific parameters or job files \-\- all
servers receive the same job file.
.P
In order to let `fio \-\-client' runs use a shared filesystem from multiple
hosts, `fio \-\-client' now prepends the IP address of the server to the
filename. For example, if fio is using the directory `/mnt/nfs/fio' and is
writing filename `fileio.tmp', with a \fB\-\-client\fR `hostfile'
containing two hostnames `h1' and `h2' with IP addresses 192.168.10.120 and
192.168.10.121, then fio will create two files:
.RS
.P
.PD 0
/mnt/nfs/fio/192.168.10.120.fileio.tmp
.P
/mnt/nfs/fio/192.168.10.121.fileio.tmp
.PD
.RE
.P
This behavior can be disabled by the \fBunique_filename\fR option.
.P
Terse output in client/server mode will differ slightly from what is produced
when fio is run in stand-alone mode. See the terse output section for details.
.P
Also, if one fio invocation runs workloads on multiple servers, fio will
provide at the end an aggregate summary report for all workloads. This
aggregate summary report assumes that options affecting reporting like
\fBunified_rw_reporting\fR and \fBpercentile_list\fR are identical across all
the jobs summarized. Having different values for these options is an
unsupported configuration.
.SH AUTHORS
.B fio
was written by Jens Axboe <axboe@kernel.dk>.
.br
This man page was written by Aaron Carroll <aaronc@cse.unsw.edu.au> based
on documentation by Jens Axboe.
.br
This man page was rewritten by Tomohiro Kusumi <tkusumi@tuxera.com> based
on documentation by Jens Axboe.
.SH "REPORTING BUGS"
Report bugs to the \fBfio\fR mailing list <fio@vger.kernel.org>.
.br
See \fBREPORTING\-BUGS\fR.
.P
\fBREPORTING\-BUGS\fR: \fIhttp://git.kernel.dk/cgit/fio/plain/REPORTING\-BUGS\fR
.SH "SEE ALSO"
For further documentation see \fBHOWTO\fR and \fBREADME\fR.
.br
Sample jobfiles are available in the `examples/' directory.
.br
These are typically located under `/usr/share/doc/fio'.
.P
\fBHOWTO\fR: \fIhttp://git.kernel.dk/cgit/fio/plain/HOWTO\fR
.br
\fBREADME\fR: \fIhttp://git.kernel.dk/cgit/fio/plain/README\fR
