#!/bin/sh
#
# Fio configure script. Heavily influenced by the manual qemu configure
# script. Sad this this is easier than autoconf and enemies.
#

# set temporary file name
if test ! -z "$TMPDIR" ; then
    TMPDIR1="${TMPDIR}"
elif test ! -z "$TEMPDIR" ; then
    TMPDIR1="${TEMPDIR}"
else
    TMPDIR1="/tmp"
fi

TMPC="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.c"
TMPO="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.o"
TMPE="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.exe"

# NB: do not call "exit" in the trap handler; this is buggy with some shells;
# see <1285349658-3122-1-git-send-email-loic.minier@linaro.org>
trap "rm -f $TMPC $TMPO $TMPE" EXIT INT QUIT TERM

rm -rf config.log

config_host_mak="config-host.mak"
config_host_h="config-host.h"

rm -rf $config_host_mak
rm -rf $config_host_h

fatal() {
  echo $@
  echo "Configure failed, check config.log and/or the above output"
  rm -rf $config_host_mak
  rm -rf $config_host_h
  exit 1
}

# Default CFLAGS
CFLAGS="-D_GNU_SOURCE -include config-host.h"
BUILD_CFLAGS=""

# Print a helpful header at the top of config.log
echo "# FIO configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

# Print configure header at the top of $config_host_h
echo "/*" > $config_host_h
echo " * Automatically generated by configure - do not modify" >> $config_host_h
printf " * Configured with:" >> $config_host_h
printf " * '%s'" "$0" "$@" >> $config_host_h
echo "" >> $config_host_h
echo " */" >> $config_host_h

do_cc() {
    # Run the compiler, capturing its output to the log.
    echo $cc "$@" >> config.log
    $cc "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $cc -Werror "$@" >> config.log
    $cc -Werror "$@" >> config.log 2>&1 && return $?
    echo "ERROR: configure test passed without -Werror but failed with -Werror."
    echo "This is probably a bug in the configure script. The failing command"
    echo "will be at the bottom of config.log."
    fatal "You can run configure with --disable-werror to bypass this check."
}

compile_object() {
  do_cc $CFLAGS -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2 $LIBS"
  echo "Compiling test case $3" >> config.log
  do_cc $CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags
}

feature_not_found() {
  feature=$1
  packages=$2

  echo "ERROR"
  echo "ERROR: User requested feature $feature"
  if test ! -z "$packages" ; then
    echo "ERROR: That feature needs $packages installed"
  fi
  echo "ERROR: configure was not able to find it"
  fatal "ERROR"
}

has() {
  type "$1" >/dev/null 2>&1
}

check_define() {
  cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void)
{
  return 0;
}
EOF
  compile_object
}

output_sym() {
  echo "$1=y" >> $config_host_mak
  echo "#define $1" >> $config_host_h
}

targetos=""
cpu=""

# default options
show_help="no"
exit_val=0
gfio="no"

# parse options
for opt do
  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
  case "$opt" in
  --cpu=*) cpu="$optarg"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --extra-cflags=*) CFLAGS="$CFLAGS $optarg"
  ;;
  --build-32bit-win) build_32bit_win="yes"
  ;;
  --enable-gfio)
  gfio="yes"
  ;;
  --disable-numa) disable_numa="yes"
  ;;
  --help)
    show_help="yes"
    ;;
  *)
  echo "Bad option $opt"
  show_help="yes"
  exit_val=1
  esac
done

if test "$show_help" = "yes" ; then
  echo "--cpu=                 Specify target CPU if auto-detect fails"
  echo "--cc=                  Specify compiler to use"
  echo "--extra-cflags=        Specify extra CFLAGS to pass to compiler"
  echo "--build-32bit-win      Enable 32-bit build on Windows"
  echo "--enable-gfio          Enable building of gtk gfio"
  echo "--disable-numa         Disable libnuma even if found"
  exit $exit_val
fi

cross_prefix=${cross_prefix-${CROSS_COMPILE}}
cc="${CC-${cross_prefix}gcc}"

if check_define __ANDROID__ ; then
  targetos="Android"
elif check_define __linux__ ; then
  targetos="Linux"
elif check_define __OpenBSD__ ; then
  targetos='OpenBSD'
elif check_define __sun__ ; then
  targetos='SunOS'
  CFLAGS="$CFLAGS -D_REENTRANT"
elif check_define _WIN32 ; then
  targetos='CYGWIN'
else
  targetos=`uname -s`
fi

echo "# Automatically generated by configure - do not modify" > $config_host_mak
printf "# Configured with:" >> $config_host_mak
printf " '%s'" "$0" "$@" >> $config_host_mak
echo >> $config_host_mak
echo "CONFIG_TARGET_OS=$targetos" >> $config_host_mak

# Some host OSes need non-standard checks for which CPU to use.
# Note that these checks are broken for cross-compilation: if you're
# cross-compiling to one of these OSes then you'll need to specify
# the correct CPU with the --cpu option.
case $targetos in
Darwin)
  # on Leopard most of the system is 32-bit, so we have to ask the kernel if
  # we can run 64-bit userspace code.
  # If the user didn't specify a CPU explicitly and the kernel says this is
  # 64 bit hw, then assume x86_64. Otherwise fall through to the usual
  # detection code.
  if test -z "$cpu" && test "$(sysctl -n hw.optional.x86_64)" = "1"; then
    cpu="x86_64"
  fi
  ;;
SunOS)
  # `uname -m` returns i86pc even on an x86_64 box, so default based on isainfo
  if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
    cpu="x86_64"
  fi
  LIBS="-lnsl -lsocket"
  ;;
CYGWIN*)
  echo "Forcing known good options on Windows"
  if test -z "$CC" ; then
    if test ! -z "$build_32bit_win" && test "$build_32bit_win" = "yes"; then
      CC="i686-w64-mingw32-gcc"
    else
      CC="x86_64-w64-mingw32-gcc"
    fi
  fi
  output_sym "CONFIG_LITTLE_ENDIAN"
  if test ! -z "$build_32bit_win" && test "$build_32bit_win" = "yes"; then
    output_sym "CONFIG_32BIT"
  else
    output_sym "CONFIG_64BIT_LLP64"
  fi
  output_sym "CONFIG_FADVISE"
  output_sym "CONFIG_SOCKLEN_T"
  output_sym "CONFIG_FADVISE"
  output_sym "CONFIG_SFAA"
  output_sym "CONFIG_RUSAGE_THREAD"
  output_sym "CONFIG_WINDOWSAIO"
  output_sym "CONFIG_FDATASYNC"
  output_sym "CONFIG_CLOCK_MONOTONIC"
  output_sym "CONFIG_GETTIMEOFDAY"
  output_sym "CONFIG_CLOCK_GETTIME"
  output_sym "CONFIG_SCHED_IDLE"
  output_sym "CONFIG_TCP_NODELAY"
  output_sym "CONFIG_TLS_THREAD"
  output_sym "CONFIG_IPV6"
  echo "CC=$CC" >> $config_host_mak
  echo "BUILD_CFLAGS=$CFLAGS -include config-host.h -D_GNU_SOURCE" >> $config_host_mak
  exit 0
  ;;
esac

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  cpu="x86_64"
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    cpu="ppc64"
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __ia64__ ; then
  cpu="ia64"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __hppa__ ; then
  cpu="hppa"
else
  cpu=`uname -m`
fi

# Normalise host CPU name and set ARCH.
case "$cpu" in
  ia64|ppc|ppc64|s390|s390x|sparc64)
    cpu="$cpu"
  ;;
  i386|i486|i586|i686|i86pc|BePC)
    cpu="i386"
  ;;
  x86_64|amd64)
    cpu="x86_64"
  ;;
  armv*b|armv*l|arm)
    cpu="arm"
  ;;
  hppa|parisc|parisc64)
    cpu="hppa"
  ;;
  mips*)
    cpu="mips"
  ;;
  sparc|sun4[cdmuv])
    cpu="sparc"
  ;;
  *)
  echo "Unknown CPU"
  ;;
esac

if test -z "$CC" ; then
  if test "$targetos" = "FreeBSD"; then
    if has clang; then
      CC=clang
    else
      CC=gcc
    fi
  fi
fi

cc="${CC-${cross_prefix}gcc}"

##########################################
# check cross compile

cross_compile="no"
cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
if compile_prog "" "" "cross"; then
  $TMPE 2>/dev/null || cross_compile="yes"
else
  fatal "compile test failed"
fi

##########################################
# check endianness
bigendian="no"
if test "$cross_compile" = "no" ; then
  cat > $TMPC <<EOF
#include <inttypes.h>
int main(void)
{
  volatile uint32_t i=0x01234567;
  return (*((uint8_t*)(&i))) == 0x67;
}
EOF
  if compile_prog "" "" "endian"; then
    $TMPE && bigendian="yes"
  fi
else
  # If we're cross compiling, try our best to work it out and rely on the
  # run-time check to fail if we get it wrong.
  cat > $TMPC <<EOF
#include <endian.h>
int main(void)
{
#if __BYTE_ORDER != __BIG_ENDIAN
# error "Unknown endianness"
#endif
}
EOF
  compile_prog "" "" "endian" && bigendian="yes"
  check_define "__ARMEB__" && bigendian="yes"
  check_define "__MIPSEB__" && bigendian="yes"
fi


echo "Operating system              $targetos"
echo "CPU                           $cpu"
echo "Big endian                    $bigendian"
echo "Compiler                      $cc"
echo "Cross compile                 $cross_compile"
echo

##########################################
# check for wordsize
wordsize="0"
cat > $TMPC <<EOF
#include <limits.h>
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
int main(void)
{
  BUILD_BUG_ON(sizeof(long)*CHAR_BIT != WORDSIZE);
  return 0;
}
EOF
if compile_prog "-DWORDSIZE=32" "" "wordsize"; then
  wordsize="32"
elif compile_prog "-DWORDSIZE=64" "" "wordsize"; then
  wordsize="64"
else
  fatal "Unknown wordsize"
fi
echo "Wordsize                      $wordsize"

##########################################
# zlib probe
zlib="no"
cat > $TMPC <<EOF
#include <zlib.h>
int main(void)
{
  z_stream stream;
  if (inflateInit(&stream) != Z_OK)
    return 1;
  return 0;
}
EOF
if compile_prog "" "-lz" "zlib" ; then
  zlib=yes
  LIBS="-lz $LIBS"
fi
echo "zlib                          $zlib"

##########################################
# linux-aio probe
libaio="no"
cat > $TMPC <<EOF
#include <libaio.h>
#include <stddef.h>
int main(void)
{
  io_setup(0, NULL);
  return 0;
}
EOF
if compile_prog "" "-laio" "libaio" ; then
  libaio=yes
  LIBS="-laio $LIBS"
else
  if test "$libaio" = "yes" ; then
    feature_not_found "linux AIO" "libaio-dev or libaio-devel"
  fi
  libaio=no
fi
echo "Linux AIO support             $libaio"

##########################################
# posix aio probe
posix_aio="no"
posix_aio_lrt="no"
cat > $TMPC <<EOF
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  aio_read(&cb);
  return 0;
}
EOF
if compile_prog "" "" "posixaio" ; then
  posix_aio="yes"
elif compile_prog "" "-lrt" "posixaio"; then
  posix_aio="yes"
  posix_aio_lrt="yes"
  LIBS="-lrt $LIBS"
fi
echo "POSIX AIO support             $posix_aio"
echo "POSIX AIO support needs -lrt  $posix_aio_lrt"

##########################################
# posix aio fsync probe
posix_aio_fsync="no"
if test "$posix_aio" = "yes" ; then
  cat > $TMPC <<EOF
#include <fcntl.h>
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  return aio_fsync(O_SYNC, &cb);
  return 0;
}
EOF
  if compile_prog "" "$LIBS" "posix_aio_fsync" ; then
    posix_aio_fsync=yes
  fi
fi
echo "POSIX AIO fsync               $posix_aio_fsync"

##########################################
# solaris aio probe
solaris_aio="no"
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/asynch.h>
#include <unistd.h>
int main(void)
{
  aio_result_t res;
  return aioread(0, NULL, 0, 0, SEEK_SET, &res);
  return 0;
}
EOF
if compile_prog "" "-laio" "solarisaio" ; then
  solaris_aio=yes
  LIBS="-laio $LIBS"
fi
echo "Solaris AIO support           $solaris_aio"

##########################################
# __sync_fetch_and_and test
sfaa="no"
cat > $TMPC << EOF
static int sfaa(int *ptr)
{
  return __sync_fetch_and_add(ptr, 0);
}

int main(int argc, char **argv)
{
  int val = 42;
  sfaa(&val);
  return val;
}
EOF
if compile_prog "" "" "__sync_fetch_and_add()" ; then
    sfaa="yes"
fi
echo "__sync_fetch_and_add          $sfaa"

##########################################
# libverbs probe
libverbs="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <infiniband/arch.h>
int main(int argc, char **argv)
{
  struct ibv_pd *pd = ibv_alloc_pd(NULL);
  return 0;
}
EOF
if compile_prog "" "-libverbs" "libverbs" ; then
    libverbs="yes"
    LIBS="-libverbs $LIBS"
fi
echo "libverbs                      $libverbs"

##########################################
# rdmacm probe
rdmacm="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <rdma/rdma_cma.h>
int main(int argc, char **argv)
{
  rdma_destroy_qp(NULL);
  return 0;
}
EOF
if compile_prog "" "-lrdmacm" "rdma"; then
    rdmacm="yes"
    LIBS="-lrdmacm $LIBS"
fi
echo "rdmacm                        $rdmacm"

##########################################
# Linux fallocate probe
linux_fallocate="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
#include <linux/falloc.h>
int main(int argc, char **argv)
{
  int r = fallocate(0, FALLOC_FL_KEEP_SIZE, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "linux_fallocate"; then
    linux_fallocate="yes"
fi
echo "Linux fallocate               $linux_fallocate"

##########################################
# POSIX fadvise probe
posix_fadvise="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fadvise(0, 0, 0, POSIX_FADV_NORMAL);
  return r;
}
EOF
if compile_prog "" "" "posix_fadvise"; then
    posix_fadvise="yes"
fi
echo "POSIX fadvise                 $posix_fadvise"

##########################################
# POSIX fallocate probe
posix_fallocate="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fallocate(0, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "posix_fallocate"; then
    posix_fallocate="yes"
fi
echo "POSIX fallocate               $posix_fallocate"

##########################################
# sched_set/getaffinity 2 or 3 argument test
linux_2arg_affinity="no"
linux_3arg_affinity="no"
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, sizeof(mask), &mask);
}
EOF
if compile_prog "" "" "sched_setaffinity(,,)"; then
  linux_3arg_affinity="yes"
else
  cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, &mask);
}
EOF
  if compile_prog "" "" "sched_setaffinity(,)"; then
    linux_2arg_affinity="yes"
  fi
fi
echo "sched_setaffinity(3 arg)      $linux_3arg_affinity"
echo "sched_setaffinity(2 arg)      $linux_2arg_affinity"

##########################################
# clock_gettime probe
clock_gettime="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(0, NULL);
}
EOF
if compile_prog "" "" "clock_gettime"; then
    clock_gettime="yes"
elif compile_prog "" "-lrt" "clock_gettime"; then
    clock_gettime="yes"
    LIBS="-lrt $LIBS"
fi
echo "clock_gettime                 $clock_gettime"

##########################################
# CLOCK_MONOTONIC probe
clock_monotonic="no"
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic"; then
      clock_monotonic="yes"
  fi
fi
echo "CLOCK_MONOTONIC               $clock_monotonic"

##########################################
# CLOCK_MONOTONIC_PRECISE probe
clock_monotonic_precise="no"
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC_PRECISE, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic precise"; then
      clock_monotonic_precise="yes"
  fi
fi
echo "CLOCK_MONOTONIC_PRECISE       $clock_monotonic_precise"

##########################################
# gettimeofday() probe
gettimeofday="no"
cat > $TMPC << EOF
#include <sys/time.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct timeval tv;
  return gettimeofday(&tv, NULL);
}
EOF
if compile_prog "" "" "gettimeofday"; then
    gettimeofday="yes"
fi
echo "gettimeofday                  $gettimeofday"

##########################################
# fdatasync() probe
fdatasync="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
int main(int argc, char **argv)
{
  return fdatasync(0);
}
EOF
if compile_prog "" "" "fdatasync"; then
  fdatasync="yes"
fi
echo "fdatasync                     $fdatasync"

##########################################
# sync_file_range() probe
sync_file_range="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/fs.h>
int main(int argc, char **argv)
{
  unsigned int flags = SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE |
			SYNC_FILE_RANGE_WAIT_AFTER;
  return sync_file_range(0, 0, 0, flags);
}
EOF
if compile_prog "" "" "sync_file_range"; then
  sync_file_range="yes"
fi
echo "sync_file_range               $sync_file_range"

##########################################
# ext4 move extent probe
ext4_me="no"
cat > $TMPC << EOF
#include <fcntl.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
  struct move_extent me;
  return ioctl(0, EXT4_IOC_MOVE_EXT, &me);
}
EOF
if compile_prog "" "" "ext4 move extent" ; then
  ext4_me="yes"
elif test $targetos = "Linux" ; then
  # On Linux, just default to it on and let it error at runtime if we really
  # don't have it. None of my updated systems have it defined, but it does
  # work. Takes a while to bubble back.
  ext4_me="yes"
fi
echo "EXT4 move extent              $ext4_me"

##########################################
# splice probe
linux_splice="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  return splice(0, NULL, 0, NULL, 0, SPLICE_F_NONBLOCK);
}
EOF
if compile_prog "" "" "linux splice"; then
  linux_splice="yes"
fi
echo "Linux splice(2)               $linux_splice"

##########################################
# GUASI probe
guasi="no"
cat > $TMPC << EOF
#include <guasi.h>
#include <guasi_syscalls.h>
int main(int argc, char **argv)
{
  guasi_t ctx = guasi_create(0, 0, 0);
  return 0;
}
EOF
if compile_prog "" "" "guasi"; then
  guasi="yes"
fi
echo "GUASI                         $guasi"

##########################################
# fusion-aw probe
fusion_aw="no"
cat > $TMPC << EOF
#include <nvm/nvm_primitives.h>
int main(int argc, char **argv)
{
  nvm_version_t ver_info;
  nvm_handle_t handle;

  handle = nvm_get_handle(0, &ver_info);
  return nvm_atomic_write(handle, 0, 0, 0);
}
EOF
if compile_prog "" "-L/usr/lib/fio -L/usr/lib/nvm -lnvm-primitives -lvsl -ldl" "fusion-aw"; then
  LIBS="-L/usr/lib/fio -L/usr/lib/nvm -lnvm-primitives -lvsl -ldl $LIBS"
  fusion_aw="yes"
fi
echo "Fusion-io atomic engine       $fusion_aw"

##########################################
# libnuma probe
libnuma="no"
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  return numa_available();
}
EOF
if test "$disable_numa" != "yes"  && compile_prog "" "-lnuma" "libnuma"; then
  libnuma="yes"
  LIBS="-lnuma $LIBS"
fi
echo "libnuma                       $libnuma"

##########################################
# libnuma 2.x version API
if test "$libnuma" = "yes" ; then
libnuma_v2="no"
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  struct bitmask *mask = numa_parse_nodestring(NULL);
  return 0;
}
EOF
if compile_prog "" "" "libnuma api"; then
  libnuma_v2="yes"
fi
echo "libnuma v2                    $libnuma_v2"
fi

##########################################
# strsep() probe
strsep="no"
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  strsep(NULL, NULL);
  return 0;
}
EOF
if compile_prog "" "" "strsep"; then
  strsep="yes"
fi
echo "strsep                        $strsep"

##########################################
# strcasestr() probe
strcasestr="no"
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  return strcasestr(argv[0], argv[1]) != NULL;
}
EOF
if compile_prog "" "" "strcasestr"; then
  strcasestr="yes"
fi
echo "strcasestr                    $strcasestr"

##########################################
# getopt_long_only() probe
getopt_long_only="no"
cat > $TMPC << EOF
#include <unistd.h>
#include <stdio.h>
#include <getopt.h>
int main(int argc, char **argv)
{
  int c = getopt_long_only(argc, argv, NULL, NULL, NULL);
  return c;
}
EOF
if compile_prog "" "" "getopt_long_only"; then
  getopt_long_only="yes"
fi
echo "getopt_long_only()            $getopt_long_only"

##########################################
# inet_aton() probe
inet_aton="no"
cat > $TMPC << EOF
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct in_addr in;
  return inet_aton(NULL, &in);
}
EOF
if compile_prog "" "" "inet_aton"; then
  inet_aton="yes"
fi
echo "inet_aton                     $inet_aton"

##########################################
# socklen_t probe
socklen_t="no"
cat > $TMPC << EOF
#include <sys/socket.h>
int main(int argc, char **argv)
{
  socklen_t len = 0;
  return len;
}
EOF
if compile_prog "" "" "socklen_t"; then
  socklen_t="yes"
fi
echo "socklen_t                     $socklen_t"

##########################################
# Whether or not __thread is supported for TLS
tls_thread="no"
cat > $TMPC << EOF
#include <stdio.h>
static __thread int ret;
int main(int argc, char **argv)
{
  return ret;
}
EOF
if compile_prog "" "" "__thread"; then
  tls_thread="yes"
fi
echo "__thread                      $tls_thread"

##########################################
# Check if we have required gtk/glib support for gfio
if test "$gfio" = "yes" ; then
  cat > $TMPC << EOF
#include <glib.h>
#include <cairo.h>
#include <gtk/gtk.h>
int main(void)
{
  gdk_threads_enter();
  gdk_threads_leave();

  printf("%d", GTK_CHECK_VERSION(2, 18, 0));
}
EOF
GTK_CFLAGS=$(pkg-config --cflags gtk+-2.0 gthread-2.0)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
GTK_LIBS=$(pkg-config --libs gtk+-2.0 gthread-2.0)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
if compile_prog "$GTK_CFLAGS" "$GTK_LIBS" "gfio" ; then
  r=$($TMPE)
  if test "$r" != "0" ; then
    gfio="yes"
    LIBS="$LIBS $GTK_LIBS"
    CFLAGS="$CFLAGS $GTK_CFLAGS"
  else
    echo "GTK found, but need version 2.18 or higher"
    gfio="no"
  fi
else
  echo "Please install gtk and gdk libraries"
  gfio="no"
fi
fi

echo "gtk 2.18 or higher            $gfio"

# Check whether we have getrusage(RUSAGE_THREAD)
rusage_thread="no"
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rusage ru;
  getrusage(RUSAGE_THREAD, &ru);
  return 0;
}
EOF
if compile_prog "" "" "RUSAGE_THREAD"; then
  rusage_thread="yes"
fi
echo "RUSAGE_THREAD                 $rusage_thread"

##########################################
# Check whether we have SCHED_IDLE
sched_idle="no"
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  struct sched_param p;
  return sched_setscheduler(0, SCHED_IDLE, &p);
}
EOF
if compile_prog "" "" "SCHED_IDLE"; then
  sched_idle="yes"
fi
echo "SCHED_IDLE                    $sched_idle"

##########################################
# Check whether we have TCP_NODELAY
tcp_nodelay="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
int main(int argc, char **argv)
{
  return getsockopt(0, 0, TCP_NODELAY, NULL, NULL);
}
EOF
if compile_prog "" "" "TCP_NODELAY"; then
  tcp_nodelay="yes"
fi
echo "TCP_NODELAY                   $tcp_nodelay"

##########################################
# Check whether we have RLIMIT_MEMLOCK
rlimit_memlock="no"
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rlimit rl;
  return getrlimit(RLIMIT_MEMLOCK, &rl);
}
EOF
if compile_prog "" "" "RLIMIT_MEMLOCK"; then
  rlimit_memlock="yes"
fi
echo "RLIMIT_MEMLOCK                $rlimit_memlock"

##########################################
# Check whether we have pwritev/preadv
pwritev="no"
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/uio.h>
int main(int argc, char **argv)
{
  return pwritev(0, NULL, 1, 0) + preadv(0, NULL, 1, 0);
}
EOF
if compile_prog "" "" "pwritev"; then
  pwritev="yes"
fi
echo "pwritev/preadv                $pwritev"

##########################################
# Check whether we have the required functions for ipv6
ipv6="no"
cat > $TMPC << EOF
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct addrinfo hints;
  struct in6_addr addr;
  int ret;

  ret = getaddrinfo(NULL, NULL, &hints, NULL);
  freeaddrinfo(NULL);
  printf("%s\n", gai_strerror(ret));
  addr = in6addr_any;
  return 0;
}
EOF
if compile_prog "" "" "ipv6"; then
  ipv6="yes"
fi
echo "IPv6 helpers                  $ipv6"

##########################################
# check for rbd
rbd="no"
cat > $TMPC << EOF
#include <rbd/librbd.h>

int main(int argc, char **argv)
{

  rados_t cluster;
  rados_ioctx_t io_ctx;
  const char pool[] = "rbd";

  int major, minor, extra;
  rbd_version(&major, &minor, &extra);

  rados_ioctx_create(cluster, pool, &io_ctx);
  return 0;
}
EOF
if compile_prog "" "-lrbd -lrados" "rbd"; then
  LIBS="-lrbd -lrados $LIBS"
  rbd="yes"
fi
echo "Rados Block Device engine     $rbd"

##########################################
# Check whether we have setvbuf
setvbuf="no"
cat > $TMPC << EOF
#include <stdio.h>
int main(int argc, char **argv)
{
  FILE *f = NULL;
  char buf[80];
  setvbuf(f, buf, _IOFBF, sizeof(buf));
  return 0;
}
EOF
if compile_prog "" "" "setvbuf"; then
  setvbuf="yes"
fi
echo "setvbuf                       $setvbuf"

##########################################
# Check if we support stckf on s390
s390_z196_facilities="no"
cat > $TMPC << EOF
#define STFLE_BITS_Z196 45 /* various z196 facilities ... */
int main(int argc, char **argv)
{
    /* We want just 1 double word to be returned.  */
    register unsigned long reg0 asm("0") = 0;
    unsigned long stfle_bits;
    asm volatile(".machine push"        "\n\t"
                 ".machine \"z9-109\""  "\n\t"
                 "stfle %0"             "\n\t"
                 ".machine pop"         "\n"
                 : "=QS" (stfle_bits), "+d" (reg0)
                 : : "cc");

    if ((stfle_bits & (1UL << (63 - STFLE_BITS_Z196))) != 0)
      return 0;
    else
      return -1;
}
EOF
if compile_prog "" "" "s390_z196_facilities"; then
  $TMPE
  if [[ $? -eq 0 ]]; then
  	s390_z196_facilities="yes"
  fi
fi
echo "s390_z196_facilities          $s390_z196_facilities"
#############################################################################

if test "$wordsize" = "64" ; then
  output_sym "CONFIG_64BIT"
elif test "$wordsize" = "32" ; then
  output_sym "CONFIG_32BIT"
else
  fatal "Unknown wordsize!"
fi
if test "$bigendian" = "yes" ; then
  output_sym "CONFIG_BIG_ENDIAN"
else
  output_sym "CONFIG_LITTLE_ENDIAN"
fi
if test "$zlib" = "yes" ; then
  output_sym "CONFIG_ZLIB"
fi
if test "$libaio" = "yes" ; then
  output_sym "CONFIG_LIBAIO"
fi
if test "$posix_aio" = "yes" ; then
  output_sym "CONFIG_POSIXAIO"
fi
if test "$posix_aio_fsync" = "yes" ; then
  output_sym "CONFIG_POSIXAIO_FSYNC"
fi
if test "$linux_fallocate" = "yes" ; then
  output_sym "CONFIG_LINUX_FALLOCATE"
fi
if test "$posix_fallocate" = "yes" ; then
  output_sym "CONFIG_POSIX_FALLOCATE"
fi
if test "$fdatasync" = "yes" ; then
  output_sym "CONFIG_FDATASYNC"
fi
if test "$sync_file_range" = "yes" ; then
  output_sym "CONFIG_SYNC_FILE_RANGE"
fi
if test "$sfaa" = "yes" ; then
  output_sym "CONFIG_SFAA"
fi
if test "$libverbs" = "yes" -a "$rdmacm" = "yes" ; then
  output_sym "CONFIG_RDMA"
fi
if test "$clock_gettime" = "yes" ; then
  output_sym "CONFIG_CLOCK_GETTIME"
fi
if test "$clock_monotonic" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC"
fi
if test "$clock_monotonic_precise" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC_PRECISE"
fi
if test "$gettimeofday" = "yes" ; then
  output_sym "CONFIG_GETTIMEOFDAY"
fi
if test "$posix_fadvise" = "yes" ; then
  output_sym "CONFIG_POSIX_FADVISE"
fi
if test "$linux_3arg_affinity" = "yes" ; then
  output_sym "CONFIG_3ARG_AFFINITY"
elif test "$linux_2arg_affinity" = "yes" ; then
  output_sym "CONFIG_2ARG_AFFINITY"
fi
if test "$strsep" = "yes" ; then
  output_sym "CONFIG_STRSEP"
fi
if test "$strcasestr" = "yes" ; then
  output_sym "CONFIG_STRCASESTR"
fi
if test "$getopt_long_only" = "yes" ; then
  output_sym "CONFIG_GETOPT_LONG_ONLY"
fi
if test "$inet_aton" = "yes" ; then
  output_sym "CONFIG_INET_ATON"
fi
if test "$socklen_t" = "yes" ; then
  output_sym "CONFIG_SOCKLEN_T"
fi
if test "$ext4_me" = "yes" ; then
  output_sym "CONFIG_LINUX_EXT4_MOVE_EXTENT"
fi
if test "$linux_splice" = "yes" ; then
  output_sym "CONFIG_LINUX_SPLICE"
fi
if test "$guasi" = "yes" ; then
  output_sym "CONFIG_GUASI"
fi
if test "$fusion_aw" = "yes" ; then
  output_sym "CONFIG_FUSION_AW"
fi
if test "$libnuma_v2" = "yes" ; then
  output_sym "CONFIG_LIBNUMA"
fi
if test "$solaris_aio" = "yes" ; then
  output_sym "CONFIG_SOLARISAIO"
fi
if test "$tls_thread" = "yes" ; then
  output_sym "CONFIG_TLS_THREAD"
fi
if test "$rusage_thread" = "yes" ; then
  output_sym "CONFIG_RUSAGE_THREAD"
fi
if test "$gfio" = "yes" ; then
  echo "CONFIG_GFIO=y" >> $config_host_mak
fi
if test "$sched_idle" = "yes" ; then
  output_sym "CONFIG_SCHED_IDLE"
fi
if test "$tcp_nodelay" = "yes" ; then
  output_sym "CONFIG_TCP_NODELAY"
fi
if test "$rlimit_memlock" = "yes" ; then
  output_sym "CONFIG_RLIMIT_MEMLOCK"
fi
if test "$pwritev" = "yes" ; then
  output_sym "CONFIG_PWRITEV"
fi
if test "$ipv6" = "yes" ; then
  output_sym "CONFIG_IPV6"
fi
if test "$rbd" = "yes" ; then
  output_sym "CONFIG_RBD"
fi
if test "$setvbuf" = "yes" ; then
  output_sym "CONFIG_SETVBUF"
fi
if test "$s390_z196_facilities" = "yes" ; then
  output_sym "CONFIG_S390_Z196_FACILITIES"
  CFLAGS="$CFLAGS -march=z9-109"
fi

echo "LIBS+=$LIBS" >> $config_host_mak
echo "CFLAGS+=$CFLAGS" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "BUILD_CFLAGS=$BUILD_CFLAGS $CFLAGS" >> $config_host_mak
