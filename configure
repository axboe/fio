#!/bin/sh
#
# Fio configure script. Heavily influenced by the manual qemu configure
# script. Sad this this is easier than autoconf and enemies.
#

# set temporary file name
if test ! -z "$TMPDIR" ; then
    TMPDIR1="${TMPDIR}"
elif test ! -z "$TEMPDIR" ; then
    TMPDIR1="${TEMPDIR}"
else
    TMPDIR1="/tmp"
fi

TMPC="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.c"
TMPO="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.o"
TMPE="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.exe"

# NB: do not call "exit" in the trap handler; this is buggy with some shells;
# see <1285349658-3122-1-git-send-email-loic.minier@linaro.org>
trap "rm -f $TMPC $TMPO $TMPE" EXIT INT QUIT TERM

rm -rf config.log

config_host_mak="config-host.mak"
config_host_h="config-host.h"

rm -rf $config_host_mak
rm -rf $config_host_h

fatal() {
  echo $@
  echo "Configure failed, check config.log and/or the above output"
  rm -rf $config_host_mak
  rm -rf $config_host_h
  exit 1
}

# Default CFLAGS
CFLAGS="-D_GNU_SOURCE -include config-host.h"
BUILD_CFLAGS=""

# Print a helpful header at the top of config.log
echo "# FIO configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

# Print configure header at the top of $config_host_h
echo "/*" > $config_host_h
echo " * Automatically generated by configure - do not modify" >> $config_host_h
printf " * Configured with:" >> $config_host_h
printf " * '%s'" "$0" "$@" >> $config_host_h
echo "" >> $config_host_h
echo " */" >> $config_host_h

do_cc() {
    # Run the compiler, capturing its output to the log.
    echo $cc "$@" >> config.log
    $cc "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $cc -Werror "$@" >> config.log
    $cc -Werror "$@" >> config.log 2>&1 && return $?
    echo "ERROR: configure test passed without -Werror but failed with -Werror."
    echo "This is probably a bug in the configure script. The failing command"
    echo "will be at the bottom of config.log."
    fatal "You can run configure with --disable-werror to bypass this check."
}

compile_object() {
  do_cc $CFLAGS -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2 $LIBS"
  echo "Compiling test case $3" >> config.log
  do_cc $CFLAGS $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags
}

feature_not_found() {
  feature=$1
  packages=$2

  echo "ERROR"
  echo "ERROR: User requested feature $feature"
  if test ! -z "$packages" ; then
    echo "ERROR: That feature needs $packages installed"
  fi
  echo "ERROR: configure was not able to find it"
  fatal "ERROR"
}

has() {
  type "$1" >/dev/null 2>&1
}

check_define() {
  cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void)
{
  return 0;
}
EOF
  compile_object
}

output_sym() {
  echo "$1=y" >> $config_host_mak
  echo "#define $1" >> $config_host_h
}

targetos=""
cpu=""

# default options
show_help="no"
exit_val=0
gfio_check="no"
libhdfs="no"
pmemblk="no"
devdax="no"
disable_lex=""
disable_pmem="no"
prefix=/usr/local

# parse options
for opt do
  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
  case "$opt" in
  --prefix=*) prefix="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  #  esx is cross compiled and cannot be detect through simple uname calls
  --esx)
  esx="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --extra-cflags=*) CFLAGS="$CFLAGS $optarg"
  ;;
  --build-32bit-win) build_32bit_win="yes"
  ;;
  --build-static) build_static="yes"
  ;;
  --enable-gfio) gfio_check="yes"
  ;;
  --disable-numa) disable_numa="yes"
  ;;
  --disable-rdma) disable_rdma="yes"
  ;;
  --disable-rbd) disable_rbd="yes"
  ;;
  --disable-rbd-blkin) disable_rbd_blkin="yes"
  ;;
  --disable-gfapi) disable_gfapi="yes"
  ;;
  --enable-libhdfs) libhdfs="yes"
  ;;
  --disable-lex) disable_lex="yes"
  ;;
  --enable-lex) disable_lex="no"
  ;;
  --disable-shm) no_shm="yes"
  ;;
  --disable-optimizations) disable_opt="yes"
  ;;
  --disable-pmem) disable_pmem="yes"
  ;;
  --enable-cuda) enable_cuda="yes"
  ;;
  --help)
    show_help="yes"
    ;;
  *)
  echo "Bad option $opt"
  show_help="yes"
  exit_val=1
  esac
done

if test "$show_help" = "yes" ; then
  echo "--prefix=               Use this directory as installation prefix"
  echo "--cpu=                  Specify target CPU if auto-detect fails"
  echo "--cc=                   Specify compiler to use"
  echo "--extra-cflags=         Specify extra CFLAGS to pass to compiler"
  echo "--build-32bit-win       Enable 32-bit build on Windows"
  echo "--build-static          Build a static fio"
  echo "--esx                   Configure build options for esx"
  echo "--enable-gfio           Enable building of gtk gfio"
  echo "--disable-numa          Disable libnuma even if found"
  echo "--disable-rdma          Disable RDMA support even if found"
  echo "--disable-gfapi         Disable gfapi"
  echo "--enable-libhdfs        Enable hdfs support"
  echo "--disable-lex           Disable use of lex/yacc for math"
  echo "--disable-pmem          Disable pmem based engines even if found"
  echo "--enable-lex            Enable use of lex/yacc for math"
  echo "--disable-shm           Disable SHM support"
  echo "--disable-optimizations Don't enable compiler optimizations"
  echo "--enable-cuda           Enable GPUDirect RDMA support"
  exit $exit_val
fi

cross_prefix=${cross_prefix-${CROSS_COMPILE}}
cc="${CC-${cross_prefix}gcc}"

if check_define __ANDROID__ ; then
  targetos="Android"
elif check_define __linux__ ; then
  targetos="Linux"
elif check_define __OpenBSD__ ; then
  targetos='OpenBSD'
elif check_define __sun__ ; then
  targetos='SunOS'
  CFLAGS="$CFLAGS -D_REENTRANT"
elif check_define _WIN32 ; then
  targetos='CYGWIN'
else
  targetos=`uname -s`
fi

echo "# Automatically generated by configure - do not modify" > $config_host_mak
printf "# Configured with:" >> $config_host_mak
printf " '%s'" "$0" "$@" >> $config_host_mak
echo >> $config_host_mak
echo "CONFIG_TARGET_OS=$targetos" >> $config_host_mak

if test "$no_shm" = "yes" ; then
  output_sym "CONFIG_NO_SHM"
fi

if test "$disable_opt" = "yes" ; then
  output_sym "CONFIG_FIO_NO_OPT"
fi

# Some host OSes need non-standard checks for which CPU to use.
# Note that these checks are broken for cross-compilation: if you're
# cross-compiling to one of these OSes then you'll need to specify
# the correct CPU with the --cpu option.
case $targetos in
AIX|OpenBSD)
  # Unless explicitly enabled, turn off lex.
  # OpenBSD will hit syntax error when enabled.
  if test -z "$disable_lex" ; then
    disable_lex="yes"
  else
    force_no_lex_o="yes"
  fi
  ;;
Darwin)
  # on Leopard most of the system is 32-bit, so we have to ask the kernel if
  # we can run 64-bit userspace code.
  # If the user didn't specify a CPU explicitly and the kernel says this is
  # 64 bit hw, then assume x86_64. Otherwise fall through to the usual
  # detection code.
  if test -z "$cpu" && test "$(sysctl -n hw.optional.x86_64)" = "1"; then
    cpu="x86_64"
  fi
  # Error at compile time linking of weak/partial symbols if possible...
cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
  if compile_prog "" "-Wl,-no_weak_imports" "disable weak symbols"; then
    echo "Disabling weak symbols"
    LDFLAGS="$LDFLAGS -Wl,-no_weak_imports"
  fi
  ;;
SunOS)
  # `uname -m` returns i86pc even on an x86_64 box, so default based on isainfo
  if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
    cpu="x86_64"
  fi
  LIBS="-lnsl -lsocket"
  ;;
CYGWIN*)
  # We still force some options, so keep this message here.
  echo "Forcing some known good options on Windows"
  if test -z "$CC" ; then
    if test ! -z "$build_32bit_win" && test "$build_32bit_win" = "yes"; then
      CC="i686-w64-mingw32-gcc"
      if test -e "../zlib/contrib/vstudio/vc14/x86/ZlibStatReleaseWithoutAsm/zlibstat.lib"; then
        echo "Building with zlib support"
        output_sym "CONFIG_ZLIB"
        echo "LIBS=../zlib/contrib/vstudio/vc14/x86/ZlibStatReleaseWithoutAsm/zlibstat.lib" >> $config_host_mak
      fi
    else
      CC="x86_64-w64-mingw32-gcc"
      if test -e "../zlib/contrib/vstudio/vc14/x64/ZlibStatReleaseWithoutAsm/zlibstat.lib"; then
        echo "Building with zlib support"
        output_sym "CONFIG_ZLIB"
        echo "LIBS=../zlib/contrib/vstudio/vc14/x64/ZlibStatReleaseWithoutAsm/zlibstat.lib" >> $config_host_mak
      fi
    fi
  fi
  if test ! -z "$build_32bit_win" && test "$build_32bit_win" = "yes"; then
    output_sym "CONFIG_32BIT"
  else
    output_sym "CONFIG_64BIT_LLP64"
  fi
  # We need this to be output_sym'd here because this is Windows specific.
  # The regular configure path never sets this config.
  output_sym "CONFIG_WINDOWSAIO"
  # We now take the regular configuration path without having exit 0 here.
  # Flags below are still necessary mostly for MinGW.
  socklen_t="yes"
  sfaa="yes"
  rusage_thread="yes"
  fdatasync="yes"
  clock_gettime="yes" # clock_monotonic probe has dependency on this
  clock_monotonic="yes"
  gettimeofday="yes"
  sched_idle="yes"
  tcp_nodelay="yes"
  tls_thread="yes"
  static_assert="yes"
  ipv6="yes"
  echo "CC=$CC" >> $config_host_mak
  echo "BUILD_CFLAGS=$CFLAGS -I../zlib -include config-host.h -D_GNU_SOURCE" >> $config_host_mak
  ;;
esac

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  cpu="x86_64"
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    cpu="ppc64"
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __ia64__ ; then
  cpu="ia64"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __aarch64__ ; then
  cpu="aarch64"
elif check_define __hppa__ ; then
  cpu="hppa"
else
  cpu=`uname -m`
fi

# Normalise host CPU name and set ARCH.
case "$cpu" in
  ia64|ppc|ppc64|s390|s390x|sparc64)
    cpu="$cpu"
  ;;
  i386|i486|i586|i686|i86pc|BePC)
    cpu="x86"
  ;;
  x86_64|amd64)
    cpu="x86_64"
  ;;
  armv*b|armv*l|arm)
    cpu="arm"
  ;;
  aarch64)
    cpu="arm64"
  ;;
  hppa|parisc|parisc64)
    cpu="hppa"
  ;;
  mips*)
    cpu="mips"
  ;;
  sparc|sun4[cdmuv])
    cpu="sparc"
  ;;
  *)
  echo "Unknown CPU"
  ;;
esac

if test -z "$CC" ; then
  if test "$targetos" = "FreeBSD"; then
    if has clang; then
      CC=clang
    else
      CC=gcc
    fi
  fi
fi

cc="${CC-${cross_prefix}gcc}"

##########################################
# check cross compile

if test "$cross_compile" != "yes" ; then
  cross_compile="no"
fi
cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
if compile_prog "" "" "cross"; then
  $TMPE 2>/dev/null || cross_compile="yes"
else
  fatal "compile test failed"
fi

##########################################
# check endianness
if test "$bigendian" != "yes" ; then
  bigendian="no"
fi
if test "$cross_compile" = "no" ; then
  cat > $TMPC <<EOF
#include <inttypes.h>
int main(void)
{
  volatile uint32_t i=0x01234567;
  return (*((uint8_t*)(&i))) == 0x67;
}
EOF
  if compile_prog "" "" "endian"; then
    $TMPE && bigendian="yes"
  fi
else
  # If we're cross compiling, try our best to work it out and rely on the
  # run-time check to fail if we get it wrong.
  cat > $TMPC <<EOF
#include <endian.h>
int main(void)
{
#if __BYTE_ORDER != __BIG_ENDIAN
# error "Unknown endianness"
#endif
}
EOF
  compile_prog "" "" "endian" && bigendian="yes"
  check_define "__ARMEB__" && bigendian="yes"
  check_define "__MIPSEB__" && bigendian="yes"
fi


echo "Operating system              $targetos"
echo "CPU                           $cpu"
echo "Big endian                    $bigendian"
echo "Compiler                      $cc"
echo "Cross compile                 $cross_compile"
echo

##########################################
# See if we need to build a static build
if test "$build_static" = "yes" ; then
  CFLAGS="$CFLAGS -ffunction-sections -fdata-sections"
  LDFLAGS="$LDFLAGS -static -Wl,--gc-sections"
else
  build_static="no"
fi
echo "Static build                  $build_static"

##########################################
# check for wordsize
wordsize="0"
cat > $TMPC <<EOF
#include <limits.h>
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
int main(void)
{
  BUILD_BUG_ON(sizeof(long)*CHAR_BIT != WORDSIZE);
  return 0;
}
EOF
if compile_prog "-DWORDSIZE=32" "" "wordsize"; then
  wordsize="32"
elif compile_prog "-DWORDSIZE=64" "" "wordsize"; then
  wordsize="64"
else
  fatal "Unknown wordsize"
fi
echo "Wordsize                      $wordsize"

##########################################
# zlib probe
if test "$zlib" != "yes" ; then
  zlib="no"
fi
cat > $TMPC <<EOF
#include <zlib.h>
int main(void)
{
  z_stream stream;
  if (inflateInit(&stream) != Z_OK)
    return 1;
  return 0;
}
EOF
if compile_prog "" "-lz" "zlib" ; then
  zlib=yes
  LIBS="-lz $LIBS"
fi
echo "zlib                          $zlib"

##########################################
# linux-aio probe
if test "$libaio" != "yes" ; then
  libaio="no"
fi
if test "$esx" != "yes" ; then
  cat > $TMPC <<EOF
#include <libaio.h>
#include <stddef.h>
int main(void)
{
  io_setup(0, NULL);
  return 0;
}
EOF
  if compile_prog "" "-laio" "libaio" ; then
    libaio=yes
    LIBS="-laio $LIBS"
  else
    if test "$libaio" = "yes" ; then
      feature_not_found "linux AIO" "libaio-dev or libaio-devel"
    fi
    libaio=no
  fi
fi
echo "Linux AIO support             $libaio"

##########################################
# posix aio probe
if test "$posix_aio" != "yes" ; then
  posix_aio="no"
fi
if test "$posix_aio_lrt" != "yes" ; then
  posix_aio_lrt="no"
fi
cat > $TMPC <<EOF
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  aio_read(&cb);
  return 0;
}
EOF
if compile_prog "" "" "posixaio" ; then
  posix_aio="yes"
elif compile_prog "" "-lrt" "posixaio"; then
  posix_aio="yes"
  posix_aio_lrt="yes"
  LIBS="-lrt $LIBS"
fi
echo "POSIX AIO support             $posix_aio"
echo "POSIX AIO support needs -lrt  $posix_aio_lrt"

##########################################
# posix aio fsync probe
if test "$posix_aio_fsync" != "yes" ; then
  posix_aio_fsync="no"
fi
if test "$posix_aio" = "yes" ; then
  cat > $TMPC <<EOF
#include <fcntl.h>
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  return aio_fsync(O_SYNC, &cb);
  return 0;
}
EOF
  if compile_prog "" "$LIBS" "posix_aio_fsync" ; then
    posix_aio_fsync=yes
  fi
fi
echo "POSIX AIO fsync               $posix_aio_fsync"

##########################################
# POSIX pshared attribute probe
if test "$posix_pshared" != "yes" ; then
  posix_pshared="no"
fi
cat > $TMPC <<EOF
#include <unistd.h>
int main(void)
{
#if defined(_POSIX_THREAD_PROCESS_SHARED) && ((_POSIX_THREAD_PROCESS_SHARED + 0) > 0)
# if defined(__CYGWIN__)
#  error "_POSIX_THREAD_PROCESS_SHARED is buggy on Cygwin"
# elif defined(__APPLE__)
#  include <AvailabilityMacros.h>
#  include <TargetConditionals.h>
#  if TARGET_OS_MAC && MAC_OS_X_VERSION_MIN_REQUIRED < 1070
#   error "_POSIX_THREAD_PROCESS_SHARED is buggy/unsupported prior to OSX 10.7"
#  endif
# endif
#else
# error "_POSIX_THREAD_PROCESS_SHARED is unsupported"
#endif
  return 0;
}
EOF
if compile_prog "" "$LIBS" "posix_pshared" ; then
  posix_pshared=yes
fi
echo "POSIX pshared support         $posix_pshared"

##########################################
# solaris aio probe
if test "$solaris_aio" != "yes" ; then
  solaris_aio="no"
fi
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/asynch.h>
#include <unistd.h>
int main(void)
{
  aio_result_t res;
  return aioread(0, NULL, 0, 0, SEEK_SET, &res);
  return 0;
}
EOF
if compile_prog "" "-laio" "solarisaio" ; then
  solaris_aio=yes
  LIBS="-laio $LIBS"
fi
echo "Solaris AIO support           $solaris_aio"

##########################################
# __sync_fetch_and_add test
if test "$sfaa" != "yes" ; then
  sfaa="no"
fi
cat > $TMPC << EOF
#include <inttypes.h>
static int sfaa(uint64_t *ptr)
{
  return __sync_fetch_and_add(ptr, 0);
}

int main(int argc, char **argv)
{
  uint64_t val = 42;
  sfaa(&val);
  return val;
}
EOF
if compile_prog "" "" "__sync_fetch_and_add()" ; then
    sfaa="yes"
fi
echo "__sync_fetch_and_add          $sfaa"

##########################################
# libverbs probe
if test "$libverbs" != "yes" ; then
  libverbs="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <infiniband/arch.h>
int main(int argc, char **argv)
{
  struct ibv_pd *pd = ibv_alloc_pd(NULL);
  return 0;
}
EOF
if test "$disable_rdma" != "yes" && compile_prog "" "-libverbs" "libverbs" ; then
    libverbs="yes"
    LIBS="-libverbs $LIBS"
fi
echo "libverbs                      $libverbs"

##########################################
# rdmacm probe
if test "$rdmacm" != "yes" ; then
  rdmacm="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <rdma/rdma_cma.h>
int main(int argc, char **argv)
{
  rdma_destroy_qp(NULL);
  return 0;
}
EOF
if test "$disable_rdma" != "yes" && compile_prog "" "-lrdmacm" "rdma"; then
    rdmacm="yes"
    LIBS="-lrdmacm $LIBS"
fi
echo "rdmacm                        $rdmacm"

##########################################
# Linux fallocate probe
if test "$linux_fallocate" != "yes" ; then
  linux_fallocate="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
#include <linux/falloc.h>
int main(int argc, char **argv)
{
  int r = fallocate(0, FALLOC_FL_KEEP_SIZE, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "linux_fallocate"; then
    linux_fallocate="yes"
fi
echo "Linux fallocate               $linux_fallocate"

##########################################
# POSIX fadvise probe
if test "$posix_fadvise" != "yes" ; then
  posix_fadvise="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fadvise(0, 0, 0, POSIX_FADV_NORMAL);
  return r;
}
EOF
if compile_prog "" "" "posix_fadvise"; then
    posix_fadvise="yes"
fi
echo "POSIX fadvise                 $posix_fadvise"

##########################################
# POSIX fallocate probe
if test "$posix_fallocate" != "yes" ; then
  posix_fallocate="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fallocate(0, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "posix_fallocate"; then
    posix_fallocate="yes"
fi
echo "POSIX fallocate               $posix_fallocate"

##########################################
# sched_set/getaffinity 2 or 3 argument test
if test "$linux_2arg_affinity" != "yes" ; then
  linux_2arg_affinity="no"
fi
if test "$linux_3arg_affinity" != "yes" ; then
  linux_3arg_affinity="no"
fi
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, sizeof(mask), &mask);
}
EOF
if compile_prog "" "" "sched_setaffinity(,,)"; then
  linux_3arg_affinity="yes"
else
  cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, &mask);
}
EOF
  if compile_prog "" "" "sched_setaffinity(,)"; then
    linux_2arg_affinity="yes"
  fi
fi
echo "sched_setaffinity(3 arg)      $linux_3arg_affinity"
echo "sched_setaffinity(2 arg)      $linux_2arg_affinity"

##########################################
# clock_gettime probe
if test "$clock_gettime" != "yes" ; then
  clock_gettime="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(0, NULL);
}
EOF
if compile_prog "" "" "clock_gettime"; then
    clock_gettime="yes"
elif compile_prog "" "-lrt" "clock_gettime"; then
    clock_gettime="yes"
    LIBS="-lrt $LIBS"
fi
echo "clock_gettime                 $clock_gettime"

##########################################
# CLOCK_MONOTONIC probe
if test "$clock_monotonic" != "yes" ; then
  clock_monotonic="no"
fi
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic"; then
      clock_monotonic="yes"
  fi
fi
echo "CLOCK_MONOTONIC               $clock_monotonic"

##########################################
# CLOCK_MONOTONIC_RAW probe
if test "$clock_monotonic_raw" != "yes" ; then
  clock_monotonic_raw="no"
fi
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC_RAW, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic"; then
      clock_monotonic_raw="yes"
  fi
fi
echo "CLOCK_MONOTONIC_RAW           $clock_monotonic_raw"

##########################################
# CLOCK_MONOTONIC_PRECISE probe
if test "$clock_monotonic_precise" != "yes" ; then
  clock_monotonic_precise="no"
fi
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC_PRECISE, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic precise"; then
      clock_monotonic_precise="yes"
  fi
fi
echo "CLOCK_MONOTONIC_PRECISE       $clock_monotonic_precise"

##########################################
# clockid_t probe
if test "$clockid_t" != "yes" ; then
  clockid_t="no"
fi
cat > $TMPC << EOF
#include <time.h>
#include <string.h>
int main(int argc, char **argv)
{
  volatile clockid_t cid;
  memset((void*)&cid, 0, sizeof(cid));
  return 0;
}
EOF
if compile_prog "" "$LIBS" "clockid_t"; then
  clockid_t="yes"
fi
echo "clockid_t                     $clockid_t"

##########################################
# gettimeofday() probe
if test "$gettimeofday" != "yes" ; then
  gettimeofday="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct timeval tv;
  return gettimeofday(&tv, NULL);
}
EOF
if compile_prog "" "" "gettimeofday"; then
    gettimeofday="yes"
fi
echo "gettimeofday                  $gettimeofday"

##########################################
# fdatasync() probe
if test "$fdatasync" != "yes" ; then
  fdatasync="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
int main(int argc, char **argv)
{
  return fdatasync(0);
}
EOF
if compile_prog "" "" "fdatasync"; then
  fdatasync="yes"
fi
echo "fdatasync                     $fdatasync"

##########################################
# sync_file_range() probe
if test "$sync_file_range" != "yes" ; then
  sync_file_range="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/fs.h>
int main(int argc, char **argv)
{
  unsigned int flags = SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE |
			SYNC_FILE_RANGE_WAIT_AFTER;
  return sync_file_range(0, 0, 0, flags);
}
EOF
if compile_prog "" "" "sync_file_range"; then
  sync_file_range="yes"
fi
echo "sync_file_range               $sync_file_range"

##########################################
# ext4 move extent probe
if test "$ext4_me" != "yes" ; then
  ext4_me="no"
fi
cat > $TMPC << EOF
#include <fcntl.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
  struct move_extent me;
  return ioctl(0, EXT4_IOC_MOVE_EXT, &me);
}
EOF
if compile_prog "" "" "ext4 move extent" ; then
  ext4_me="yes"
elif test $targetos = "Linux" ; then
  # On Linux, just default to it on and let it error at runtime if we really
  # don't have it. None of my updated systems have it defined, but it does
  # work. Takes a while to bubble back.
  ext4_me="yes"
fi
echo "EXT4 move extent              $ext4_me"

##########################################
# splice probe
if test "$linux_splice" != "yes" ; then
  linux_splice="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  return splice(0, NULL, 0, NULL, 0, SPLICE_F_NONBLOCK);
}
EOF
if compile_prog "" "" "linux splice"; then
  linux_splice="yes"
fi
echo "Linux splice(2)               $linux_splice"

##########################################
# GUASI probe
if test "$guasi" != "yes" ; then
  guasi="no"
fi
cat > $TMPC << EOF
#include <guasi.h>
#include <guasi_syscalls.h>
int main(int argc, char **argv)
{
  guasi_t ctx = guasi_create(0, 0, 0);
  return 0;
}
EOF
if compile_prog "" "" "guasi"; then
  guasi="yes"
fi
echo "GUASI                         $guasi"

##########################################
# fusion-aw probe
if test "$fusion_aw" != "yes" ; then
  fusion_aw="no"
fi
cat > $TMPC << EOF
#include <nvm/nvm_primitives.h>
int main(int argc, char **argv)
{
  nvm_version_t ver_info;
  nvm_handle_t handle;

  handle = nvm_get_handle(0, &ver_info);
  return nvm_atomic_write(handle, 0, 0, 0);
}
EOF
if compile_prog "" "-L/usr/lib/fio -L/usr/lib/nvm -lnvm-primitives -ldl -lpthread" "fusion-aw"; then
  LIBS="-L/usr/lib/fio -L/usr/lib/nvm -lnvm-primitives -ldl -lpthread $LIBS"
  fusion_aw="yes"
fi
echo "Fusion-io atomic engine       $fusion_aw"

##########################################
# libnuma probe
if test "$libnuma" != "yes" ; then
  libnuma="no"
fi
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  return numa_available();
}
EOF
if test "$disable_numa" != "yes"  && compile_prog "" "-lnuma" "libnuma"; then
  libnuma="yes"
  LIBS="-lnuma $LIBS"
fi
echo "libnuma                       $libnuma"

##########################################
# libnuma 2.x version API, initialize with "no" only if $libnuma is set to "yes"
if test "$libnuma" = "yes" ; then
libnuma_v2="no"
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  struct bitmask *mask = numa_parse_nodestring(NULL);
  return mask->size == 0;
}
EOF
if compile_prog "" "" "libnuma api"; then
  libnuma_v2="yes"
fi
echo "libnuma v2                    $libnuma_v2"
fi

##########################################
# strsep() probe
if test "$strsep" != "yes" ; then
  strsep="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  static char *string = "This is a string";
  strsep(&string, "needle");
  return 0;
}
EOF
if compile_prog "" "" "strsep"; then
  strsep="yes"
fi
echo "strsep                        $strsep"

##########################################
# strcasestr() probe
if test "$strcasestr" != "yes" ; then
  strcasestr="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  return strcasestr(argv[0], argv[1]) != NULL;
}
EOF
if compile_prog "" "" "strcasestr"; then
  strcasestr="yes"
fi
echo "strcasestr                    $strcasestr"

##########################################
# strlcat() probe
if test "$strlcat" != "yes" ; then
  strlcat="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  static char dst[64];
  static char *string = "This is a string";
  memset(dst, 0, sizeof(dst));
  strlcat(dst, string, sizeof(dst));
  return 0;
}
EOF
if compile_prog "" "" "strlcat"; then
  strlcat="yes"
fi
echo "strlcat                       $strlcat"

##########################################
# getopt_long_only() probe
if test "$getopt_long_only" != "yes" ; then
  getopt_long_only="no"
fi
cat > $TMPC << EOF
#include <unistd.h>
#include <stdio.h>
#include <getopt.h>
int main(int argc, char **argv)
{
  int c = getopt_long_only(argc, argv, NULL, NULL, NULL);
  return c;
}
EOF
if compile_prog "" "" "getopt_long_only"; then
  getopt_long_only="yes"
fi
echo "getopt_long_only()            $getopt_long_only"

##########################################
# inet_aton() probe
if test "$inet_aton" != "yes" ; then
  inet_aton="no"
fi
cat > $TMPC << EOF
#include <sys/socket.h>
#include <arpa/inet.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct in_addr in;
  return inet_aton(NULL, &in);
}
EOF
if compile_prog "" "" "inet_aton"; then
  inet_aton="yes"
fi
echo "inet_aton                     $inet_aton"

##########################################
# socklen_t probe
if test "$socklen_t" != "yes" ; then
  socklen_t="no"
fi
cat > $TMPC << EOF
#include <sys/socket.h>
int main(int argc, char **argv)
{
  socklen_t len = 0;
  return len;
}
EOF
if compile_prog "" "" "socklen_t"; then
  socklen_t="yes"
fi
echo "socklen_t                     $socklen_t"

##########################################
# Whether or not __thread is supported for TLS
if test "$tls_thread" != "yes" ; then
  tls_thread="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
static __thread int ret;
int main(int argc, char **argv)
{
  return ret;
}
EOF
if compile_prog "" "" "__thread"; then
  tls_thread="yes"
fi
echo "__thread                      $tls_thread"

##########################################
# Check if we have required gtk/glib support for gfio
if test "$gfio" != "yes" ; then
  gfio="no"
fi
if test "$gfio_check" = "yes" ; then
  cat > $TMPC << EOF
#include <glib.h>
#include <cairo.h>
#include <gtk/gtk.h>
int main(void)
{
  gdk_threads_enter();
  gdk_threads_leave();

  return GTK_CHECK_VERSION(2, 18, 0) ? 0 : 1; /* 0 on success */
}
EOF
GTK_CFLAGS=$(pkg-config --cflags gtk+-2.0 gthread-2.0)
ORG_LDFLAGS=$LDFLAGS
LDFLAGS=$(echo $LDFLAGS | sed s/"-static"//g)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
GTK_LIBS=$(pkg-config --libs gtk+-2.0 gthread-2.0)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
if compile_prog "$GTK_CFLAGS" "$GTK_LIBS" "gfio" ; then
  $TMPE
  if test "$?" = "0" ; then
    gfio="yes"
    GFIO_LIBS="$LIBS $GTK_LIBS"
    CFLAGS="$CFLAGS $GTK_CFLAGS"
  else
    echo "GTK found, but need version 2.18 or higher"
    gfio="no"
  fi
else
  echo "Please install gtk and gdk libraries"
  gfio="no"
fi
LDFLAGS=$ORG_LDFLAGS
fi

if test "$gfio_check" = "yes" ; then
  echo "gtk 2.18 or higher            $gfio"
fi

##########################################
# Check whether we have getrusage(RUSAGE_THREAD)
if test "$rusage_thread" != "yes" ; then
  rusage_thread="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rusage ru;
  getrusage(RUSAGE_THREAD, &ru);
  return 0;
}
EOF
if compile_prog "" "" "RUSAGE_THREAD"; then
  rusage_thread="yes"
fi
echo "RUSAGE_THREAD                 $rusage_thread"

##########################################
# Check whether we have SCHED_IDLE
if test "$sched_idle" != "yes" ; then
  sched_idle="no"
fi
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  struct sched_param p;
  return sched_setscheduler(0, SCHED_IDLE, &p);
}
EOF
if compile_prog "" "" "SCHED_IDLE"; then
  sched_idle="yes"
fi
echo "SCHED_IDLE                    $sched_idle"

##########################################
# Check whether we have TCP_NODELAY
if test "$tcp_nodelay" != "yes" ; then
  tcp_nodelay="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
int main(int argc, char **argv)
{
  return getsockopt(0, 0, TCP_NODELAY, NULL, NULL);
}
EOF
if compile_prog "" "" "TCP_NODELAY"; then
  tcp_nodelay="yes"
fi
echo "TCP_NODELAY                   $tcp_nodelay"

##########################################
# Check whether we have SO_SNDBUF
if test "$window_size" != "yes" ; then
  window_size="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
int main(int argc, char **argv)
{
  setsockopt(0, SOL_SOCKET, SO_SNDBUF, NULL, 0);
  setsockopt(0, SOL_SOCKET, SO_RCVBUF, NULL, 0);
}
EOF
if compile_prog "" "" "SO_SNDBUF"; then
  window_size="yes"
fi
echo "Net engine window_size        $window_size"

##########################################
# Check whether we have TCP_MAXSEG
if test "$mss" != "yes" ; then
  mss="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netinet/in.h>
int main(int argc, char **argv)
{
  return setsockopt(0, IPPROTO_TCP, TCP_MAXSEG, NULL, 0);
}
EOF
if compile_prog "" "" "TCP_MAXSEG"; then
  mss="yes"
fi
echo "TCP_MAXSEG                    $mss"

##########################################
# Check whether we have RLIMIT_MEMLOCK
if test "$rlimit_memlock" != "yes" ; then
  rlimit_memlock="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rlimit rl;
  return getrlimit(RLIMIT_MEMLOCK, &rl);
}
EOF
if compile_prog "" "" "RLIMIT_MEMLOCK"; then
  rlimit_memlock="yes"
fi
echo "RLIMIT_MEMLOCK                $rlimit_memlock"

##########################################
# Check whether we have pwritev/preadv
if test "$pwritev" != "yes" ; then
  pwritev="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/uio.h>
int main(int argc, char **argv)
{
  return pwritev(0, NULL, 1, 0) + preadv(0, NULL, 1, 0);
}
EOF
if compile_prog "" "" "pwritev"; then
  pwritev="yes"
fi
echo "pwritev/preadv                $pwritev"

##########################################
# Check whether we have pwritev2/preadv2
if test "$pwritev2" != "yes" ; then
  pwritev2="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/uio.h>
int main(int argc, char **argv)
{
  return pwritev2(0, NULL, 1, 0, 0) + preadv2(0, NULL, 1, 0, 0);
}
EOF
if compile_prog "" "" "pwritev2"; then
  pwritev2="yes"
fi
echo "pwritev2/preadv2              $pwritev2"

##########################################
# Check whether we have the required functions for ipv6
if test "$ipv6" != "yes" ; then
  ipv6="no"
fi
cat > $TMPC << EOF
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct addrinfo hints;
  struct in6_addr addr;
  int ret;

  ret = getaddrinfo(NULL, NULL, &hints, NULL);
  freeaddrinfo(NULL);
  printf("%s\n", gai_strerror(ret));
  addr = in6addr_any;
  return 0;
}
EOF
if compile_prog "" "" "ipv6"; then
  ipv6="yes"
fi
echo "IPv6 helpers                  $ipv6"

##########################################
# check for rbd
if test "$rbd" != "yes" ; then
  rbd="no"
fi
cat > $TMPC << EOF
#include <rbd/librbd.h>

int main(int argc, char **argv)
{
  rados_t cluster;
  rados_ioctx_t io_ctx;
  const char pool[] = "rbd";

  int major, minor, extra;
  rbd_version(&major, &minor, &extra);

  rados_ioctx_create(cluster, pool, &io_ctx);
  return 0;
}
EOF
if test "$disable_rbd" != "yes"  && compile_prog "" "-lrbd -lrados" "rbd"; then
  LIBS="-lrbd -lrados $LIBS"
  rbd="yes"
fi
echo "Rados Block Device engine     $rbd"

##########################################
# check for rbd_poll
if test "$rbd_poll" != "yes" ; then
  rbd_poll="no"
fi
if test "$rbd" = "yes"; then
cat > $TMPC << EOF
#include <rbd/librbd.h>
#include <sys/eventfd.h>

int main(int argc, char **argv)
{
  rbd_image_t image;
  rbd_completion_t comp;

  int fd = eventfd(0, EFD_NONBLOCK);
  rbd_set_image_notification(image, fd, EVENT_TYPE_EVENTFD);
  rbd_poll_io_events(image, comp, 1);

  return 0;
}
EOF
if compile_prog "" "-lrbd -lrados" "rbd"; then
  rbd_poll="yes"
fi
echo "rbd_poll                      $rbd_poll"
fi

##########################################
# check for rbd_invaidate_cache()
if test "$rbd_inval" != "yes" ; then
  rbd_inval="no"
fi
if test "$rbd" = "yes"; then
cat > $TMPC << EOF
#include <rbd/librbd.h>

int main(int argc, char **argv)
{
  rbd_image_t image;

  return rbd_invalidate_cache(image);
}
EOF
if compile_prog "" "-lrbd -lrados" "rbd"; then
  rbd_inval="yes"
fi
echo "rbd_invalidate_cache          $rbd_inval"
fi

##########################################
# check for blkin
if test "$rbd_blkin" != "yes" ; then
  rbd_blkin="no"
fi
cat > $TMPC << EOF
#include <rbd/librbd.h>
#include <zipkin_c.h>

int main(int argc, char **argv)
{
  int r;
  struct blkin_trace_info t_info;
  blkin_init_trace_info(&t_info);
  rbd_completion_t completion;
  rbd_image_t image;
  uint64_t off;
  size_t len;
  const char *buf;
  r = rbd_aio_write_traced(image, off, len, buf, completion, &t_info);
  return 0;
}
EOF
if test "$disable_rbd" != "yes" && test "$disable_rbd_blkin" != "yes" \
 && compile_prog "" "-lrbd -lrados -lblkin" "rbd_blkin"; then
  LIBS="-lblkin $LIBS"
  rbd_blkin="yes"
fi
echo "rbd blkin tracing             $rbd_blkin"

##########################################
# Check whether we have setvbuf
if test "$setvbuf" != "yes" ; then
  setvbuf="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
int main(int argc, char **argv)
{
  FILE *f = NULL;
  char buf[80];
  setvbuf(f, buf, _IOFBF, sizeof(buf));
  return 0;
}
EOF
if compile_prog "" "" "setvbuf"; then
  setvbuf="yes"
fi
echo "setvbuf                       $setvbuf"

##########################################
# check for gfapi
if test "$gfapi" != "yes" ; then
  gfapi="no"
fi
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  glfs_t *g = glfs_new("foo");

  return 0;
}
EOF
if test "$disable_gfapi" != "yes"  && compile_prog "" "-lgfapi -lglusterfs" "gfapi"; then
  LIBS="-lgfapi -lglusterfs $LIBS"
  gfapi="yes"
fi
 echo "Gluster API engine            $gfapi"

##########################################
# check for gfapi fadvise support, initialize with "no" only if $gfapi is set to "yes"
if test "$gfapi" = "yes" ; then
gf_fadvise="no"
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  struct glfs_fd *fd;
  int ret = glfs_fadvise(fd, 0, 0, 1);

  return 0;
}
EOF
if compile_prog "" "-lgfapi -lglusterfs" "gfapi"; then
  gf_fadvise="yes"
fi
echo "Gluster API use fadvise       $gf_fadvise"
fi

##########################################
# check for gfapi trim support
if test "$gf_trim" != "yes" ; then
  gf_trim="no"
fi
if test "$gfapi" = "yes" ; then
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  return glfs_discard_async(NULL, 0, 0);
}
EOF
if compile_prog "" "-lgfapi -lglusterfs" "gf trim"; then
  gf_trim="yes"
fi
echo "Gluster API trim support      $gf_trim"
fi

##########################################
# Check if we support stckf on s390
if test "$s390_z196_facilities" != "yes" ; then
  s390_z196_facilities="no"
fi
cat > $TMPC << EOF
#define STFLE_BITS_Z196 45 /* various z196 facilities ... */
int main(int argc, char **argv)
{
    /* We want just 1 double word to be returned.  */
    register unsigned long reg0 asm("0") = 0;
    unsigned long stfle_bits;
    asm volatile(".machine push"        "\n\t"
                 ".machine \"z9-109\""  "\n\t"
                 "stfle %0"             "\n\t"
                 ".machine pop"         "\n"
                 : "=QS" (stfle_bits), "+d" (reg0)
                 : : "cc");

    if ((stfle_bits & (1UL << (63 - STFLE_BITS_Z196))) != 0)
      return 0;
    else
      return -1;
}
EOF
if compile_prog "" "" "s390_z196_facilities"; then
  $TMPE
  if [[ $? -eq 0 ]]; then
  	s390_z196_facilities="yes"
  fi
fi
echo "s390_z196_facilities          $s390_z196_facilities"

##########################################
# Check if we have required environment variables configured for libhdfs
if test "$libhdfs" = "yes" ; then
  hdfs_conf_error=0
  if test "$JAVA_HOME" = "" ; then
    echo "configure: JAVA_HOME should be defined to jdk/jvm path"
    hdfs_conf_error=1
  fi
  if test "$FIO_LIBHDFS_INCLUDE" = "" ; then
    echo "configure: FIO_LIBHDFS_INCLUDE should be defined to libhdfs inlude path"
    hdfs_conf_error=1
  fi
  if test "$FIO_LIBHDFS_LIB" = "" ; then
    echo "configure: FIO_LIBHDFS_LIB should be defined to libhdfs library path"
    hdfs_conf_error=1
  fi
  if test "$hdfs_conf_error" = "1" ; then
    exit 1
  fi
  FIO_HDFS_CPU=$cpu
  if test "$FIO_HDFS_CPU" = "x86_64" ; then
    FIO_HDFS_CPU="amd64"
  fi
fi
echo "HDFS engine                   $libhdfs"

##########################################
# Check whether we have MTD
if test "$mtd" != "yes" ; then
  mtd="no"
fi
cat > $TMPC << EOF
#include <string.h>
#include <mtd/mtd-user.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
  struct mtd_write_req ops;
  struct mtd_info_user info;
  memset(&ops, 0, sizeof(ops));
  info.type = MTD_MLCNANDFLASH;
  return ioctl(0, MEMGETINFO, &info);
}
EOF
if compile_prog "" "" "mtd"; then
  mtd="yes"
fi
echo "MTD                           $mtd"

##########################################
# Check whether we have libpmem
if test "$libpmem" != "yes" ; then
  libpmem="no"
fi
cat > $TMPC << EOF
#include <libpmem.h>
int main(int argc, char **argv)
{
  int rc;
  rc = pmem_is_pmem(0, 0);
  return 0;
}
EOF
if compile_prog "" "-lpmem" "libpmem"; then
  libpmem="yes"
  LIBS="-lpmem $LIBS"
fi
echo "libpmem                       $libpmem"

##########################################
# Check whether we have libpmemblk
# libpmem is a prerequisite
if test "$libpmemblk" != "yes" ; then
  libpmemblk="no"
fi
if test "$libpmem" = "yes"; then
  cat > $TMPC << EOF
#include <libpmemblk.h>
int main(int argc, char **argv)
{
  PMEMblkpool *pbp;
  pbp = pmemblk_open("", 0);
  return 0;
}
EOF
  if compile_prog "" "-lpmemblk" "libpmemblk"; then
    libpmemblk="yes"
    LIBS="-lpmemblk $LIBS"
  fi
fi
echo "libpmemblk                    $libpmemblk"

# Choose the ioengines
if test "$libpmem" = "yes" && test "$disable_pmem" = "no"; then
  devdax="yes"
  if test "$libpmemblk" = "yes"; then
    pmemblk="yes"
  fi
fi

##########################################
# Report whether pmemblk engine is enabled
echo "NVML pmemblk engine           $pmemblk"

##########################################
# Report whether dev-dax engine is enabled
echo "NVML dev-dax engine           $devdax"

##########################################
# Check if we have lex/yacc available
yacc="no"
yacc_is_bison="no"
lex="no"
arith="no"
if test "$disable_lex" = "no" || test -z "$disable_lex" ; then
if test "$targetos" != "SunOS" ; then
LEX=$(which lex 2> /dev/null)
if test -x "$LEX" ; then
  lex="yes"
fi
YACC=$(which bison 2> /dev/null)
if test -x "$YACC" ; then
  yacc="yes"
  yacc_is_bison="yes"
else
  YACC=$(which yacc 2> /dev/null)
  if test -x "$YACC" ; then
    yacc="yes"
  fi
fi
if test "$yacc" = "yes" && test "$lex" = "yes" ; then
  arith="yes"
fi

if test "$arith" = "yes" ; then
cat > $TMPC << EOF
extern int yywrap(void);

int main(int argc, char **argv)
{
  yywrap();
  return 0;
}
EOF
if compile_prog "" "-ll" "lex"; then
  LIBS="-ll $LIBS"
else
  arith="no"
fi
fi
fi
fi

# Check if lex fails using -o
if test "$arith" = "yes" ; then
if test "$force_no_lex_o" = "yes" ; then
  lex_use_o="no"
else
$LEX -o lex.yy.c exp/expression-parser.l 2> /dev/null
if test "$?" = "0" ; then
  lex_use_o="yes"
else
  lex_use_o="no"
fi
fi
fi

echo "lex/yacc for arithmetic       $arith"

##########################################
# Check whether we have setmntent/getmntent
if test "$getmntent" != "yes" ; then
  getmntent="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <mntent.h>
int main(int argc, char **argv)
{
  FILE *mtab = setmntent(NULL, "r");
  struct mntent *mnt = getmntent(mtab);
  endmntent(mtab);
  return 0;
}
EOF
if compile_prog "" "" "getmntent"; then
  getmntent="yes"
fi
echo "getmntent                     $getmntent"

##########################################
# Check whether we have getmntinfo
# These are originally added for BSDs, but may also work
# on other operating systems with getmntinfo(3).

# getmntinfo(3) for FreeBSD/DragonFlyBSD/OpenBSD.
# Note that NetBSD needs -Werror to catch warning as error.
if test "$getmntinfo" != "yes" ; then
  getmntinfo="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/param.h>
#include <sys/mount.h>
int main(int argc, char **argv)
{
  struct statfs *st;
  return getmntinfo(&st, MNT_NOWAIT);
}
EOF
if compile_prog "-Werror" "" "getmntinfo"; then
  getmntinfo="yes"
fi
echo "getmntinfo                    $getmntinfo"

# getmntinfo(3) for NetBSD.
if test "$getmntinfo_statvfs" != "yes" ; then
  getmntinfo_statvfs="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/statvfs.h>
int main(int argc, char **argv)
{
  struct statvfs *st;
  return getmntinfo(&st, MNT_NOWAIT);
}
EOF
# Skip the test if the one with statfs arg is detected.
if test "$getmntinfo" != "yes" && compile_prog "-Werror" "" "getmntinfo_statvfs"; then
  getmntinfo_statvfs="yes"
  echo "getmntinfo_statvfs            $getmntinfo_statvfs"
fi

##########################################
# Check whether we have _Static_assert
if test "$static_assert" != "yes" ; then
  static_assert="no"
fi
cat > $TMPC << EOF
#include <assert.h>
#include <stdlib.h>
#undef offsetof
#ifdef __compiler_offsetof
#define offsetof(TYPE,MEMBER) __compiler_offsetof(TYPE,MEMBER)
#else
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#endif

#define container_of(ptr, type, member) ({			\
	const typeof( ((type *)0)->member ) *__mptr = (ptr);	\
	(type *)( (char *)__mptr - offsetof(type,member) );})

struct foo {
  int a, b;
};

int main(int argc, char **argv)
{
  _Static_assert(offsetof(struct foo, a) == 0 , "Check");
  return 0 ;
}
EOF
if compile_prog "" "" "static_assert"; then
    static_assert="yes"
fi
echo "Static Assert                 $static_assert"

##########################################
# Check whether we have bool / stdbool.h
if test "$have_bool" != "yes" ; then
  have_bool="no"
fi
cat > $TMPC << EOF
#include <stdbool.h>
int main(int argc, char **argv)
{
  bool var = true;
  return var != false;
}
EOF
if compile_prog "" "" "bool"; then
  have_bool="yes"
fi
echo "bool                          $have_bool"

##########################################
# check march=armv8-a+crc+crypto
if test "$march_armv8_a_crc_crypto" != "yes" ; then
  march_armv8_a_crc_crypto="no"
fi
if test "$cpu" = "arm64" ; then
  cat > $TMPC <<EOF
#include <sys/auxv.h>
#include <arm_acle.h>
#include <arm_neon.h>

int main(void)
{
  return 0;
}
EOF
  if compile_prog "-march=armv8-a+crc+crypto" "" ""; then
    march_armv8_a_crc_crypto="yes"
    CFLAGS="$CFLAGS -march=armv8-a+crc+crypto -DARCH_HAVE_CRC_CRYPTO"
  fi
fi
echo "march_armv8_a_crc_crypto      $march_armv8_a_crc_crypto"

##########################################
# cuda probe
if test "$cuda" != "yes" ; then
  cuda="no"
fi
cat > $TMPC << EOF
#include <cuda.h>
int main(int argc, char **argv)
{
  return cuInit(0);
}
EOF
if test "$enable_cuda" = "yes" && compile_prog "" "-lcuda" "cuda"; then
  cuda="yes"
  LIBS="-lcuda $LIBS"
fi
echo "cuda                          $cuda"

#############################################################################

if test "$wordsize" = "64" ; then
  output_sym "CONFIG_64BIT"
elif test "$wordsize" = "32" ; then
  output_sym "CONFIG_32BIT"
else
  fatal "Unknown wordsize!"
fi
if test "$bigendian" = "yes" ; then
  output_sym "CONFIG_BIG_ENDIAN"
else
  output_sym "CONFIG_LITTLE_ENDIAN"
fi
if test "$zlib" = "yes" ; then
  output_sym "CONFIG_ZLIB"
fi
if test "$libaio" = "yes" ; then
  output_sym "CONFIG_LIBAIO"
fi
if test "$posix_aio" = "yes" ; then
  output_sym "CONFIG_POSIXAIO"
fi
if test "$posix_aio_fsync" = "yes" ; then
  output_sym "CONFIG_POSIXAIO_FSYNC"
fi
if test "$posix_pshared" = "yes" ; then
  output_sym "CONFIG_PSHARED"
fi
if test "$linux_fallocate" = "yes" ; then
  output_sym "CONFIG_LINUX_FALLOCATE"
fi
if test "$posix_fallocate" = "yes" ; then
  output_sym "CONFIG_POSIX_FALLOCATE"
fi
if test "$fdatasync" = "yes" ; then
  output_sym "CONFIG_FDATASYNC"
fi
if test "$sync_file_range" = "yes" ; then
  output_sym "CONFIG_SYNC_FILE_RANGE"
fi
if test "$sfaa" = "yes" ; then
  output_sym "CONFIG_SFAA"
fi
if test "$libverbs" = "yes" -a "$rdmacm" = "yes" ; then
  output_sym "CONFIG_RDMA"
fi
if test "$clock_gettime" = "yes" ; then
  output_sym "CONFIG_CLOCK_GETTIME"
fi
if test "$clock_monotonic" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC"
fi
if test "$clock_monotonic_raw" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC_RAW"
fi
if test "$clock_monotonic_precise" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC_PRECISE"
fi
if test "$clockid_t" = "yes"; then
  output_sym "CONFIG_CLOCKID_T"
fi
if test "$gettimeofday" = "yes" ; then
  output_sym "CONFIG_GETTIMEOFDAY"
fi
if test "$posix_fadvise" = "yes" ; then
  output_sym "CONFIG_POSIX_FADVISE"
fi
if test "$linux_3arg_affinity" = "yes" ; then
  output_sym "CONFIG_3ARG_AFFINITY"
elif test "$linux_2arg_affinity" = "yes" ; then
  output_sym "CONFIG_2ARG_AFFINITY"
fi
if test "$strsep" = "yes" ; then
  output_sym "CONFIG_STRSEP"
fi
if test "$strcasestr" = "yes" ; then
  output_sym "CONFIG_STRCASESTR"
fi
if test "$strlcat" = "yes" ; then
  output_sym "CONFIG_STRLCAT"
fi
if test "$getopt_long_only" = "yes" ; then
  output_sym "CONFIG_GETOPT_LONG_ONLY"
fi
if test "$inet_aton" = "yes" ; then
  output_sym "CONFIG_INET_ATON"
fi
if test "$socklen_t" = "yes" ; then
  output_sym "CONFIG_SOCKLEN_T"
fi
if test "$ext4_me" = "yes" ; then
  output_sym "CONFIG_LINUX_EXT4_MOVE_EXTENT"
fi
if test "$linux_splice" = "yes" ; then
  output_sym "CONFIG_LINUX_SPLICE"
fi
if test "$guasi" = "yes" ; then
  output_sym "CONFIG_GUASI"
fi
if test "$fusion_aw" = "yes" ; then
  output_sym "CONFIG_FUSION_AW"
fi
if test "$libnuma_v2" = "yes" ; then
  output_sym "CONFIG_LIBNUMA"
fi
if test "$solaris_aio" = "yes" ; then
  output_sym "CONFIG_SOLARISAIO"
fi
if test "$tls_thread" = "yes" ; then
  output_sym "CONFIG_TLS_THREAD"
fi
if test "$rusage_thread" = "yes" ; then
  output_sym "CONFIG_RUSAGE_THREAD"
fi
if test "$gfio" = "yes" ; then
  output_sym "CONFIG_GFIO"
fi
if test "$esx" = "yes" ; then
  output_sym "CONFIG_ESX"
  output_sym "CONFIG_NO_SHM"
fi
if test "$sched_idle" = "yes" ; then
  output_sym "CONFIG_SCHED_IDLE"
fi
if test "$tcp_nodelay" = "yes" ; then
  output_sym "CONFIG_TCP_NODELAY"
fi
if test "$window_size" = "yes" ; then
  output_sym "CONFIG_NET_WINDOWSIZE"
fi
if test "$mss" = "yes" ; then
  output_sym "CONFIG_NET_MSS"
fi
if test "$rlimit_memlock" = "yes" ; then
  output_sym "CONFIG_RLIMIT_MEMLOCK"
fi
if test "$pwritev" = "yes" ; then
  output_sym "CONFIG_PWRITEV"
fi
if test "$pwritev2" = "yes" ; then
  output_sym "CONFIG_PWRITEV2"
fi
if test "$ipv6" = "yes" ; then
  output_sym "CONFIG_IPV6"
fi
if test "$rbd" = "yes" ; then
  output_sym "CONFIG_RBD"
fi
if test "$rbd_poll" = "yes" ; then
  output_sym "CONFIG_RBD_POLL"
fi
if test "$rbd_inval" = "yes" ; then
  output_sym "CONFIG_RBD_INVAL"
fi
if test "$rbd_blkin" = "yes" ; then
  output_sym "CONFIG_RBD_BLKIN"
fi
if test "$setvbuf" = "yes" ; then
  output_sym "CONFIG_SETVBUF"
fi
if test "$s390_z196_facilities" = "yes" ; then
  output_sym "CONFIG_S390_Z196_FACILITIES"
  CFLAGS="$CFLAGS -march=z9-109"
fi
if test "$gfapi" = "yes" ; then
  output_sym "CONFIG_GFAPI"
fi
if test "$gf_fadvise" = "yes" ; then
  output_sym "CONFIG_GF_FADVISE"
fi
if test "$gf_trim" = "yes" ; then
  output_sym "CONFIG_GF_TRIM"
fi
if test "$libhdfs" = "yes" ; then
  output_sym "CONFIG_LIBHDFS"
  echo "FIO_HDFS_CPU=$FIO_HDFS_CPU" >> $config_host_mak
  echo "JAVA_HOME=$JAVA_HOME" >> $config_host_mak
  echo "FIO_LIBHDFS_INCLUDE=$FIO_LIBHDFS_INCLUDE" >> $config_host_mak
  echo "FIO_LIBHDFS_LIB=$FIO_LIBHDFS_LIB" >> $config_host_mak
 fi
if test "$mtd" = "yes" ; then
  output_sym "CONFIG_MTD"
fi
if test "$pmemblk" = "yes" ; then
  output_sym "CONFIG_PMEMBLK"
fi
if test "$devdax" = "yes" ; then
  output_sym "CONFIG_LINUX_DEVDAX"
fi
if test "$arith" = "yes" ; then
  output_sym "CONFIG_ARITHMETIC"
  if test "$yacc_is_bison" = "yes" ; then
    echo "YACC=$YACC -y" >> $config_host_mak
  else
    echo "YACC=$YACC" >> $config_host_mak
  fi
  if test "$lex_use_o" = "yes" ; then
    echo "CONFIG_LEX_USE_O=y" >> $config_host_mak
  fi
fi
if test "$getmntent" = "yes" ; then
  output_sym "CONFIG_GETMNTENT"
fi
if test "$getmntinfo" = "yes" ; then
  output_sym "CONFIG_GETMNTINFO"
fi
if test "$getmntinfo_statvfs" = "yes" ; then
  output_sym "CONFIG_GETMNTINFO_STATVFS"
fi
if test "$static_assert" = "yes" ; then
  output_sym "CONFIG_STATIC_ASSERT"
fi
if test "$have_bool" = "yes" ; then
  output_sym "CONFIG_HAVE_BOOL"
fi
if test "$disable_opt" = "yes" ; then
  output_sym "CONFIG_DISABLE_OPTIMIZATIONS"
fi
if test "$zlib" = "no" ; then
  echo "Consider installing zlib-dev (zlib-devel), some fio features depend on it."
fi
if test "$cuda" = "yes" ; then
  output_sym "CONFIG_CUDA"
fi

echo "LIBS+=$LIBS" >> $config_host_mak
echo "GFIO_LIBS+=$GFIO_LIBS" >> $config_host_mak
echo "CFLAGS+=$CFLAGS" >> $config_host_mak
echo "LDFLAGS+=$LDFLAGS" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "BUILD_CFLAGS=$BUILD_CFLAGS $CFLAGS" >> $config_host_mak
echo "INSTALL_PREFIX=$prefix" >> $config_host_mak

if [ `dirname $0` != "." -a ! -e Makefile ]; then
    cat > Makefile <<EOF
SRCDIR:=`dirname $0`
include \$(SRCDIR)/Makefile
EOF
fi
