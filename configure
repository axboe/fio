#!/bin/sh
#
# Fio configure script. Heavily influenced by the manual qemu configure
# script. Sad this is easier than autoconf and enemies.
#

# set temporary file name
if test ! -z "$TMPDIR" ; then
    TMPDIR1="${TMPDIR}"
elif test ! -z "$TEMPDIR" ; then
    TMPDIR1="${TEMPDIR}"
else
    TMPDIR1="/tmp"
fi

TMPC="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.c"
TMPC2="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}-2.c"
TMPO="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.o"
TMPE="${TMPDIR1}/fio-conf-${RANDOM}-$$-${RANDOM}.exe"

# NB: do not call "exit" in the trap handler; this is buggy with some shells;
# see <1285349658-3122-1-git-send-email-loic.minier@linaro.org>
trap "rm -f $TMPC $TMPC2 $TMPO $TMPE" EXIT INT QUIT TERM

rm -rf config.log

config_host_mak="config-host.mak"
config_host_h="config-host.h"

rm -rf $config_host_mak
rm -rf $config_host_h

fatal() {
  echo $@
  echo "Configure failed, check config.log and/or the above output"
  rm -rf $config_host_mak
  rm -rf $config_host_h
  exit 1
}

# Print result for each configuration test
print_config() {
  printf "%-30s%s\n" "$1" "$2"
}

# Default CFLAGS
CFLAGS="-D_GNU_SOURCE -include config-host.h $CFLAGS"
BUILD_CFLAGS=""

# Print a helpful header at the top of config.log
echo "# FIO configure log $(date)" >> config.log
printf "# Configured with:" >> config.log
printf " '%s'" "$0" "$@" >> config.log
echo >> config.log
echo "#" >> config.log

# Print configure header at the top of $config_host_h
echo "/*" > $config_host_h
echo " * Automatically generated by configure - do not modify" >> $config_host_h
printf " * Configured with:" >> $config_host_h
printf " * '%s'" "$0" "$@" >> $config_host_h
echo "" >> $config_host_h
echo " */" >> $config_host_h

do_cc() {
    # Run the compiler, capturing its output to the log.
    echo $cc "$@" >> config.log
    $cc "$@" >> config.log 2>&1 || return $?
    # Test passed. If this is an --enable-werror build, rerun
    # the test with -Werror and bail out if it fails. This
    # makes warning-generating-errors in configure test code
    # obvious to developers.
    if test "$werror" != "yes"; then
        return 0
    fi
    # Don't bother rerunning the compile if we were already using -Werror
    case "$*" in
        *-Werror*)
           return 0
        ;;
    esac
    echo $cc -Werror "$@" >> config.log
    $cc -Werror "$@" >> config.log 2>&1 && return $?
    echo "ERROR: configure test passed without -Werror but failed with -Werror."
    echo "This is probably a bug in the configure script. The failing command"
    echo "will be at the bottom of config.log."
    fatal "You can run configure with --disable-werror to bypass this check."
}

compile_object() {
  do_cc $CFLAGS -Werror-implicit-function-declaration -c -o $TMPO $TMPC
}

compile_prog() {
  local_cflags="$1"
  local_ldflags="$2 $LIBS"
  echo "Compiling test case $3" >> config.log
  do_cc $CFLAGS -Werror-implicit-function-declaration $local_cflags -o $TMPE $TMPC $LDFLAGS $local_ldflags
}

feature_not_found() {
  feature=$1
  packages=$2

  echo "ERROR"
  echo "ERROR: User requested feature $feature"
  if test ! -z "$packages" ; then
    echo "ERROR: That feature needs $packages installed"
  fi
  echo "ERROR: configure was not able to find it"
  fatal "ERROR"
}

has() {
  type "$1" >/dev/null 2>&1
}

check_define() {
  cat > $TMPC <<EOF
#if !defined($1)
#error $1 not defined
#endif
int main(void)
{
  return 0;
}
EOF
  compile_object
}

output_sym() {
  echo "$1=y" >> $config_host_mak
  echo "#define $1" >> $config_host_h
}

check_min_lib_version() {
  _feature=$3

  if "${cross_prefix}"pkg-config --atleast-version="$2" "$1" > /dev/null 2>&1; then
    return 0
  fi
  : "${_feature:=${1}}"
  if "${cross_prefix}"pkg-config --version > /dev/null 2>&1; then
    if eval "echo \$$_feature" = "yes" ; then
      feature_not_found "$_feature" "$1 >= $2"
    fi
  else
    print_config "$1" "missing pkg-config, can't check $_feature version"
  fi
  return 1
}

targetos=""
cpu=""

# default options
show_help="no"
exit_val=0
gfio_check="no"
libhdfs="no"
pmemblk="no"
devdax="no"
pmem="no"
cuda="no"
libcufile="no"
disable_lex=""
disable_pmem="no"
disable_native="no"
march_set="no"
libiscsi="no"
libnbd="no"
libzbc=""
dynamic_engines="no"
prefix=/usr/local

# parse options
for opt do
  optarg=`expr "x$opt" : 'x[^=]*=\(.*\)'`
  case "$opt" in
  --prefix=*) prefix="$optarg"
  ;;
  --cpu=*) cpu="$optarg"
  ;;
  #  esx is cross compiled and cannot be detect through simple uname calls
  --esx)
  esx="yes"
  ;;
  --cc=*) CC="$optarg"
  ;;
  --extra-cflags=*) CFLAGS="$CFLAGS $optarg"
  ;;
  --build-32bit-win) build_32bit_win="yes"
  ;;
  --target-win-ver=*) target_win_ver="$optarg"
  ;;
  --enable-pdb) pdb="yes"
  ;;
  --build-static) build_static="yes"
  ;;
  --enable-gfio) gfio_check="yes"
  ;;
  --disable-numa) disable_numa="yes"
  ;;
  --disable-rdma) disable_rdma="yes"
  ;;
  --disable-rados) disable_rados="yes"
  ;;
  --disable-rbd) disable_rbd="yes"
  ;;
  --disable-http) disable_http="yes"
  ;;
  --disable-gfapi) disable_gfapi="yes"
  ;;
  --enable-libhdfs) libhdfs="yes"
  ;;
  --disable-lex) disable_lex="yes"
  ;;
  --enable-lex) disable_lex="no"
  ;;
  --disable-shm) no_shm="yes"
  ;;
  --disable-optimizations) disable_opt="yes"
  ;;
  --disable-pmem) disable_pmem="yes"
  ;;
  --enable-cuda) cuda="yes"
  ;;
  --enable-libcufile) libcufile="yes"
  ;;
  --disable-native) disable_native="yes"
  ;;
  --with-ime=*) ime_path="$optarg"
  ;;
  --enable-libiscsi) libiscsi="yes"
  ;;
  --enable-libnbd) libnbd="yes"
  ;;
  --disable-libzbc) libzbc="no"
  ;;
  --disable-tcmalloc) disable_tcmalloc="yes"
  ;;
  --dynamic-libengines) dynamic_engines="yes"
  ;;
  --help)
    show_help="yes"
    ;;
  *)
  echo "Bad option $opt"
  show_help="yes"
  exit_val=1
  esac
done

if test "$show_help" = "yes" ; then
  echo "--prefix=               Use this directory as installation prefix"
  echo "--cpu=                  Specify target CPU if auto-detect fails"
  echo "--cc=                   Specify compiler to use"
  echo "--extra-cflags=         Specify extra CFLAGS to pass to compiler"
  echo "--build-32bit-win       Enable 32-bit build on Windows"
  echo "--target-win-ver=       Minimum version of Windows to target (XP or 7)"
  echo "--enable-pdb            Enable Windows PDB symbols generation (needs clang/lld)"
  echo "--build-static          Build a static fio"
  echo "--esx                   Configure build options for esx"
  echo "--enable-gfio           Enable building of gtk gfio"
  echo "--disable-numa          Disable libnuma even if found"
  echo "--disable-rdma          Disable RDMA support even if found"
  echo "--disable-rados         Disable Rados support even if found"
  echo "--disable-rbd           Disable Rados Block Device even if found"
  echo "--disable-http          Disable HTTP support even if found"
  echo "--disable-gfapi         Disable gfapi"
  echo "--enable-libhdfs        Enable hdfs support"
  echo "--disable-lex           Disable use of lex/yacc for math"
  echo "--disable-pmem          Disable pmem based engines even if found"
  echo "--enable-lex            Enable use of lex/yacc for math"
  echo "--disable-shm           Disable SHM support"
  echo "--disable-optimizations Don't enable compiler optimizations"
  echo "--enable-cuda           Enable GPUDirect RDMA support"
  echo "--enable-libcufile      Enable GPUDirect Storage cuFile support"
  echo "--disable-native        Don't build for native host"
  echo "--with-ime=             Install path for DDN's Infinite Memory Engine"
  echo "--enable-libiscsi       Enable iscsi support"
  echo "--enable-libnbd         Enable libnbd (NBD engine) support"
  echo "--disable-libzbc        Disable libzbc even if found"
  echo "--disable-tcmalloc	Disable tcmalloc support"
  echo "--dynamic-libengines	Lib-based ioengines as dynamic libraries"
  exit $exit_val
fi

cross_prefix=${cross_prefix-${CROSS_COMPILE}}
# Preferred compiler (can be overriden later after we know the platform):
#  ${CC} (if set)
#  ${cross_prefix}gcc (if cross-prefix specified)
#  gcc if available
#  clang if available
if test -z "${CC}${cross_prefix}"; then
  if has gcc; then
    cc=gcc
  elif has clang; then
    cc=clang
  fi
else
  cc="${CC-${cross_prefix}gcc}"
fi

if check_define __ANDROID__ ; then
  targetos="Android"
elif check_define __linux__ ; then
  targetos="Linux"
elif check_define __OpenBSD__ ; then
  targetos='OpenBSD'
elif check_define __NetBSD__ ; then
  targetos='NetBSD'
elif check_define __sun__ ; then
  targetos='SunOS'
  CFLAGS="$CFLAGS -D_REENTRANT"
elif check_define _WIN32 ; then
  targetos='CYGWIN'
else
  targetos=`uname -s`
fi

echo "# Automatically generated by configure - do not modify" > $config_host_mak
printf "# Configured with:" >> $config_host_mak
printf " '%s'" "$0" "$@" >> $config_host_mak
echo >> $config_host_mak
echo "CONFIG_TARGET_OS=$targetos" >> $config_host_mak

if test "$no_shm" = "yes" ; then
  output_sym "CONFIG_NO_SHM"
fi

if test "$disable_opt" = "yes" ; then
  output_sym "CONFIG_FIO_NO_OPT"
fi

# Some host OSes need non-standard checks for which CPU to use.
# Note that these checks are broken for cross-compilation: if you're
# cross-compiling to one of these OSes then you'll need to specify
# the correct CPU with the --cpu option.
case $targetos in
AIX|OpenBSD|NetBSD)
  # Unless explicitly enabled, turn off lex.
  # OpenBSD will hit syntax error when enabled.
  if test -z "$disable_lex" ; then
    disable_lex="yes"
  else
    force_no_lex_o="yes"
  fi
  ;;
FreeBSD)
  CFLAGS="$CFLAGS -I/usr/local/include"
  LDFLAGS="$LDFLAGS -L/usr/local/lib"
  ;;
Darwin)
  # on Leopard most of the system is 32-bit, so we have to ask the kernel if
  # we can run 64-bit userspace code.
  # If the user didn't specify a CPU explicitly and the kernel says this is
  # 64 bit hw, then assume x86_64. Otherwise fall through to the usual
  # detection code.
  if test -z "$cpu" && test "$(sysctl -n hw.optional.x86_64)" = "1"; then
    cpu="x86_64"
  fi
  # Error at compile time linking of weak/partial symbols if possible...
cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
  if compile_prog "" "-Wl,-no_weak_imports" "disable weak symbols"; then
    echo "Disabling weak symbols"
    LDFLAGS="$LDFLAGS -Wl,-no_weak_imports"
  fi
  ;;
SunOS)
  # `uname -m` returns i86pc even on an x86_64 box, so default based on isainfo
  if test -z "$cpu" && test "$(isainfo -k)" = "amd64"; then
    cpu="x86_64"
  fi
  LIBS="-lnsl -lsocket"
  ;;
CYGWIN*)
  # We still force some options, so keep this message here.
  echo "Forcing some known good options on Windows"
  if test -z "${CC}${cross_prefix}"; then
    if test ! -z "$build_32bit_win" && test "$build_32bit_win" = "yes"; then
      cc="i686-w64-mingw32-gcc"
    else
      cc="x86_64-w64-mingw32-gcc"
    fi
  fi

  target_win_ver=$(echo "$target_win_ver" | tr '[:lower:]' '[:upper:]')
  if test -z "$target_win_ver"; then
    # Default Windows API target
    target_win_ver="7"
  fi
  if test "$target_win_ver" = "XP"; then
    output_sym "CONFIG_WINDOWS_XP"
    # Technically the below is targeting 2003
    CFLAGS="$CFLAGS -D_WIN32_WINNT=0x0502"
  elif test "$target_win_ver" = "7"; then
    output_sym "CONFIG_WINDOWS_7"
    CFLAGS="$CFLAGS -D_WIN32_WINNT=0x0601"
  else
    fatal "Unknown target Windows version"
  fi

  # We need this to be output_sym'd here because this is Windows specific.
  # The regular configure path never sets this config.
  output_sym "CONFIG_WINDOWSAIO"
  # We now take the regular configuration path without having exit 0 here.
  # Flags below are still necessary mostly for MinGW.
  build_static="yes"
  rusage_thread="yes"
  fdatasync="yes"
  clock_gettime="yes" # clock_monotonic probe has dependency on this
  clock_monotonic="yes"
  sched_idle="yes"
  ;;
esac

# Now we know the target platform we can have another guess at the preferred
# compiler when it wasn't explictly set
if test -z "${CC}${cross_prefix}"; then
  if test "$targetos" = "FreeBSD" || test "$targetos" = "Darwin"; then
    if has clang; then
      cc=clang
    fi
  fi
fi
if test -z "$cc"; then
    echo "configure: failed to find compiler"
    exit 1
fi

if test ! -z "$cpu" ; then
  # command line argument
  :
elif check_define __i386__ ; then
  cpu="i386"
elif check_define __x86_64__ ; then
  cpu="x86_64"
elif check_define __sparc__ ; then
  if check_define __arch64__ ; then
    cpu="sparc64"
  else
    cpu="sparc"
  fi
elif check_define _ARCH_PPC ; then
  if check_define _ARCH_PPC64 ; then
    cpu="ppc64"
  else
    cpu="ppc"
  fi
elif check_define __mips__ ; then
  cpu="mips"
elif check_define __ia64__ ; then
  cpu="ia64"
elif check_define __s390__ ; then
  if check_define __s390x__ ; then
    cpu="s390x"
  else
    cpu="s390"
  fi
elif check_define __arm__ ; then
  cpu="arm"
elif check_define __aarch64__ ; then
  cpu="aarch64"
elif check_define __hppa__ ; then
  cpu="hppa"
else
  cpu=`uname -m`
fi

# Normalise host CPU name and set ARCH.
case "$cpu" in
  ia64|ppc|ppc64|s390|s390x|sparc64)
    cpu="$cpu"
  ;;
  i386|i486|i586|i686|i86pc|BePC)
    cpu="x86"
  ;;
  x86_64|amd64)
    cpu="x86_64"
  ;;
  armv*b|armv*l|arm)
    cpu="arm"
  ;;
  aarch64)
    cpu="arm64"
  ;;
  hppa|parisc|parisc64)
    cpu="hppa"
  ;;
  mips*)
    cpu="mips"
  ;;
  sparc|sun4[cdmuv])
    cpu="sparc"
  ;;
  *)
  echo "Unknown CPU"
  ;;
esac

##########################################
# check cross compile

if test "$cross_compile" != "yes" ; then
  cross_compile="no"
fi
cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
if compile_prog "" "" "cross"; then
  $TMPE 2>/dev/null || cross_compile="yes"
else
  fatal "compile test failed"
fi

##########################################
# check endianness
if test "$bigendian" != "yes" ; then
  bigendian="no"
fi
if test "$cross_compile" = "no" ; then
  cat > $TMPC <<EOF
#include <inttypes.h>
int main(void)
{
  volatile uint32_t i=0x01234567;
  return (*((uint8_t*)(&i))) == 0x67;
}
EOF
  if compile_prog "" "" "endian"; then
    $TMPE && bigendian="yes"
  fi
else
  # If we're cross compiling, try our best to work it out and rely on the
  # run-time check to fail if we get it wrong.
  cat > $TMPC <<EOF
#include <endian.h>
int main(void)
{
#if __BYTE_ORDER != __BIG_ENDIAN
# error "Unknown endianness"
#endif
}
EOF
  compile_prog "" "" "endian" && bigendian="yes"
  check_define "__ARMEB__" && bigendian="yes"
  check_define "__MIPSEB__" && bigendian="yes"
fi


print_config "Operating system" "$targetos"
print_config "CPU" "$cpu"
print_config "Big endian" "$bigendian"
if test ! -z "$target_win_ver"; then
  print_config "Target Windows version" "$target_win_ver"
fi
print_config "Compiler" "$cc"
print_config "Cross compile" "$cross_compile"
echo

##########################################
# See if we need to build a static build
if test "$build_static" = "yes" ; then
  CFLAGS="$CFLAGS -ffunction-sections -fdata-sections"
  LDFLAGS="$LDFLAGS -static -Wl,--gc-sections"
else
  build_static="no"
fi
print_config "Static build" "$build_static"

##########################################
# check for C11 atomics support
cat > $TMPC <<EOF
#include <stdatomic.h>
int main(void)
{
  _Atomic unsigned v;
  atomic_load(&v);
  return 0;
}
EOF
if ! compile_prog "" "" "C11 atomics"; then
  echo
  echo "Your compiler doesn't support C11 atomics. gcc 4.9/clang 3.6 are the"
  echo "minimum versions with it - perhaps your compiler is too old?"
  fatal "C11 atomics support not found"
fi


##########################################
# check for wordsize
wordsize="0"
cat > $TMPC <<EOF
#include <limits.h>
#define BUILD_BUG_ON(condition) ((void)sizeof(char[1 - 2*!!(condition)]))
int main(void)
{
  BUILD_BUG_ON(sizeof(long)*CHAR_BIT != WORDSIZE);
  return 0;
}
EOF
if compile_prog "-DWORDSIZE=32" "" "wordsize"; then
  wordsize="32"
elif compile_prog "-DWORDSIZE=64" "" "wordsize"; then
  wordsize="64"
else
  fatal "Unknown wordsize"
fi
print_config "Wordsize" "$wordsize"

##########################################
# zlib probe
if test "$zlib" != "yes" ; then
  zlib="no"
fi
cat > $TMPC <<EOF
#include <zlib.h>
int main(void)
{
  z_stream stream;
  if (inflateInit(&stream) != Z_OK)
    return 1;
  return 0;
}
EOF
if compile_prog "" "-lz" "zlib" ; then
  zlib=yes
  LIBS="-lz $LIBS"
fi
print_config "zlib" "$zlib"

##########################################
# linux-aio probe
if test "$libaio" != "yes" ; then
  libaio="no"
fi
if test "$esx" != "yes" ; then
  cat > $TMPC <<EOF
#include <libaio.h>
#include <stddef.h>
int main(void)
{
  io_setup(0, NULL);
  return 0;
}
EOF
  if compile_prog "" "-laio" "libaio" ; then
    libaio=yes
  else
    if test "$libaio" = "yes" ; then
      feature_not_found "linux AIO" "libaio-dev or libaio-devel"
    fi
    libaio=no
  fi

  cat > $TMPC <<EOF
#include <libaio.h>
#include <stddef.h>
int main(void)
{
  io_prep_preadv2(NULL, 0, NULL, 0, 0, 0);
  io_prep_pwritev2(NULL, 0, NULL, 0, 0, 0);
  return 0;
}
EOF
  if compile_prog "" "" "libaio rw flags" ; then
    libaio_rw_flags=yes
  else
    libaio_rw_flags=no
  fi
fi
print_config "Linux AIO support" "$libaio"
print_config "Linux AIO support rw flags" "$libaio_rw_flags"

##########################################
# posix aio probe
if test "$posix_aio" != "yes" ; then
  posix_aio="no"
fi
if test "$posix_aio_lrt" != "yes" ; then
  posix_aio_lrt="no"
fi
cat > $TMPC <<EOF
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  aio_read(&cb);
  return 0;
}
EOF
if compile_prog "" "" "posixaio" ; then
  posix_aio="yes"
elif compile_prog "" "-lrt" "posixaio -lrt"; then
  posix_aio="yes"
  posix_aio_lrt="yes"
  LIBS="-lrt $LIBS"
fi
print_config "POSIX AIO support" "$posix_aio"
print_config "POSIX AIO support needs -lrt" "$posix_aio_lrt"

##########################################
# posix aio fsync probe
if test "$posix_aio_fsync" != "yes" ; then
  posix_aio_fsync="no"
fi
if test "$posix_aio" = "yes" ; then
  cat > $TMPC <<EOF
#include <fcntl.h>
#include <aio.h>
int main(void)
{
  struct aiocb cb;
  return aio_fsync(O_SYNC, &cb);
  return 0;
}
EOF
  if compile_prog "" "$LIBS" "posix_aio_fsync" ; then
    posix_aio_fsync=yes
  fi
fi
print_config "POSIX AIO fsync" "$posix_aio_fsync"

##########################################
# POSIX pshared attribute probe
if test "$posix_pshared" != "yes" ; then
  posix_pshared="no"
fi
cat > $TMPC <<EOF
#include <unistd.h>
int main(void)
{
#if defined(_POSIX_THREAD_PROCESS_SHARED) && ((_POSIX_THREAD_PROCESS_SHARED + 0) > 0)
# if defined(__CYGWIN__)
#  error "_POSIX_THREAD_PROCESS_SHARED is buggy on Cygwin"
# elif defined(__APPLE__)
#  include <AvailabilityMacros.h>
#  include <TargetConditionals.h>
#  if TARGET_OS_MAC && MAC_OS_X_VERSION_MIN_REQUIRED < 1070
#   error "_POSIX_THREAD_PROCESS_SHARED is buggy/unsupported prior to OSX 10.7"
#  endif
# endif
#else
# error "_POSIX_THREAD_PROCESS_SHARED is unsupported"
#endif
  return 0;
}
EOF
if compile_prog "" "$LIBS" "posix_pshared" ; then
  posix_pshared=yes
fi
print_config "POSIX pshared support" "$posix_pshared"

##########################################
# POSIX pthread_condattr_setclock() probe
if test "$pthread_condattr_setclock" != "yes" ; then
  pthread_condattr_setclock="no"
fi
cat > $TMPC <<EOF
#include <pthread.h>
int main(void)
{
  pthread_condattr_t condattr;
  pthread_condattr_setclock(&condattr, CLOCK_MONOTONIC);
  return 0;
}
EOF
if compile_prog "" "$LIBS" "pthread_condattr_setclock" ; then
  pthread_condattr_setclock=yes
elif compile_prog "" "$LIBS -lpthread" "pthread_condattr_setclock" ; then
  pthread_condattr_setclock=yes
  LIBS="$LIBS -lpthread"
fi
print_config "pthread_condattr_setclock()" "$pthread_condattr_setclock"

##########################################
# pthread_sigmask() probe
if test "$pthread_sigmask" != "yes" ; then
  pthread_sigmask="no"
fi
cat > $TMPC <<EOF
#include <stddef.h> /* NULL */
#include <signal.h> /* pthread_sigmask() */
int main(void)
{
  return pthread_sigmask(0, NULL, NULL);
}
EOF
if compile_prog "" "$LIBS" "pthread_sigmask" ; then
  pthread_sigmask=yes
elif compile_prog "" "$LIBS -lpthread" "pthread_sigmask" ; then
  pthread_sigmask=yes
  LIBS="$LIBS -lpthread"
fi
print_config "pthread_sigmask()" "$pthread_sigmask"

##########################################
# solaris aio probe
if test "$solaris_aio" != "yes" ; then
  solaris_aio="no"
fi
cat > $TMPC <<EOF
#include <sys/types.h>
#include <sys/asynch.h>
#include <unistd.h>
int main(void)
{
  aio_result_t res;
  return aioread(0, NULL, 0, 0, SEEK_SET, &res);
  return 0;
}
EOF
if compile_prog "" "-laio" "solarisaio" ; then
  solaris_aio=yes
  LIBS="-laio $LIBS"
fi
print_config "Solaris AIO support" "$solaris_aio"

##########################################
# __sync_fetch_and_add test
if test "$sfaa" != "yes" ; then
  sfaa="no"
fi
cat > $TMPC << EOF
#include <inttypes.h>
static int sfaa(uint64_t *ptr)
{
  return __sync_fetch_and_add(ptr, 0);
}

int main(int argc, char **argv)
{
  uint64_t val = 42;
  sfaa(&val);
  return val;
}
EOF
if compile_prog "" "" "__sync_fetch_and_add()" ; then
    sfaa="yes"
fi
print_config "__sync_fetch_and_add" "$sfaa"

##########################################
# __sync_synchronize() test
if test "$sync_sync" != "yes" ; then
  sync_sync="no"
fi
cat > $TMPC << EOF
#include <inttypes.h>

int main(int argc, char **argv)
{
  __sync_synchronize();
  return 0;
}
EOF
if compile_prog "" "" "__sync_synchronize()" ; then
    sync_sync="yes"
fi
print_config "__sync_synchronize" "$sync_sync"

##########################################
# __sync_val_compare_and_swap() test
if test "$cmp_swap" != "yes" ; then
  cmp_swap="no"
fi
cat > $TMPC << EOF
#include <inttypes.h>

int main(int argc, char **argv)
{
  int x = 0;
  return __sync_val_compare_and_swap(&x, 1, 2);
}
EOF
if compile_prog "" "" "__sync_val_compare_and_swap()" ; then
    cmp_swap="yes"
fi
print_config "__sync_val_compare_and_swap" "$cmp_swap"

##########################################
# libverbs probe
if test "$libverbs" != "yes" ; then
  libverbs="no"
fi
cat > $TMPC << EOF
#include <infiniband/verbs.h>
int main(int argc, char **argv)
{
  struct ibv_pd *pd = ibv_alloc_pd(NULL);
  return pd != NULL;
}
EOF
if test "$disable_rdma" != "yes" && compile_prog "" "-libverbs" "libverbs" ; then
    libverbs="yes"
fi
print_config "libverbs" "$libverbs"

##########################################
# rdmacm probe
if test "$rdmacm" != "yes" ; then
  rdmacm="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <rdma/rdma_cma.h>
int main(int argc, char **argv)
{
  rdma_destroy_qp(NULL);
  return 0;
}
EOF
if test "$disable_rdma" != "yes" && compile_prog "" "-lrdmacm" "rdma"; then
    rdmacm="yes"
fi
print_config "rdmacm" "$rdmacm"

##########################################
# asprintf() and vasprintf() probes
if test "$have_asprintf" != "yes" ; then
  have_asprintf="no"
fi
cat > $TMPC << EOF
#include <stdio.h>

int main(int argc, char **argv)
{
  char *buf;
  return asprintf(&buf, "%s", "str") == 0;
}
EOF
if compile_prog "" "" "have_asprintf"; then
    have_asprintf="yes"
fi
print_config "asprintf()" "$have_asprintf"

if test "$have_vasprintf" != "yes" ; then
  have_vasprintf="no"
fi
cat > $TMPC << EOF
#include <stdio.h>

int main(int argc, char **argv)
{
  va_list ap;
  char *buf;
  return vasprintf(&buf, "%s", ap) == 0;
}
EOF
if compile_prog "" "" "have_vasprintf"; then
    have_vasprintf="yes"
fi
print_config "vasprintf()" "$have_vasprintf"

##########################################
# Linux fallocate probe
if test "$linux_fallocate" != "yes" ; then
  linux_fallocate="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
#include <linux/falloc.h>
int main(int argc, char **argv)
{
  int r = fallocate(0, FALLOC_FL_KEEP_SIZE, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "linux_fallocate"; then
    linux_fallocate="yes"
fi
print_config "Linux fallocate" "$linux_fallocate"

##########################################
# POSIX fadvise probe
if test "$posix_fadvise" != "yes" ; then
  posix_fadvise="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fadvise(0, 0, 0, POSIX_FADV_NORMAL);
  return r;
}
EOF
if compile_prog "" "" "posix_fadvise"; then
    posix_fadvise="yes"
fi
print_config "POSIX fadvise" "$posix_fadvise"

##########################################
# POSIX fallocate probe
if test "$posix_fallocate" != "yes" ; then
  posix_fallocate="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  int r = posix_fallocate(0, 0, 1024);
  return r;
}
EOF
if compile_prog "" "" "posix_fallocate"; then
    posix_fallocate="yes"
fi
print_config "POSIX fallocate" "$posix_fallocate"

##########################################
# sched_set/getaffinity 2 or 3 argument test
if test "$linux_2arg_affinity" != "yes" ; then
  linux_2arg_affinity="no"
fi
if test "$linux_3arg_affinity" != "yes" ; then
  linux_3arg_affinity="no"
fi
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, sizeof(mask), &mask);
}
EOF
if compile_prog "" "" "sched_setaffinity(,,)"; then
  linux_3arg_affinity="yes"
else
  cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  cpu_set_t mask;
  return sched_setaffinity(0, &mask);
}
EOF
  if compile_prog "" "" "sched_setaffinity(,)"; then
    linux_2arg_affinity="yes"
  fi
fi
print_config "sched_setaffinity(3 arg)" "$linux_3arg_affinity"
print_config "sched_setaffinity(2 arg)" "$linux_2arg_affinity"

##########################################
# clock_gettime probe
if test "$clock_gettime" != "yes" ; then
  clock_gettime="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(0, NULL);
}
EOF
if compile_prog "" "" "clock_gettime"; then
    clock_gettime="yes"
elif compile_prog "" "-lrt" "clock_gettime"; then
    clock_gettime="yes"
    LIBS="-lrt $LIBS"
fi
print_config "clock_gettime" "$clock_gettime"

##########################################
# CLOCK_MONOTONIC probe
if test "$clock_monotonic" != "yes" ; then
  clock_monotonic="no"
fi
if test "$clock_gettime" = "yes" ; then
  cat > $TMPC << EOF
#include <stdio.h>
#include <time.h>
int main(int argc, char **argv)
{
  return clock_gettime(CLOCK_MONOTONIC, NULL);
}
EOF
  if compile_prog "" "$LIBS" "clock monotonic"; then
      clock_monotonic="yes"
  fi
fi
print_config "CLOCK_MONOTONIC" "$clock_monotonic"

##########################################
# clockid_t probe
if test "$clockid_t" != "yes" ; then
  clockid_t="no"
fi
cat > $TMPC << EOF
#include <time.h>
#include <string.h>
int main(int argc, char **argv)
{
  volatile clockid_t cid;
  memset((void*)&cid, 0, sizeof(cid));
  return 0;
}
EOF
if compile_prog "" "$LIBS" "clockid_t"; then
  clockid_t="yes"
fi
print_config "clockid_t" "$clockid_t"

##########################################
# gettimeofday() probe
if test "$gettimeofday" != "yes" ; then
  gettimeofday="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <stdio.h>
int main(int argc, char **argv)
{
  struct timeval tv;
  return gettimeofday(&tv, NULL);
}
EOF
if compile_prog "" "" "gettimeofday"; then
    gettimeofday="yes"
fi
print_config "gettimeofday" "$gettimeofday"

##########################################
# fdatasync() probe
if test "$fdatasync" != "yes" ; then
  fdatasync="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
int main(int argc, char **argv)
{
  return fdatasync(0);
}
EOF
if compile_prog "" "" "fdatasync"; then
  fdatasync="yes"
fi
print_config "fdatasync" "$fdatasync"

##########################################
# pipe() probe
if test "$pipe" != "yes" ; then
  pipe="no"
fi
cat > $TMPC << EOF
#include <unistd.h>
int main(int argc, char **argv)
{
  int fd[2];
  return pipe(fd);
}
EOF
if compile_prog "" "" "pipe"; then
  pipe="yes"
fi
print_config "pipe()" "$pipe"

##########################################
# pipe2() probe
if test "$pipe2" != "yes" ; then
  pipe2="no"
fi
cat > $TMPC << EOF
#include <unistd.h>
int main(int argc, char **argv)
{
  int fd[2];
  return pipe2(fd, 0);
}
EOF
if compile_prog "" "" "pipe2"; then
  pipe2="yes"
fi
print_config "pipe2()" "$pipe2"

##########################################
# pread() probe
if test "$pread" != "yes" ; then
  pread="no"
fi
cat > $TMPC << EOF
#include <unistd.h>
int main(int argc, char **argv)
{
  return pread(0, NULL, 0, 0);
}
EOF
if compile_prog "" "" "pread"; then
  pread="yes"
fi
print_config "pread()" "$pread"

##########################################
# sync_file_range() probe
if test "$sync_file_range" != "yes" ; then
  sync_file_range="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <unistd.h>
#include <fcntl.h>
#include <linux/fs.h>
int main(int argc, char **argv)
{
  unsigned int flags = SYNC_FILE_RANGE_WAIT_BEFORE | SYNC_FILE_RANGE_WRITE |
			SYNC_FILE_RANGE_WAIT_AFTER;
  return sync_file_range(0, 0, 0, flags);
}
EOF
if compile_prog "" "" "sync_file_range"; then
  sync_file_range="yes"
fi
print_config "sync_file_range" "$sync_file_range"

##########################################
# ext4 move extent probe
if test "$ext4_me" != "yes" ; then
  ext4_me="no"
fi
cat > $TMPC << EOF
#include <fcntl.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
  struct move_extent me;
  return ioctl(0, EXT4_IOC_MOVE_EXT, &me);
}
EOF
if compile_prog "" "" "ext4 move extent" ; then
  ext4_me="yes"
elif test $targetos = "Linux" ; then
  # On Linux, just default to it on and let it error at runtime if we really
  # don't have it. None of my updated systems have it defined, but it does
  # work. Takes a while to bubble back.
  ext4_me="yes"
fi
print_config "EXT4 move extent" "$ext4_me"

##########################################
# splice probe
if test "$linux_splice" != "yes" ; then
  linux_splice="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <fcntl.h>
int main(int argc, char **argv)
{
  return splice(0, NULL, 0, NULL, 0, SPLICE_F_NONBLOCK);
}
EOF
if compile_prog "" "" "linux splice"; then
  linux_splice="yes"
fi
print_config "Linux splice(2)" "$linux_splice"

##########################################
# libnuma probe
if test "$libnuma" != "yes" ; then
  libnuma="no"
fi
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  return numa_available();
}
EOF
if test "$disable_numa" != "yes"  && compile_prog "" "-lnuma" "libnuma"; then
  libnuma="yes"
  LIBS="-lnuma $LIBS"
fi
print_config "libnuma" "$libnuma"

##########################################
# libnuma 2.x version API, initialize with "no" only if $libnuma is set to "yes"
if test "$libnuma" = "yes" ; then
libnuma_v2="no"
cat > $TMPC << EOF
#include <numa.h>
int main(int argc, char **argv)
{
  struct bitmask *mask = numa_parse_nodestring(NULL);
  return mask->size == 0;
}
EOF
if compile_prog "" "" "libnuma api"; then
  libnuma_v2="yes"
fi
print_config "libnuma v2" "$libnuma_v2"
fi

##########################################
# strsep() probe
if test "$strsep" != "yes" ; then
  strsep="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  static char *string = "This is a string";
  strsep(&string, "needle");
  return 0;
}
EOF
if compile_prog "" "" "strsep"; then
  strsep="yes"
fi
print_config "strsep" "$strsep"

##########################################
# strcasestr() probe
if test "$strcasestr" != "yes" ; then
  strcasestr="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  return strcasestr(argv[0], argv[1]) != NULL;
}
EOF
if compile_prog "" "" "strcasestr"; then
  strcasestr="yes"
fi
print_config "strcasestr" "$strcasestr"

##########################################
# strlcat() probe
if test "$strlcat" != "yes" ; then
  strlcat="no"
fi
cat > $TMPC << EOF
#include <string.h>
int main(int argc, char **argv)
{
  static char dst[64];
  static char *string = "This is a string";
  memset(dst, 0, sizeof(dst));
  strlcat(dst, string, sizeof(dst));
  return 0;
}
EOF
if compile_prog "" "" "strlcat"; then
  strlcat="yes"
fi
print_config "strlcat" "$strlcat"

##########################################
# getopt_long_only() probe
if test "$getopt_long_only" != "yes" ; then
  getopt_long_only="no"
fi
cat > $TMPC << EOF
#include <unistd.h>
#include <stdio.h>
#include <getopt.h>
int main(int argc, char **argv)
{
  int c = getopt_long_only(argc, argv, "", NULL, NULL);
  return c;
}
EOF
if compile_prog "" "" "getopt_long_only"; then
  getopt_long_only="yes"
fi
print_config "getopt_long_only()" "$getopt_long_only"

##########################################
# inet_aton() probe
if test "$inet_aton" != "yes" ; then
  inet_aton="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#else
#include <sys/socket.h>
#include <arpa/inet.h>
#endif
#include <stdio.h>
int main(int argc, char **argv)
{
  struct in_addr in;
  return inet_aton(NULL, &in);
}
EOF
if compile_prog "" "" "inet_aton"; then
  inet_aton="yes"
fi
print_config "inet_aton" "$inet_aton"

##########################################
# socklen_t probe
if test "$socklen_t" != "yes" ; then
  socklen_t="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <sys/socket.h>
#endif
int main(int argc, char **argv)
{
  socklen_t len = 0;
  return len;
}
EOF
if compile_prog "" "" "socklen_t"; then
  socklen_t="yes"
fi
print_config "socklen_t" "$socklen_t"

##########################################
# Whether or not __thread is supported for TLS
if test "$tls_thread" != "yes" ; then
  tls_thread="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
static __thread int ret;
int main(int argc, char **argv)
{
  return ret;
}
EOF
if compile_prog "" "" "__thread"; then
  tls_thread="yes"
fi
print_config "__thread" "$tls_thread"

##########################################
# Check if we have required gtk/glib support for gfio
if test "$gfio" != "yes" ; then
  gfio="no"
fi
if test "$gfio_check" = "yes" ; then
  cat > $TMPC << EOF
#include <glib.h>
#include <cairo.h>
#include <gtk/gtk.h>
int main(void)
{
  gdk_threads_enter();
  gdk_threads_leave();

  return GTK_CHECK_VERSION(2, 18, 0) ? 0 : 1; /* 0 on success */
}
EOF
GTK_CFLAGS=$(${cross_prefix}pkg-config --cflags gtk+-2.0 gthread-2.0)
ORG_LDFLAGS=$LDFLAGS
LDFLAGS=$(echo $LDFLAGS | sed s/"-static"//g)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
GTK_LIBS=$(${cross_prefix}pkg-config --libs gtk+-2.0 gthread-2.0)
if test "$?" != "0" ; then
  echo "configure: gtk and gthread not found"
  exit 1
fi
gfio="yes"
if check_min_lib_version gtk+-2.0 2.18.0 "gfio"; then
  if compile_prog "$GTK_CFLAGS" "$GTK_LIBS" "gfio" ; then
    GFIO_LIBS="$LIBS $GTK_LIBS"
    CFLAGS="$CFLAGS $GTK_CFLAGS"
  else
    echo "Please install gtk and gdk libraries"
    gfio="no"
  fi
else
  gfio="no"
fi
LDFLAGS=$ORG_LDFLAGS
fi

if test "$gfio_check" = "yes" ; then
  print_config "gtk 2.18 or higher" "$gfio"
fi

##########################################
# Check whether we have getrusage(RUSAGE_THREAD)
if test "$rusage_thread" != "yes" ; then
  rusage_thread="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rusage ru;
  getrusage(RUSAGE_THREAD, &ru);
  return 0;
}
EOF
if compile_prog "" "" "RUSAGE_THREAD"; then
  rusage_thread="yes"
fi
print_config "RUSAGE_THREAD" "$rusage_thread"

##########################################
# Check whether we have SCHED_IDLE
if test "$sched_idle" != "yes" ; then
  sched_idle="no"
fi
cat > $TMPC << EOF
#include <sched.h>
int main(int argc, char **argv)
{
  struct sched_param p;
  return sched_setscheduler(0, SCHED_IDLE, &p);
}
EOF
if compile_prog "" "" "SCHED_IDLE"; then
  sched_idle="yes"
fi
print_config "SCHED_IDLE" "$sched_idle"

##########################################
# Check whether we have TCP_NODELAY
if test "$tcp_nodelay" != "yes" ; then
  tcp_nodelay="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#else
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#endif
int main(int argc, char **argv)
{
  return getsockopt(0, 0, TCP_NODELAY, NULL, NULL);
}
EOF
if compile_prog "" "" "TCP_NODELAY"; then
  tcp_nodelay="yes"
elif compile_prog "" "-lws2_32" "TCP_NODELAY"; then
  tcp_nodelay="yes"
  LIBS="$LIBS -lws2_32"
fi
print_config "TCP_NODELAY" "$tcp_nodelay"

##########################################
# Check whether we have SO_SNDBUF
if test "$window_size" != "yes" ; then
  window_size="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#else
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#endif
int main(int argc, char **argv)
{
  setsockopt(0, SOL_SOCKET, SO_SNDBUF, NULL, 0);
  setsockopt(0, SOL_SOCKET, SO_RCVBUF, NULL, 0);
}
EOF
if compile_prog "" "" "SO_SNDBUF"; then
  window_size="yes"
elif compile_prog "" "-lws2_32" "SO_SNDBUF"; then
  window_size="yes"
  LIBS="$LIBS -lws2_32"
fi
print_config "Net engine window_size" "$window_size"

##########################################
# Check whether we have TCP_MAXSEG
if test "$mss" != "yes" ; then
  mss="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#else
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <netinet/in.h>
#endif
int main(int argc, char **argv)
{
  return setsockopt(0, IPPROTO_TCP, TCP_MAXSEG, NULL, 0);
}
EOF
if compile_prog "" "" "TCP_MAXSEG"; then
  mss="yes"
elif compile_prog "" "-lws2_32" "TCP_MAXSEG"; then
  mss="yes"
  LIBS="$LIBS -lws2_32"
fi
print_config "TCP_MAXSEG" "$mss"

##########################################
# Check whether we have RLIMIT_MEMLOCK
if test "$rlimit_memlock" != "yes" ; then
  rlimit_memlock="no"
fi
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/resource.h>
int main(int argc, char **argv)
{
  struct rlimit rl;
  return getrlimit(RLIMIT_MEMLOCK, &rl);
}
EOF
if compile_prog "" "" "RLIMIT_MEMLOCK"; then
  rlimit_memlock="yes"
fi
print_config "RLIMIT_MEMLOCK" "$rlimit_memlock"

##########################################
# Check whether we have pwritev/preadv
if test "$pwritev" != "yes" ; then
  pwritev="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/uio.h>
int main(int argc, char **argv)
{
  return pwritev(0, NULL, 1, 0) + preadv(0, NULL, 1, 0);
}
EOF
if compile_prog "" "" "pwritev"; then
  pwritev="yes"
fi
print_config "pwritev/preadv" "$pwritev"

##########################################
# Check whether we have pwritev2/preadv2
if test "$pwritev2" != "yes" ; then
  pwritev2="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/uio.h>
int main(int argc, char **argv)
{
  return pwritev2(0, NULL, 1, 0, 0) + preadv2(0, NULL, 1, 0, 0);
}
EOF
if compile_prog "" "" "pwritev2"; then
  pwritev2="yes"
fi
print_config "pwritev2/preadv2" "$pwritev2"

##########################################
# Check whether we have the required functions for ipv6
if test "$ipv6" != "yes" ; then
  ipv6="no"
fi
cat > $TMPC << EOF
#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#else
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#endif
#include <stdio.h>
int main(int argc, char **argv)
{
  struct addrinfo hints;
  struct in6_addr addr;
  int ret;

  ret = getaddrinfo(NULL, NULL, &hints, NULL);
  freeaddrinfo(NULL);
  printf("%s\n", gai_strerror(ret));
  addr = in6addr_any;
  return 0;
}
EOF
if compile_prog "" "" "ipv6"; then
  ipv6="yes"
fi
print_config "IPv6 helpers" "$ipv6"

##########################################
# check for http
if test "$http" != "yes" ; then
  http="no"
fi
# check for openssl >= 1.1.0, which uses an opaque HMAC_CTX pointer
cat > $TMPC << EOF
#include <curl/curl.h>
#include <openssl/hmac.h>

int main(int argc, char **argv)
{
  CURL *curl;
  HMAC_CTX *ctx;

  curl = curl_easy_init();
  curl_easy_cleanup(curl);

  ctx = HMAC_CTX_new();
  HMAC_CTX_reset(ctx);
  HMAC_CTX_free(ctx);
  return 0;
}
EOF
# openssl < 1.1.0 uses the HMAC_CTX type directly
cat > $TMPC2 << EOF
#include <curl/curl.h>
#include <openssl/hmac.h>

int main(int argc, char **argv)
{
  CURL *curl;
  HMAC_CTX ctx;

  curl = curl_easy_init();
  curl_easy_cleanup(curl);

  HMAC_CTX_init(&ctx);
  HMAC_CTX_cleanup(&ctx);
  return 0;
}
EOF
if test "$disable_http" != "yes"; then
  HTTP_LIBS="-lcurl -lssl -lcrypto"
  if compile_prog "" "$HTTP_LIBS" "curl-new-ssl"; then
    output_sym "CONFIG_HAVE_OPAQUE_HMAC_CTX"
    http="yes"
  elif mv $TMPC2 $TMPC && compile_prog "" "$HTTP_LIBS" "curl-old-ssl"; then
    http="yes"
  fi
fi
print_config "http engine" "$http"

##########################################
# check for rados
if test "$rados" != "yes" ; then
  rados="no"
fi
cat > $TMPC << EOF
#include <rados/librados.h>

int main(int argc, char **argv)
{
  rados_t cluster;
  rados_ioctx_t io_ctx;
  const char cluster_name[] = "ceph";
  const char user_name[] = "client.admin";
  const char pool[] = "rados";

  /* The rados_create2 signature required was only introduced in ceph 0.65 */
  rados_create2(&cluster, cluster_name, user_name, 0);
  rados_ioctx_create(cluster, pool, &io_ctx);

  return 0;
}
EOF
if test "$disable_rados" != "yes"  && compile_prog "" "-lrados" "rados"; then
  rados="yes"
fi
print_config "Rados engine" "$rados"

##########################################
# check for rbd
if test "$rbd" != "yes" ; then
  rbd="no"
fi
cat > $TMPC << EOF
#include <rbd/librbd.h>

int main(int argc, char **argv)
{
  rados_t cluster;
  rados_ioctx_t io_ctx;
  const char cluster_name[] = "ceph";
  const char user_name[] = "client.admin";
  const char pool[] = "rbd";
  int major, minor, extra;

  rbd_version(&major, &minor, &extra);
  /* The rados_create2 signature required was only introduced in ceph 0.65 */
  rados_create2(&cluster, cluster_name, user_name, 0);
  rados_ioctx_create(cluster, pool, &io_ctx);

  return 0;
}
EOF
if test "$disable_rbd" != "yes"  && compile_prog "" "-lrbd -lrados" "rbd"; then
  rbd="yes"
fi
print_config "Rados Block Device engine" "$rbd"

##########################################
# check for rbd_poll
if test "$rbd_poll" != "yes" ; then
  rbd_poll="no"
fi
if test "$rbd" = "yes"; then
cat > $TMPC << EOF
#include <rbd/librbd.h>
#include <sys/eventfd.h>

int main(int argc, char **argv)
{
  rbd_image_t image;
  rbd_completion_t comp;

  int fd = eventfd(0, EFD_NONBLOCK);
  rbd_set_image_notification(image, fd, EVENT_TYPE_EVENTFD);
  rbd_poll_io_events(image, comp, 1);

  return 0;
}
EOF
if compile_prog "" "-lrbd -lrados" "rbd"; then
  rbd_poll="yes"
fi
print_config "rbd_poll" "$rbd_poll"
fi

##########################################
# check for rbd_invalidate_cache()
if test "$rbd_inval" != "yes" ; then
  rbd_inval="no"
fi
if test "$rbd" = "yes"; then
cat > $TMPC << EOF
#include <rbd/librbd.h>

int main(int argc, char **argv)
{
  rbd_image_t image;

  return rbd_invalidate_cache(image);
}
EOF
if compile_prog "" "-lrbd -lrados" "rbd"; then
  rbd_inval="yes"
fi
print_config "rbd_invalidate_cache" "$rbd_inval"
fi

##########################################
# Check whether we have setvbuf
if test "$setvbuf" != "yes" ; then
  setvbuf="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
int main(int argc, char **argv)
{
  FILE *f = NULL;
  char buf[80];
  setvbuf(f, buf, _IOFBF, sizeof(buf));
  return 0;
}
EOF
if compile_prog "" "" "setvbuf"; then
  setvbuf="yes"
fi
print_config "setvbuf" "$setvbuf"

##########################################
# check for gfapi
if test "$gfapi" != "yes" ; then
  gfapi="no"
fi
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  glfs_t *g = glfs_new("foo");

  return 0;
}
EOF
if test "$disable_gfapi" != "yes"  && compile_prog "" "-lgfapi -lglusterfs" "gfapi"; then
  gfapi="yes"
fi
print_config "Gluster API engine" "$gfapi"

##########################################
# check for gfapi fadvise support, initialize with "no" only if $gfapi is set to "yes"
if test "$gfapi" = "yes" ; then
gf_fadvise="no"
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  struct glfs_fd *fd;
  int ret = glfs_fadvise(fd, 0, 0, 1);

  return 0;
}
EOF
if compile_prog "" "-lgfapi -lglusterfs" "gfapi"; then
  gf_fadvise="yes"
fi
print_config "Gluster API use fadvise" "$gf_fadvise"
fi

##########################################
# check for newer gfapi
if test "$gfapi" = "yes" ; then
gf_new="no"
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  return glfs_fsync(NULL, NULL, NULL) && glfs_ftruncate(NULL, 0, NULL, NULL);
}
EOF
if compile_prog "" "-lgfapi -lglusterfs" "gf new api"; then
  gf_new="yes"
fi
print_config "Gluster new API" "$gf_new"
fi

##########################################
# check for gfapi trim support
if test "$gf_trim" != "yes" ; then
  gf_trim="no"
fi
if test "$gfapi" = "yes" ; then
cat > $TMPC << EOF
#include <glusterfs/api/glfs.h>

int main(int argc, char **argv)
{
  return glfs_discard_async(NULL, 0, 0);
}
EOF
if compile_prog "" "-lgfapi -lglusterfs" "gf trim"; then
  gf_trim="yes"
fi
print_config "Gluster API trim support" "$gf_trim"
fi

##########################################
# Check if we support stckf on s390
if test "$s390_z196_facilities" != "yes" ; then
  s390_z196_facilities="no"
fi
cat > $TMPC << EOF
#define STFLE_BITS_Z196 45 /* various z196 facilities ... */
int main(int argc, char **argv)
{
    /* We want just 1 double word to be returned.  */
    register unsigned long reg0 asm("0") = 0;
    unsigned long stfle_bits;
    asm volatile(".machine push"        "\n\t"
                 ".machine \"z9-109\""  "\n\t"
                 "stfle %0"             "\n\t"
                 ".machine pop"         "\n"
                 : "=QS" (stfle_bits), "+d" (reg0)
                 : : "cc");

    if ((stfle_bits & (1UL << (63 - STFLE_BITS_Z196))) != 0)
      return 0;
    else
      return -1;
}
EOF
if compile_prog "" "" "s390_z196_facilities"; then
  $TMPE
  if [ $? -eq 0 ]; then
  	s390_z196_facilities="yes"
  fi
fi
print_config "s390_z196_facilities" "$s390_z196_facilities"

##########################################
# Check if we have required environment variables configured for libhdfs
if test "$libhdfs" = "yes" ; then
  hdfs_conf_error=0
  if test "$JAVA_HOME" = "" ; then
    echo "configure: JAVA_HOME should be defined to jdk/jvm path"
    hdfs_conf_error=1
  fi
  if test "$FIO_LIBHDFS_INCLUDE" = "" ; then
    echo "configure: FIO_LIBHDFS_INCLUDE should be defined to libhdfs inlude path"
    hdfs_conf_error=1
  fi
  if test "$FIO_LIBHDFS_LIB" = "" ; then
    echo "configure: FIO_LIBHDFS_LIB should be defined to libhdfs library path"
    hdfs_conf_error=1
  fi
  if test "$hdfs_conf_error" = "1" ; then
    feature_not_found "libhdfs" ""
  fi
  FIO_HDFS_CPU=$cpu
  if test "$FIO_HDFS_CPU" = "x86_64" ; then
    FIO_HDFS_CPU="amd64"
  fi
fi
print_config "HDFS engine" "$libhdfs"

##########################################
# Check whether we have MTD
if test "$mtd" != "yes" ; then
  mtd="no"
fi
cat > $TMPC << EOF
#include <string.h>
#include <mtd/mtd-user.h>
#include <sys/ioctl.h>
int main(int argc, char **argv)
{
  struct mtd_write_req ops;
  struct mtd_info_user info;
  memset(&ops, 0, sizeof(ops));
  info.type = MTD_MLCNANDFLASH;
  return ioctl(0, MEMGETINFO, &info);
}
EOF
if compile_prog "" "" "mtd"; then
  mtd="yes"
fi
print_config "MTD" "$mtd"

##########################################
# Check whether we have libpmem
if test "$libpmem" != "yes" ; then
  libpmem="no"
fi
cat > $TMPC << EOF
#include <libpmem.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
  int rc;
  rc = pmem_is_pmem(NULL, NULL);
  return 0;
}
EOF
if compile_prog "" "-lpmem" "libpmem"; then
  libpmem="yes"
fi
print_config "libpmem" "$libpmem"

##########################################
# Check whether libpmem's version >= 1.5
if test "$libpmem1_5" != "yes" ; then
  libpmem1_5="no"
fi
if test "$libpmem" = "yes"; then
  cat > $TMPC << EOF
#include <libpmem.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
  pmem_memcpy(NULL, NULL, NULL, NULL);
  return 0;
}
EOF
  if compile_prog "" "-lpmem" "libpmem1_5"; then
    libpmem1_5="yes"
  fi
fi
print_config "libpmem1_5" "$libpmem1_5"

##########################################
# Check whether we have libpmemblk
# libpmem is a prerequisite
if test "$libpmemblk" != "yes" ; then
  libpmemblk="no"
fi
if test "$libpmem" = "yes"; then
  cat > $TMPC << EOF
#include <libpmemblk.h>
int main(int argc, char **argv)
{
  PMEMblkpool *pbp;
  pbp = pmemblk_open("", 0);
  return 0;
}
EOF
  if compile_prog "" "-lpmemblk" "libpmemblk"; then
    libpmemblk="yes"
  fi
fi
print_config "libpmemblk" "$libpmemblk"

# Choose libpmem-based ioengines
if test "$libpmem" = "yes" && test "$disable_pmem" = "no"; then
  devdax="yes"
  if test "$libpmem1_5" = "yes"; then
    pmem="yes"
  fi
  if test "$libpmemblk" = "yes"; then
    pmemblk="yes"
  fi
fi

##########################################
# Report whether pmemblk engine is enabled
print_config "PMDK pmemblk engine" "$pmemblk"

##########################################
# Report whether dev-dax engine is enabled
print_config "PMDK dev-dax engine" "$devdax"

##########################################
# Report whether libpmem engine is enabled
print_config "PMDK libpmem engine" "$pmem"

##########################################
# Check whether we support DDN's IME
if test "$libime" != "yes" ; then
  libime="no"
fi
cat > $TMPC << EOF
#include <ime_native.h>
int main(int argc, char **argv)
{
  int rc;
  ime_native_init();
  rc = ime_native_finalize();
  return 0;
}
EOF
if compile_prog "-I${ime_path}/include" "-L${ime_path}/lib -lim_client" "libime"; then
  libime="yes"
  CFLAGS="-I${ime_path}/include $CFLAGS"
  LDFLAGS="-Wl,-rpath ${ime_path}/lib -L${ime_path}/lib $LDFLAGS"
  LIBS="-lim_client $LIBS"
fi
print_config "DDN's Infinite Memory Engine" "$libime"

##########################################
# Check if we have libiscsi
if test "$libiscsi" != "no" ; then
  if check_min_lib_version libiscsi 1.9.0; then
    libiscsi="yes"
    libiscsi_cflags=$(pkg-config --cflags libiscsi)
    libiscsi_libs=$(pkg-config --libs libiscsi)
  else
    libiscsi="no"
  fi
fi
print_config "iscsi engine" "$libiscsi"

##########################################
# Check if we have libnbd (for NBD support)
if test "$libnbd" != "no" ; then
  if check_min_lib_version libnbd 0.9.8; then
    libnbd="yes"
    libnbd_cflags=$(pkg-config --cflags libnbd)
    libnbd_libs=$(pkg-config --libs libnbd)
  else
    libnbd="no"
  fi
fi
print_config "NBD engine" "$libnbd"

##########################################
# Check if we have lex/yacc available
yacc="no"
yacc_is_bison="no"
lex="no"
arith="no"
if test "$disable_lex" = "no" || test -z "$disable_lex" ; then
if test "$targetos" != "SunOS" ; then
if has lex; then
  lex="yes"
fi
if has bison; then
  yacc="yes"
  yacc_is_bison="yes"
elif has yacc; then
  yacc="yes"
fi
if test "$yacc" = "yes" && test "$lex" = "yes" ; then
  arith="yes"
fi

if test "$arith" = "yes" ; then
cat > $TMPC << EOF
extern int yywrap(void);

int main(int argc, char **argv)
{
  yywrap();
  return 0;
}
EOF
if compile_prog "" "-lfl" "flex"; then
  LIBS="-lfl $LIBS"
elif compile_prog "" "-ll" "lex"; then
  LIBS="-ll $LIBS"
else
  arith="no"
fi
fi
fi
fi

# Check if lex fails using -o
if test "$arith" = "yes" ; then
if test "$force_no_lex_o" = "yes" ; then
  lex_use_o="no"
else
if lex -o lex.yy.c exp/expression-parser.l 2> /dev/null; then
  lex_use_o="yes"
else
  lex_use_o="no"
fi
fi
fi

print_config "lex/yacc for arithmetic" "$arith"

##########################################
# Check whether we have setmntent/getmntent
if test "$getmntent" != "yes" ; then
  getmntent="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <mntent.h>
int main(int argc, char **argv)
{
  FILE *mtab = setmntent(NULL, "r");
  struct mntent *mnt = getmntent(mtab);
  endmntent(mtab);
  return 0;
}
EOF
if compile_prog "" "" "getmntent"; then
  getmntent="yes"
fi
print_config "getmntent" "$getmntent"

##########################################
# Check whether we have getmntinfo
# These are originally added for BSDs, but may also work
# on other operating systems with getmntinfo(3).

# getmntinfo(3) for FreeBSD/DragonFlyBSD/OpenBSD.
# Note that NetBSD needs -Werror to catch warning as error.
if test "$getmntinfo" != "yes" ; then
  getmntinfo="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/param.h>
#include <sys/mount.h>
int main(int argc, char **argv)
{
  struct statfs *st;
  return getmntinfo(&st, MNT_NOWAIT);
}
EOF
if compile_prog "-Werror" "" "getmntinfo"; then
  getmntinfo="yes"
fi
print_config "getmntinfo" "$getmntinfo"

# getmntinfo(3) for NetBSD.
if test "$getmntinfo_statvfs" != "yes" ; then
  getmntinfo_statvfs="no"
fi
cat > $TMPC << EOF
#include <stdio.h>
#include <sys/statvfs.h>
int main(int argc, char **argv)
{
  struct statvfs *st;
  return getmntinfo(&st, MNT_NOWAIT);
}
EOF
# Skip the test if the one with statfs arg is detected.
if test "$getmntinfo" != "yes" && compile_prog "-Werror" "" "getmntinfo_statvfs"; then
  getmntinfo_statvfs="yes"
  print_config "getmntinfo_statvfs" "$getmntinfo_statvfs"
fi

##########################################
# Check whether we have _Static_assert
if test "$static_assert" != "yes" ; then
  static_assert="no"
fi
cat > $TMPC << EOF
#include <assert.h>
#include <stdlib.h>
#include <stddef.h>

struct foo {
  int a, b;
};

int main(int argc, char **argv)
{
  _Static_assert(offsetof(struct foo, a) == 0 , "Check");
  return 0 ;
}
EOF
if compile_prog "" "" "static_assert"; then
    static_assert="yes"
fi
print_config "Static Assert" "$static_assert"

##########################################
# Check whether we have bool / stdbool.h
if test "$have_bool" != "yes" ; then
  have_bool="no"
fi
cat > $TMPC << EOF
#include <stdbool.h>
int main(int argc, char **argv)
{
  bool var = true;
  return var != false;
}
EOF
if compile_prog "" "" "bool"; then
  have_bool="yes"
fi
print_config "bool" "$have_bool"

##########################################
# Check whether we have strndup()
strndup="no"
cat > $TMPC << EOF
#include <string.h>
#include <stdlib.h>
int main(int argc, char **argv)
{
  char *res = strndup("test string", 8);

  free(res);
  return 0;
}
EOF
if compile_prog "" "" "strndup"; then
  strndup="yes"
fi
print_config "strndup" "$strndup"

##########################################
# <valgrind/drd.h> probe
# Note: presence of <valgrind/drd.h> implies that <valgrind/valgrind.h> is
# also available but not the other way around.
if test "$valgrind_dev" != "yes" ; then
  valgrind_dev="no"
fi
cat > $TMPC << EOF
#include <valgrind/drd.h>
int main(int argc, char **argv)
{
  return 0;
}
EOF
if compile_prog "" "" "valgrind_dev"; then
  valgrind_dev="yes"
fi
print_config "Valgrind headers" "$valgrind_dev"

if test "$targetos" = "Linux" ; then
##########################################
# <linux/blkzoned.h> probe
if test "$linux_blkzoned" != "yes" ; then
  linux_blkzoned="no"
fi
cat > $TMPC << EOF
#include <linux/blkzoned.h>
int main(int argc, char **argv)
{
  return 0;
}
EOF
if compile_prog "" "" "linux_blkzoned"; then
  linux_blkzoned="yes"
fi
print_config "Zoned block device support" "$linux_blkzoned"

##########################################
# Check BLK_ZONE_REP_CAPACITY
cat > $TMPC << EOF
#include <linux/blkzoned.h>
int main(void)
{
  return BLK_ZONE_REP_CAPACITY;
}
EOF
if compile_prog "" "" "blkzoned report capacity"; then
  output_sym "CONFIG_HAVE_REP_CAPACITY"
  rep_capacity="yes"
else
  rep_capacity="no"
fi
print_config "Zoned block device capacity" "$rep_capacity"
fi

##########################################
# libzbc probe
cat > $TMPC << EOF
#include <libzbc/zbc.h>
int main(int argc, char **argv)
{
  struct zbc_device *dev = NULL;

  return zbc_open("foo=bar", O_RDONLY, &dev);
}
EOF
if test "$libzbc" != "no" ; then
  if compile_prog "" "-lzbc" "libzbc"; then
    libzbc="yes"
    if ! check_min_lib_version libzbc 5; then
      libzbc="no"
    fi
  else
    if test "$libzbc" = "yes" ; then
      feature_not_found "libzbc" "libzbc or libzbc/zbc.h"
    fi
    libzbc="no"
  fi
fi
print_config "libzbc engine" "$libzbc"

##########################################
# check march=armv8-a+crc+crypto
if test "$march_armv8_a_crc_crypto" != "yes" ; then
  march_armv8_a_crc_crypto="no"
fi
if test "$cpu" = "arm64" ; then
  cat > $TMPC <<EOF
#include <arm_acle.h>
#include <arm_neon.h>
#include <sys/auxv.h>

int main(void)
{
  /* Can we also do a runtime probe? */
#if __linux__
  return getauxval(AT_HWCAP);
#else
# error "Don't know how to do runtime probe for ARM CRC32c"
#endif
}
EOF
  if compile_prog "-march=armv8-a+crc+crypto" "" "ARM CRC32c"; then
    march_armv8_a_crc_crypto="yes"
    CFLAGS="$CFLAGS -march=armv8-a+crc+crypto"
    march_set="yes"
  fi
fi
print_config "march_armv8_a_crc_crypto" "$march_armv8_a_crc_crypto"

##########################################
# cuda probe
if test "$cuda" != "no" ; then
cat > $TMPC << EOF
#include <cuda.h>
int main(int argc, char **argv)
{
  return cuInit(0);
}
EOF
  if compile_prog "" "-lcuda" "cuda"; then
    cuda="yes"
    LIBS="-lcuda $LIBS"
  else
    if test "$cuda" = "yes" ; then
      feature_not_found "cuda" ""
    fi
    cuda="no"
  fi
fi
print_config "cuda" "$cuda"

##########################################
# libcufile probe
if test "$libcufile" != "no" ; then
cat > $TMPC << EOF
#include <cufile.h>

int main(int argc, char* argv[]) {
   cuFileDriverOpen();
   return 0;
}
EOF
  if compile_prog "" "-lcuda -lcudart -lcufile" "libcufile"; then
    libcufile="yes"
    LIBS="-lcuda -lcudart -lcufile $LIBS"
  else
    if test "$libcufile" = "yes" ; then
      feature_not_found "libcufile" ""
    fi
    libcufile="no"
  fi
fi
print_config "libcufile" "$libcufile"

##########################################
# check for cc -march=native
build_native="no"
cat > $TMPC << EOF
int main(int argc, char **argv)
{
  return 0;
}
EOF
if test "$disable_native" = "no" && test "$disable_opt" != "yes" && \
   compile_prog "-march=native" "" "march=native"; then
  build_native="yes"
fi
print_config "Build march=native" "$build_native"

##########################################
# check for -lcunit
if test "$cunit" != "yes" ; then
  cunit="no"
fi
cat > $TMPC << EOF
#include <CUnit/CUnit.h>
#include <CUnit/Basic.h>
int main(void)
{
  if (CU_initialize_registry() != CUE_SUCCESS)
    return CU_get_error();
  CU_basic_set_mode(CU_BRM_VERBOSE);
  CU_basic_run_tests();
  CU_cleanup_registry();
  return CU_get_error();
}
EOF
if compile_prog "" "-lcunit" "CUnit"; then
  cunit="yes"
fi
print_config "CUnit" "$cunit"

##########################################
# check for __kernel_rwf_t
__kernel_rwf_t="no"
cat > $TMPC << EOF
#include <linux/fs.h>
int main(int argc, char **argv)
{
  __kernel_rwf_t x;
  x = 0;
  return x;
}
EOF
if compile_prog "" "" "__kernel_rwf_t"; then
  __kernel_rwf_t="yes"
fi
print_config "__kernel_rwf_t" "$__kernel_rwf_t"

##########################################
# check if gcc has -Wimplicit-fallthrough=2
fallthrough="no"
cat > $TMPC << EOF
int main(int argc, char **argv)
{
  return 0;
}
EOF
if compile_prog "-Wimplicit-fallthrough=2" "" "-Wimplicit-fallthrough=2"; then
  fallthrough="yes"
fi
print_config "-Wimplicit-fallthrough=2" "$fallthrough"

##########################################
# check for MADV_HUGEPAGE support
if test "$thp" != "yes" ; then
  thp="no"
fi
if test "$esx" != "yes" ; then
  cat > $TMPC <<EOF
#include <sys/mman.h>
int main(void)
{
  return madvise(0, 0x1000, MADV_HUGEPAGE);
}
EOF
  if compile_prog "" "" "thp" ; then
    thp=yes
  else
    if test "$thp" = "yes" ; then
      feature_not_found "Transparent Huge Page" ""
    fi
    thp=no
  fi
fi
print_config "MADV_HUGEPAGE" "$thp"

##########################################
# check for gettid()
gettid="no"
cat > $TMPC << EOF
#include <unistd.h>
int main(int argc, char **argv)
{
  return gettid();
}
EOF
if compile_prog "" "" "gettid"; then
  gettid="yes"
fi
print_config "gettid" "$gettid"

##########################################
# check for statx(2) support by libc
statx="no"
cat > $TMPC << EOF
#include <unistd.h>
#include <sys/stat.h>

int main(int argc, char **argv)
{
	struct statx st;
	return statx(-1, *argv, 0, 0, &st);
}
EOF
if compile_prog "" "" "statx"; then
  statx="yes"
fi
print_config "statx(2)/libc" "$statx"

##########################################
# check for statx(2) support by kernel
statx_syscall="no"
cat > $TMPC << EOF
#include <unistd.h>
#include <linux/stat.h>
#include <sys/stat.h>
#include <sys/syscall.h>

static int _statx(int dfd, const char *pathname, int flags, unsigned int mask,
		  struct statx *buffer)
{
	return syscall(__NR_statx, dfd, pathname, flags, mask, buffer);
}

int main(int argc, char **argv)
{
	struct statx st;
	return _statx(-1, *argv, 0, 0, &st);
}
EOF
if compile_prog "" "" "statx_syscall"; then
  statx_syscall="yes"
fi
print_config "statx(2)/syscall" "$statx_syscall"

##########################################
# check for Windows PDB generation support
if test "pdb" != "no" ; then
  cat > $TMPC <<EOF
int main(void)
{
  return 0;
}
EOF
  if compile_prog "-g -gcodeview" "-fuse-ld=lld -Wl,-pdb,$TMPO" "pdb"; then
    pdb=yes
  else
    if test "$pdb" = "yes"; then
      feature_not_found "PDB" "clang and lld"
    fi
    pdb=no
  fi
else
  pdb=no
fi
print_config "Windows PDB generation" "$pdb"

##########################################
# check for timerfd support
timerfd_create="no"
cat > $TMPC << EOF
#include <sys/time.h>
#include <sys/timerfd.h>

int main(int argc, char **argv)
{
	return timerfd_create(CLOCK_MONOTONIC, TFD_NONBLOCK);
}
EOF
if compile_prog "" "" "timerfd_create"; then
  timerfd_create="yes"
fi
print_config "timerfd_create" "$timerfd_create"

#############################################################################

if test "$wordsize" = "64" ; then
  output_sym "CONFIG_64BIT"
elif test "$wordsize" = "32" ; then
  output_sym "CONFIG_32BIT"
else
  fatal "Unknown wordsize!"
fi
if test "$bigendian" = "yes" ; then
  output_sym "CONFIG_BIG_ENDIAN"
else
  output_sym "CONFIG_LITTLE_ENDIAN"
fi
if test "$zlib" = "yes" ; then
  output_sym "CONFIG_ZLIB"
fi
if test "$libaio" = "yes" ; then
  output_sym "CONFIG_LIBAIO"
  if test "$libaio_rw_flags" = "yes" ; then
    output_sym "CONFIG_LIBAIO_RW_FLAGS"
  fi
fi
if test "$posix_aio" = "yes" ; then
  output_sym "CONFIG_POSIXAIO"
fi
if test "$posix_aio_fsync" = "yes" ; then
  output_sym "CONFIG_POSIXAIO_FSYNC"
fi
if test "$posix_pshared" = "yes" ; then
  output_sym "CONFIG_PSHARED"
fi
if test "$pthread_condattr_setclock" = "yes" ; then
  output_sym "CONFIG_PTHREAD_CONDATTR_SETCLOCK"
fi
if test "$pthread_sigmask" = "yes" ; then
  output_sym "CONFIG_PTHREAD_SIGMASK"
fi
if test "$have_asprintf" = "yes" ; then
    output_sym "CONFIG_HAVE_ASPRINTF"
fi
if test "$have_vasprintf" = "yes" ; then
    output_sym "CONFIG_HAVE_VASPRINTF"
fi
if test "$linux_fallocate" = "yes" ; then
  output_sym "CONFIG_LINUX_FALLOCATE"
fi
if test "$posix_fallocate" = "yes" ; then
  output_sym "CONFIG_POSIX_FALLOCATE"
fi
if test "$fdatasync" = "yes" ; then
  output_sym "CONFIG_FDATASYNC"
fi
if test "$pipe" = "yes" ; then
  output_sym "CONFIG_PIPE"
fi
if test "$pipe2" = "yes" ; then
  output_sym "CONFIG_PIPE2"
fi
if test "$pread" = "yes" ; then
  output_sym "CONFIG_PREAD"
fi
if test "$sync_file_range" = "yes" ; then
  output_sym "CONFIG_SYNC_FILE_RANGE"
fi
if test "$sfaa" = "yes" ; then
  output_sym "CONFIG_SFAA"
fi
if test "$sync_sync" = "yes" ; then
  output_sym "CONFIG_SYNC_SYNC"
fi
if test "$cmp_swap" = "yes" ; then
  output_sym "CONFIG_CMP_SWAP"
fi
if test "$libverbs" = "yes" -a "$rdmacm" = "yes" ; then
  output_sym "CONFIG_RDMA"
fi
if test "$clock_gettime" = "yes" ; then
  output_sym "CONFIG_CLOCK_GETTIME"
fi
if test "$clock_monotonic" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC"
fi
if test "$clock_monotonic_raw" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC_RAW"
fi
if test "$clock_monotonic_precise" = "yes" ; then
  output_sym "CONFIG_CLOCK_MONOTONIC_PRECISE"
fi
if test "$clockid_t" = "yes"; then
  output_sym "CONFIG_CLOCKID_T"
fi
if test "$gettimeofday" = "yes" ; then
  output_sym "CONFIG_GETTIMEOFDAY"
fi
if test "$posix_fadvise" = "yes" ; then
  output_sym "CONFIG_POSIX_FADVISE"
fi
if test "$linux_3arg_affinity" = "yes" ; then
  output_sym "CONFIG_3ARG_AFFINITY"
elif test "$linux_2arg_affinity" = "yes" ; then
  output_sym "CONFIG_2ARG_AFFINITY"
fi
if test "$strsep" = "yes" ; then
  output_sym "CONFIG_STRSEP"
fi
if test "$strcasestr" = "yes" ; then
  output_sym "CONFIG_STRCASESTR"
fi
if test "$strlcat" = "yes" ; then
  output_sym "CONFIG_STRLCAT"
fi
if test "$getopt_long_only" = "yes" ; then
  output_sym "CONFIG_GETOPT_LONG_ONLY"
fi
if test "$inet_aton" = "yes" ; then
  output_sym "CONFIG_INET_ATON"
fi
if test "$socklen_t" = "yes" ; then
  output_sym "CONFIG_SOCKLEN_T"
fi
if test "$ext4_me" = "yes" ; then
  output_sym "CONFIG_LINUX_EXT4_MOVE_EXTENT"
fi
if test "$linux_splice" = "yes" ; then
  output_sym "CONFIG_LINUX_SPLICE"
fi
if test "$libnuma_v2" = "yes" ; then
  output_sym "CONFIG_LIBNUMA"
fi
if test "$solaris_aio" = "yes" ; then
  output_sym "CONFIG_SOLARISAIO"
fi
if test "$tls_thread" = "yes" ; then
  output_sym "CONFIG_TLS_THREAD"
fi
if test "$rusage_thread" = "yes" ; then
  output_sym "CONFIG_RUSAGE_THREAD"
fi
if test "$gfio" = "yes" ; then
  output_sym "CONFIG_GFIO"
fi
if test "$esx" = "yes" ; then
  output_sym "CONFIG_ESX"
  output_sym "CONFIG_NO_SHM"
fi
if test "$sched_idle" = "yes" ; then
  output_sym "CONFIG_SCHED_IDLE"
fi
if test "$tcp_nodelay" = "yes" ; then
  output_sym "CONFIG_TCP_NODELAY"
fi
if test "$window_size" = "yes" ; then
  output_sym "CONFIG_NET_WINDOWSIZE"
fi
if test "$mss" = "yes" ; then
  output_sym "CONFIG_NET_MSS"
fi
if test "$rlimit_memlock" = "yes" ; then
  output_sym "CONFIG_RLIMIT_MEMLOCK"
fi
if test "$pwritev" = "yes" ; then
  output_sym "CONFIG_PWRITEV"
fi
if test "$pwritev2" = "yes" ; then
  output_sym "CONFIG_PWRITEV2"
fi
if test "$ipv6" = "yes" ; then
  output_sym "CONFIG_IPV6"
fi
if test "$http" = "yes" ; then
  output_sym "CONFIG_HTTP"
fi
if test "$rados" = "yes" ; then
  output_sym "CONFIG_RADOS"
fi
if test "$rbd" = "yes" ; then
  output_sym "CONFIG_RBD"
fi
if test "$rbd_poll" = "yes" ; then
  output_sym "CONFIG_RBD_POLL"
fi
if test "$rbd_inval" = "yes" ; then
  output_sym "CONFIG_RBD_INVAL"
fi
if test "$setvbuf" = "yes" ; then
  output_sym "CONFIG_SETVBUF"
fi
if test "$s390_z196_facilities" = "yes" ; then
  output_sym "CONFIG_S390_Z196_FACILITIES"
  CFLAGS="$CFLAGS -march=z9-109"
  march_set="yes"
fi
if test "$gfapi" = "yes" ; then
  output_sym "CONFIG_GFAPI"
fi
if test "$gf_fadvise" = "yes" ; then
  output_sym "CONFIG_GF_FADVISE"
fi
if test "$gf_trim" = "yes" ; then
  output_sym "CONFIG_GF_TRIM"
fi
if test "$gf_new" = "yes" ; then
  output_sym "CONFIG_GF_NEW_API"
fi
if test "$libhdfs" = "yes" ; then
  output_sym "CONFIG_LIBHDFS"
  echo "FIO_HDFS_CPU=$FIO_HDFS_CPU" >> $config_host_mak
  echo "JAVA_HOME=$JAVA_HOME" >> $config_host_mak
  echo "FIO_LIBHDFS_INCLUDE=$FIO_LIBHDFS_INCLUDE" >> $config_host_mak
  echo "FIO_LIBHDFS_LIB=$FIO_LIBHDFS_LIB" >> $config_host_mak
fi
if test "$mtd" = "yes" ; then
  output_sym "CONFIG_MTD"
fi
if test "$pmemblk" = "yes" ; then
  output_sym "CONFIG_PMEMBLK"
fi
if test "$devdax" = "yes" ; then
  output_sym "CONFIG_LINUX_DEVDAX"
fi
if test "$pmem" = "yes" ; then
  output_sym "CONFIG_LIBPMEM"
fi
if test "$libime" = "yes" ; then
  output_sym "CONFIG_IME"
fi
if test "$arith" = "yes" ; then
  output_sym "CONFIG_ARITHMETIC"
  if test "$yacc_is_bison" = "yes" ; then
    echo "YACC=bison -y" >> $config_host_mak
  else
    echo "YACC=yacc" >> $config_host_mak
  fi
  if test "$lex_use_o" = "yes" ; then
    echo "CONFIG_LEX_USE_O=y" >> $config_host_mak
  fi
fi
if test "$getmntent" = "yes" ; then
  output_sym "CONFIG_GETMNTENT"
fi
if test "$getmntinfo" = "yes" ; then
  output_sym "CONFIG_GETMNTINFO"
fi
if test "$getmntinfo_statvfs" = "yes" ; then
  output_sym "CONFIG_GETMNTINFO_STATVFS"
fi
if test "$static_assert" = "yes" ; then
  output_sym "CONFIG_STATIC_ASSERT"
fi
if test "$have_bool" = "yes" ; then
  output_sym "CONFIG_HAVE_BOOL"
fi
if test "$strndup" = "yes" ; then
  output_sym "CONFIG_HAVE_STRNDUP"
fi
if test "$disable_opt" = "yes" ; then
  output_sym "CONFIG_DISABLE_OPTIMIZATIONS"
fi
if test "$valgrind_dev" = "yes"; then
  output_sym "CONFIG_VALGRIND_DEV"
fi
if test "$linux_blkzoned" = "yes" ; then
  output_sym "CONFIG_HAS_BLKZONED"
fi
if test "$libzbc" = "yes" ; then
  output_sym "CONFIG_LIBZBC"
fi
if test "$zlib" = "no" ; then
  echo "Consider installing zlib-dev (zlib-devel, some fio features depend on it."
  if test "$build_static" = "yes"; then
    echo "Note that some distros have separate packages for static libraries."
  fi
fi
if test "$march_armv8_a_crc_crypto" = "yes" ; then
  output_sym "ARCH_HAVE_CRC_CRYPTO"
fi
if test "$cuda" = "yes" ; then
  output_sym "CONFIG_CUDA"
fi
if test "$libcufile" = "yes" ; then
  output_sym "CONFIG_LIBCUFILE"
fi
if test "$march_set" = "no" && test "$build_native" = "yes" ; then
  output_sym "CONFIG_BUILD_NATIVE"
fi
if test "$cunit" = "yes" ; then
  output_sym "CONFIG_HAVE_CUNIT"
fi
if test "$__kernel_rwf_t" = "yes"; then
  output_sym "CONFIG_HAVE_KERNEL_RWF_T"
fi
if test "$gettid" = "yes"; then
  output_sym "CONFIG_HAVE_GETTID"
fi
if test "$statx" = "yes"; then
  output_sym "CONFIG_HAVE_STATX"
fi
if test "$statx_syscall" = "yes"; then
  output_sym "CONFIG_HAVE_STATX_SYSCALL"
fi
if test "$timerfd_create" = "yes"; then
  output_sym "CONFIG_HAVE_TIMERFD_CREATE"
fi
if test "$fallthrough" = "yes"; then
  CFLAGS="$CFLAGS -Wimplicit-fallthrough"
fi
if test "$thp" = "yes" ; then
  output_sym "CONFIG_HAVE_THP"
fi
if test "$libiscsi" = "yes" ; then
  output_sym "CONFIG_LIBISCSI"
  echo "CONFIG_LIBISCSI=m" >> $config_host_mak
  echo "LIBISCSI_CFLAGS=$libiscsi_cflags" >> $config_host_mak
  echo "LIBISCSI_LIBS=$libiscsi_libs" >> $config_host_mak
fi
if test "$libnbd" = "yes" ; then
  output_sym "CONFIG_LIBNBD"
  echo "CONFIG_LIBNBD=m" >> $config_host_mak
  echo "LIBNBD_CFLAGS=$libnbd_cflags" >> $config_host_mak
  echo "LIBNBD_LIBS=$libnbd_libs" >> $config_host_mak
fi
if test "$dynamic_engines" = "yes" ; then
  output_sym "CONFIG_DYNAMIC_ENGINES"
fi
if test "$pdb" = yes; then
  output_sym "CONFIG_PDB"
fi

print_config "Lib-based ioengines dynamic" "$dynamic_engines"
cat > $TMPC << EOF
int main(int argc, char **argv)
{
  return 0;
}
EOF
if test "$disable_tcmalloc" != "yes"; then
  if compile_prog "" "-ltcmalloc" "tcmalloc"; then
    tcmalloc="yes"
    LIBS="-ltcmalloc $LIBS"
  elif compile_prog "" "-l:libtcmalloc_minimal.so.4" "tcmalloc_minimal4"; then
    tcmalloc="yes"
    LIBS="-l:libtcmalloc_minimal.so.4 $LIBS"
  else
    tcmalloc="no"
  fi
fi
print_config "TCMalloc support" "$tcmalloc"

echo "LIBS+=$LIBS" >> $config_host_mak
echo "GFIO_LIBS+=$GFIO_LIBS" >> $config_host_mak
echo "CFLAGS+=$CFLAGS" >> $config_host_mak
echo "LDFLAGS+=$LDFLAGS" >> $config_host_mak
echo "CC=$cc" >> $config_host_mak
echo "BUILD_CFLAGS=$BUILD_CFLAGS $CFLAGS" >> $config_host_mak
echo "INSTALL_PREFIX=$prefix" >> $config_host_mak

if [ `dirname $0` != "." -a ! -e Makefile ]; then
    cat > Makefile <<EOF
SRCDIR:=`dirname $0`
include \$(SRCDIR)/Makefile
EOF
fi
